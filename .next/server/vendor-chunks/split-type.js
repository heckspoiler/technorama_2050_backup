"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/split-type";
exports.ids = ["vendor-chunks/split-type"];
exports.modules = {

/***/ "(ssr)/./node_modules/split-type/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/split-type/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SplitType)\n/* harmony export */ });\n/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.4\n * @author Luke Peavey <lwpeavey@gmail.com>\n */ // Polyfill the following DOM methods that are not supported in IE 11.\n(function() {\n    function append() {\n        var length = arguments.length;\n        for(var i = 0; i < length; i++){\n            var node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);\n            else this.appendChild(document.createTextNode(String(node)));\n        }\n    }\n    function replaceChildren() {\n        while(this.lastChild){\n            this.removeChild(this.lastChild);\n        }\n        if (arguments.length) this.append.apply(this, arguments);\n    }\n    function replaceWith() {\n        var parent = this.parentNode;\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        var i = nodes.length;\n        if (!parent) return;\n        if (!i) parent.removeChild(this);\n        while(i--){\n            var node = nodes[i];\n            if (typeof node !== \"object\") {\n                node = this.ownerDocument.createTextNode(node);\n            } else if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n            if (!i) {\n                parent.replaceChild(node, this);\n            } else {\n                parent.insertBefore(this.previousSibling, node);\n            }\n        }\n    }\n    if (typeof Element !== \"undefined\") {\n        if (!Element.prototype.append) {\n            Element.prototype.append = append;\n            DocumentFragment.prototype.append = append;\n        }\n        if (!Element.prototype.replaceChildren) {\n            Element.prototype.replaceChildren = replaceChildren;\n            DocumentFragment.prototype.replaceChildren = replaceChildren;\n        }\n        if (!Element.prototype.replaceWith) {\n            Element.prototype.replaceWith = replaceWith;\n            DocumentFragment.prototype.replaceWith = replaceWith;\n        }\n    }\n})();\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */ function extend(target, object) {\n    return Object.getOwnPropertyNames(Object(target)).reduce(function(extended, key) {\n        var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n        var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n        return Object.defineProperty(extended, key, newValue || currentValue);\n    }, {});\n}\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */ function isString(value) {\n    return typeof value === \"string\";\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\n/**\n * Parses user supplied settings objects.\n */ function parseSettings() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var object = extend(settings); // `split` may be used as an alias for the `types` option\n    // Parse the `types` settings into an array of valid split types.\n    // If `types` is explicitly set to an empty string or array, text will not be\n    // split at all.\n    var types;\n    if (object.types !== undefined) {\n        types = object.types;\n    } else if (object.split !== undefined) {\n        types = object.split;\n    }\n    if (types !== undefined) {\n        object.types = (isString(types) || isArray(types) ? String(types) : \"\").split(\",\").map(function(type) {\n            return String(type).trim();\n        }).filter(function(type) {\n            return /((line)|(word)|(char))/i.test(type);\n        });\n    } // Support `position: absolute` as an alias for `absolute: true`\n    if (object.absolute || object.position) {\n        object.absolute = object.absolute || /absolute/.test(settings.position);\n    }\n    return object;\n}\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */ function parseTypes(value) {\n    var types = isString(value) || isArray(value) ? String(value) : \"\";\n    return {\n        none: !types,\n        lines: /line/i.test(types),\n        words: /word/i.test(types),\n        chars: /char/i.test(types)\n    };\n}\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */ function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */ function isNode(input) {\n    return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */ function isLength(value) {\n    return typeof value === \"number\" && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */ function isArrayLike(value) {\n    return isObject(value) && isLength(value.length);\n}\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */ function toArray(value) {\n    if (isArray(value)) return value;\n    if (value == null) return [];\n    return isArrayLike(value) ? Array.prototype.slice.call(value) : [\n        value\n    ];\n}\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */ function getTargetElements(target) {\n    var elements = target; // If `target` is a selector string...\n    if (isString(target)) {\n        if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n            // If `target` is an ID, use `getElementById`\n            elements = document.getElementById(target.trim().slice(1));\n        } else {\n            // Else use `querySelectorAll`\n            elements = document.querySelectorAll(target);\n        }\n    } // Return a flattened array of elements\n    return toArray(elements).reduce(function(result, element) {\n        return [].concat(_toConsumableArray(result), _toConsumableArray(toArray(element).filter(isNode)));\n    }, []);\n}\nvar entries = Object.entries;\nvar expando = \"_splittype\";\nvar cache = {};\nvar uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */ function set(owner, key, value) {\n    if (!isObject(owner)) {\n        console.warn(\"[data.set] owner is not an object\");\n        return null;\n    }\n    var id = owner[expando] || (owner[expando] = ++uid);\n    var data = cache[id] || (cache[id] = {});\n    if (value === undefined) {\n        if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n            cache[id] = _objectSpread2(_objectSpread2({}, data), key);\n        }\n    } else if (key !== undefined) {\n        data[key] = value;\n    }\n    return value;\n}\nfunction get(owner, key) {\n    var id = isObject(owner) ? owner[expando] : null;\n    var data = id && cache[id] || {};\n    if (key === undefined) {\n        return data;\n    }\n    return data[key];\n}\n/**\n * Remove all data associated with the given element\n */ function remove(element) {\n    var id = element && element[expando];\n    if (id) {\n        delete element[id];\n        delete cache[id];\n    }\n}\n/**\n * Clear all cached data\n */ function clear() {\n    Object.keys(cache).forEach(function(key) {\n        delete cache[key];\n    });\n}\n/**\n * Remove all temporary data from the store.\n */ function cleanup() {\n    entries(cache).forEach(function(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2), id = _ref2[0], _ref2$ = _ref2[1], isRoot = _ref2$.isRoot, isSplit = _ref2$.isSplit;\n        if (!isRoot || !isSplit) {\n            cache[id] = null;\n            delete cache[id];\n        }\n    });\n}\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */ function toWords(value) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n    var string = value ? String(value) : \"\";\n    return string.trim().replace(/\\s+/g, \" \").split(separator);\n}\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */ var rsAstralRange = \"\\ud800-\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsAstral = \"[\".concat(rsAstralRange, \"]\");\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\nvar rsFitz = \"\\ud83c[\\udffb-\\udfff]\";\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\nvar rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\";\nvar rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\";\nvar rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var reOptMod = \"\".concat(rsModifier, \"?\");\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\nvar rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\";\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\".concat([\n    \"\".concat(rsNonAstral).concat(rsCombo, \"?\"),\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\"), \"\\n)\");\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), \"g\");\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var unicodeRange = [\n    rsZWJ,\n    rsAstralRange,\n    rsComboMarksRange,\n    rsComboSymbolsRange,\n    rsVarRange\n];\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(\"\"), \"]\"));\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function asciiToArray(string) {\n    return string.split(\"\");\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */ function hasUnicode(string) {\n    return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function stringToArray(string) {\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString(value) {\n    return value == null ? \"\" : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */ function toChars(string) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    string = toString(string);\n    if (string && isString(string)) {\n        if (!separator && hasUnicode(string)) {\n            return stringToArray(string);\n        }\n    }\n    return string.split(separator);\n}\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */ function createElement(name, attributes) {\n    var element = document.createElement(name);\n    if (!attributes) {\n        // When called without the second argument, its just return the result\n        // of `document.createElement`\n        return element;\n    }\n    Object.keys(attributes).forEach(function(attribute) {\n        var rawValue = attributes[attribute];\n        var value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n        if (value === null || value === \"\") return;\n        if (attribute === \"children\") {\n            // Children can be one or more Elements or DOM strings\n            element.append.apply(element, _toConsumableArray(toArray(value)));\n        } else {\n            // Handle standard HTML attributes\n            element.setAttribute(attribute, value);\n        }\n    });\n    return element;\n}\nvar defaults = {\n    splitClass: \"\",\n    lineClass: \"line\",\n    wordClass: \"word\",\n    charClass: \"char\",\n    types: [\n        \"lines\",\n        \"words\",\n        \"chars\"\n    ],\n    absolute: false,\n    tagName: \"div\"\n};\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */ function splitWordsAndChars(textNode, settings) {\n    settings = extend(defaults, settings); // The split types\n    var types = parseTypes(settings.types); // the tag name for split text nodes\n    var TAG_NAME = settings.tagName; // value of the text node\n    var VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n    var splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n    var words = [];\n    var chars = [];\n    if (/^\\s/.test(VALUE)) {\n        splitText.append(\" \");\n    } // Create an array of wrapped word elements.\n    words = toWords(VALUE).reduce(function(result, WORD, idx, arr) {\n        // Let `wordElement` be the wrapped element for the current word\n        var wordElement;\n        var characterElementsForCurrentWord; // -> If splitting text into characters...\n        if (types.chars) {\n            // Iterate through the characters in the current word\n            characterElementsForCurrentWord = toChars(WORD).map(function(CHAR) {\n                var characterElement = createElement(TAG_NAME, {\n                    \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n                    style: \"display: inline-block;\",\n                    children: CHAR\n                });\n                set(characterElement, \"isChar\", true);\n                chars = [].concat(_toConsumableArray(chars), [\n                    characterElement\n                ]);\n                return characterElement;\n            });\n        } // END IF;\n        if (types.words || types.lines) {\n            // -> If Splitting Text Into Words...\n            //    Create an element to wrap the current word. If we are also\n            //    splitting text into characters, the word element will contain the\n            //    wrapped character nodes for this word. If not, it will contain the\n            //    plain text content (WORD)\n            wordElement = createElement(TAG_NAME, {\n                \"class\": \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n                style: \"display: inline-block; \".concat(types.words && settings.absolute ? \"position: relative;\" : \"\"),\n                children: types.chars ? characterElementsForCurrentWord : WORD\n            });\n            set(wordElement, {\n                isWord: true,\n                isWordStart: true,\n                isWordEnd: true\n            });\n            splitText.appendChild(wordElement);\n        } else {\n            // -> If NOT splitting into words OR lines...\n            //    Append the characters elements directly to splitText.\n            characterElementsForCurrentWord.forEach(function(characterElement) {\n                splitText.appendChild(characterElement);\n            });\n        }\n        if (idx < arr.length - 1) {\n            // Add a space after the word.\n            splitText.append(\" \");\n        } // If not splitting text into words, we return an empty array\n        return types.words ? result.concat(wordElement) : result;\n    }, []); // END LOOP;\n    // Add a trailing white space to maintain word spacing\n    if (/\\s$/.test(VALUE)) {\n        splitText.append(\" \");\n    }\n    textNode.replaceWith(splitText);\n    return {\n        words: words,\n        chars: chars\n    };\n}\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */ function split(node, settings) {\n    var type = node.nodeType; // Arrays of split words and characters\n    var wordsAndChars = {\n        words: [],\n        chars: []\n    }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n    if (!/(1|3|11)/.test(type)) {\n        return wordsAndChars;\n    } // A) IF `node` is TextNode that contains characters other than white space...\n    //    Split the text content of the node into words and/or characters\n    //    return an object containing the split word and character elements\n    if (type === 3 && /\\S/.test(node.nodeValue)) {\n        return splitWordsAndChars(node, settings);\n    } // B) ELSE `node` is an 'Element'\n    //    Iterate through its child nodes, calling the `split` function\n    //    recursively for each child node.\n    var childNodes = toArray(node.childNodes);\n    if (childNodes.length) {\n        set(node, \"isSplit\", true); // we need to set a few styles on nested html elements\n        if (!get(node).isRoot) {\n            node.style.display = \"inline-block\";\n            node.style.position = \"relative\"; // To maintain original spacing around nested elements when we are\n            // splitting text into lines, we need to check if the element should\n            // have a space before and after, and store that value for later.\n            // Note: this was necessary to maintain the correct spacing when nested\n            // elements do not align with word boundaries. For example, a nested\n            // element only wraps part of a word.\n            var nextSibling = node.nextSibling;\n            var prevSibling = node.previousSibling;\n            var text = node.textContent || \"\";\n            var textAfter = nextSibling ? nextSibling.textContent : \" \";\n            var textBefore = prevSibling ? prevSibling.textContent : \" \";\n            set(node, {\n                isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n                isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n            });\n        }\n    } // Iterate through child nodes, calling `split` recursively\n    // Returns an object containing all split words and chars\n    return childNodes.reduce(function(result, child) {\n        var _split = split(child, settings), words = _split.words, chars = _split.chars;\n        return {\n            words: [].concat(_toConsumableArray(result.words), _toConsumableArray(words)),\n            chars: [].concat(_toConsumableArray(result.chars), _toConsumableArray(chars))\n        };\n    }, wordsAndChars);\n}\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */ function getPosition(node, isWord, settings, scrollPos) {\n    if (!settings.absolute) {\n        return {\n            top: isWord ? node.offsetTop : null\n        };\n    }\n    var parent = node.offsetParent;\n    var _scrollPos = _slicedToArray(scrollPos, 2), scrollX = _scrollPos[0], scrollY = _scrollPos[1];\n    var parentX = 0;\n    var parentY = 0;\n    if (parent && parent !== document.body) {\n        var parentRect = parent.getBoundingClientRect();\n        parentX = parentRect.x + scrollX;\n        parentY = parentRect.y + scrollY;\n    }\n    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height, x = _node$getBoundingClie.x, y = _node$getBoundingClie.y;\n    var top = y + scrollY - parentY;\n    var left = x + scrollX - parentX;\n    return {\n        width: width,\n        height: height,\n        top: top,\n        left: left\n    };\n}\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */ function unSplitWords(element) {\n    if (!get(element).isWord) {\n        toArray(element.children).forEach(function(child) {\n            return unSplitWords(child);\n        });\n    } else {\n        remove(element);\n        element.replaceWith.apply(element, _toConsumableArray(element.childNodes));\n    }\n}\nvar createFragment = function createFragment() {\n    return document.createDocumentFragment();\n};\nfunction repositionAfterSplit(element, settings, scrollPos) {\n    var types = parseTypes(settings.types);\n    var TAG_NAME = settings.tagName;\n    var nodes = element.getElementsByTagName(\"*\");\n    var wordsInEachLine = [];\n    var wordsInCurrentLine = [];\n    var lineOffsetY = null;\n    var elementHeight;\n    var elementWidth;\n    var contentBox;\n    var lines = [];\n    /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/ // There is no built-in way to detect natural line breaks in text (when a\n    // block of text wraps to fit its container). To split text into lines, we\n    // have to detect line breaks by checking the top offset of words. This is\n    // why text was split into words first. To apply absolute\n    // positioning, its also necessary to record the size and position of every\n    // split node (lines, words, characters).\n    // To consolidate DOM getting/settings, this is all done at the same time,\n    // before actually splitting text into lines, which involves restructuring\n    // the DOM again.\n    // Cache the element's parent and next sibling (for DOM removal).\n    var parent = element.parentElement;\n    var nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n    var splitText = createFragment(); // get the computed style object for the element\n    var cs = window.getComputedStyle(element);\n    var align = cs.textAlign;\n    var fontSize = parseFloat(cs.fontSize);\n    var lineThreshold = fontSize * 0.2; // IF using absolute position...\n    if (settings.absolute) {\n        // Let contentBox be an object containing the width and offset position of\n        // the element's content box (the area inside padding box). This is needed\n        // (for absolute positioning) to set the width and position of line\n        // elements, which have not been created yet.\n        contentBox = {\n            left: element.offsetLeft,\n            top: element.offsetTop,\n            width: element.offsetWidth\n        }; // Let elementWidth and elementHeight be the actual width/height of the\n        // element. Also check if the element has inline height or width styles\n        // already set. If it does, cache those values for later.\n        elementWidth = element.offsetWidth;\n        elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n        set(element, {\n            cssWidth: element.style.width,\n            cssHeight: element.style.height\n        });\n    } // Iterate over every node in the target element\n    toArray(nodes).forEach(function(node) {\n        // node is a word element or custom html element\n        var isWordLike = node.parentElement === element; // TODO needs work\n        // Get te size and position of split text nodes\n        var _getPosition = getPosition(node, isWordLike, settings, scrollPos), width = _getPosition.width, height = _getPosition.height, top = _getPosition.top, left = _getPosition.left; // If element is a `<br>` tag return here\n        if (/^br$/i.test(node.nodeName)) return;\n        if (types.lines && isWordLike) {\n            // We compare the top offset of the current word to the top offset of\n            // previous words on the current line. If the difference is greater than\n            // our defined threshold (20%), we assume this word is on a new line.\n            if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n                lineOffsetY = top;\n                wordsInEachLine.push(wordsInCurrentLine = []);\n            } // Add the current word node to the line array\n            wordsInCurrentLine.push(node);\n        } // END IF\n        if (settings.absolute) {\n            // Store the size and position split text nodes\n            set(node, {\n                top: top,\n                left: left,\n                width: width,\n                height: height\n            });\n        }\n    }); // END LOOP\n    // Remove the element from the DOM\n    if (parent) {\n        parent.removeChild(element);\n    }\n    /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/ if (types.lines) {\n        // Iterate over lines of text (see 11 b)\n        // Let `line` be the array of words in the current line.\n        // Return an array of the wrapped line elements (lineElements)\n        lines = wordsInEachLine.map(function(wordsInThisLine) {\n            // Create an element to wrap the current line.\n            var lineElement = createElement(TAG_NAME, {\n                \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n                style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n            });\n            set(lineElement, \"isLine\", true);\n            var lineDimensions = {\n                height: 0,\n                top: 1e4\n            }; // Append the `lineElement` to `container`\n            splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n            // Note: wordOrElement can either be a word node or nested element\n            wordsInThisLine.forEach(function(wordOrElement, idx, arr) {\n                var _data$get = get(wordOrElement), isWordEnd = _data$get.isWordEnd, top = _data$get.top, height = _data$get.height;\n                var next = arr[idx + 1]; // Determine line height / y-position\n                // we use the height and offsetTop of the words which we already\n                // recorded. Because custom nested elements could have their own\n                // styles, the words on a line may not all be the same height or\n                // y position. So we take the greatest height / y - offset of the\n                // words on this line.\n                lineDimensions.height = Math.max(lineDimensions.height, height);\n                lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n                lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n                // If this is not the last word on the current line.\n                // TODO - logic for handing spacing can be improved\n                if (isWordEnd && get(next).isWordStart) {\n                    lineElement.append(\" \");\n                }\n            }); // END LOOP\n            if (settings.absolute) {\n                set(lineElement, {\n                    height: lineDimensions.height,\n                    top: lineDimensions.top\n                });\n            }\n            return lineElement;\n        }); // END LOOP\n        if (!types.words) {\n            unSplitWords(splitText);\n        } // 10. Insert the new container\n        element.replaceChildren(splitText);\n    }\n    /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/ // Apply absolute positioning to all child elements of the target element.\n    // This includes split lines, words, chars, and custom HTML elements that were\n    // included by the user. The size and position of child elements has already\n    // been recorded before splitting text into lines.\n    if (settings.absolute) {\n        // Set the width/height of the parent element so it does not collapse\n        // when its children are set to absolute position.\n        element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n        element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all child elements\n        toArray(nodes).forEach(function(node) {\n            var _data$get2 = get(node), isLine = _data$get2.isLine, top = _data$get2.top, left = _data$get2.left, width = _data$get2.width, height = _data$get2.height;\n            var parentData = get(node.parentElement);\n            var isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n            // -> If `node` a line element, we use the top offset of its first child\n            // -> If `node` the child of line element, then its top offset is zero\n            node.style.top = \"\".concat(isChildOfLineNode ? top - parentData.top : top, \"px\"); // Set the left position of the current node.\n            // -> IF `node` is a line element, this is equal to the position left of\n            //    the content box of the parent element\n            // -> IF `node` is the child of a line element, the value has to adjusted\n            //    so its relative to the line element\n            node.style.left = isLine ? \"\".concat(contentBox.left, \"px\") : \"\".concat(left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n            node.style.height = \"\".concat(height, \"px\"); //  Set the width of the current node.\n            //  If its a line element, width is equal to the width of the contentBox.\n            node.style.width = isLine ? \"\".concat(contentBox.width, \"px\") : \"\".concat(width, \"px\"); // Finally, set the node's position to absolute.\n            node.style.position = \"absolute\";\n        });\n    } // end if;\n    // 14. Re-attach the element to the DOM\n    if (parent) {\n        if (nextSibling) parent.insertBefore(element, nextSibling);\n        else parent.appendChild(element);\n    }\n    return lines;\n}\nvar _defaults = extend(defaults, {});\nvar SplitType = /*#__PURE__*/ function() {\n    _createClass(SplitType, null, [\n        {\n            key: \"clearData\",\n            /**\n     * CLears all data\n     */ value: function clearData() {\n                clear();\n            }\n        },\n        {\n            key: \"setDefaults\",\n            /**\n     * Sets the default settings for all SplitType instances.\n     * The provided object will be merged with the existing defaults objects.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @returns {Object} the new default settings\n     * @public\n     * @static\n     * @example\n     * SplitType.setDefaults({ \"position\": \"absolute\" })\n     */ value: function setDefaults(options) {\n                _defaults = extend(_defaults, parseSettings(options));\n                return defaults;\n            }\n        },\n        {\n            key: \"revert\",\n            value: function revert(elements) {\n                getTargetElements(elements).forEach(function(element) {\n                    var _data$get = get(element), isSplit = _data$get.isSplit, html = _data$get.html, cssWidth = _data$get.cssWidth, cssHeight = _data$get.cssHeight;\n                    if (isSplit) {\n                        element.innerHTML = html;\n                        element.style.width = cssWidth || \"\";\n                        element.style.height = cssHeight || \"\";\n                        remove(element);\n                    }\n                });\n            }\n        },\n        {\n            key: \"create\",\n            value: function create(target, options) {\n                return new SplitType(target, options);\n            }\n        },\n        {\n            key: \"data\",\n            /**\n     * The internal data store\n     */ get: function get() {\n                return cache;\n            }\n        },\n        {\n            key: \"defaults\",\n            get: function get() {\n                return _defaults;\n            },\n            set: function set(options) {\n                _defaults = extend(_defaults, parseSettings(options));\n            }\n        }\n    ]);\n    function SplitType(elements, options) {\n        _classCallCheck(this, SplitType);\n        this.isSplit = false;\n        this.settings = extend(_defaults, parseSettings(options));\n        this.elements = getTargetElements(elements); // Start the split process\n        this.split();\n    }\n    /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */ _createClass(SplitType, [\n        {\n            key: \"split\",\n            value: function split$1(options) {\n                var _this = this;\n                // Revert target elements (if they are already split)\n                // Note: revert was already called once in the constructor. However, we\n                // need to call it again here so text is reverted when the user manually\n                // calls the `split` method to re-split text.\n                this.revert(); // Store the original html content of each target element\n                this.elements.forEach(function(element) {\n                    set(element, \"html\", element.innerHTML);\n                }); // Create arrays to hold the split lines, words, and characters\n                this.lines = [];\n                this.words = [];\n                this.chars = []; // cache vertical scroll position before splitting\n                var scrollPos = [\n                    window.pageXOffset,\n                    window.pageYOffset\n                ]; // If new options were passed into the `split()` method, update settings\n                if (options !== undefined) {\n                    this.settings = extend(this.settings, parseSettings(options));\n                }\n                var types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n                // @example new SplitType('#target', { types: [] })\n                if (types.none) {\n                    return;\n                } // Split text in each target element\n                this.elements.forEach(function(element) {\n                    // Add the split text nodes from this element to the arrays of all split\n                    // text nodes for this instance.\n                    set(element, \"isRoot\", true);\n                    var _split2 = split(element, _this.settings), words = _split2.words, chars = _split2.chars;\n                    _this.words = [].concat(_toConsumableArray(_this.words), _toConsumableArray(words));\n                    _this.chars = [].concat(_toConsumableArray(_this.chars), _toConsumableArray(chars));\n                });\n                this.elements.forEach(function(element) {\n                    if (types.lines || _this.settings.absolute) {\n                        var lines = repositionAfterSplit(element, _this.settings, scrollPos);\n                        _this.lines = [].concat(_toConsumableArray(_this.lines), _toConsumableArray(lines));\n                    }\n                }); // Set isSplit to true for the SplitType instance\n                this.isSplit = true; // Set scroll position to cached value.\n                window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n                cleanup();\n            }\n        },\n        {\n            key: \"revert\",\n            value: function revert() {\n                if (this.isSplit) {\n                    // Reset instance properties if necessary\n                    this.lines = null;\n                    this.words = null;\n                    this.chars = null;\n                    this.isSplit = false;\n                }\n                SplitType.revert(this.elements);\n            }\n        }\n    ]);\n    return SplitType;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3BsaXQtdHlwZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVELHNFQUFzRTtBQUVyRTtJQUNDLFNBQVNBO1FBQ1AsSUFBSUMsU0FBU0MsVUFBVUQsTUFBTTtRQUU3QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsUUFBUUUsSUFBSztZQUMvQixJQUFJQyxPQUFPRCxJQUFJLEtBQUtELFVBQVVELE1BQU0sSUFBSUUsSUFBSUUsWUFBWUgsU0FBUyxDQUFDQyxFQUFFO1lBQ3BFLElBQUlDLEtBQUtFLFFBQVEsS0FBSyxLQUFLRixLQUFLRSxRQUFRLEtBQUssSUFBSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0g7aUJBQVcsSUFBSSxDQUFDRyxXQUFXLENBQUNDLFNBQVNDLGNBQWMsQ0FBQ0MsT0FBT047UUFDL0g7SUFDRjtJQUVBLFNBQVNPO1FBQ1AsTUFBTyxJQUFJLENBQUNDLFNBQVMsQ0FBRTtZQUNyQixJQUFJLENBQUNDLFdBQVcsQ0FBQyxJQUFJLENBQUNELFNBQVM7UUFDakM7UUFFQSxJQUFJVixVQUFVRCxNQUFNLEVBQUUsSUFBSSxDQUFDRCxNQUFNLENBQUNjLEtBQUssQ0FBQyxJQUFJLEVBQUVaO0lBQ2hEO0lBRUEsU0FBU2E7UUFDUCxJQUFJQyxTQUFTLElBQUksQ0FBQ0MsVUFBVTtRQUU1QixJQUFLLElBQUlDLE9BQU9oQixVQUFVRCxNQUFNLEVBQUVrQixRQUFRLElBQUlDLE1BQU1GLE9BQU9HLE9BQU8sR0FBR0EsT0FBT0gsTUFBTUcsT0FBUTtZQUN4RkYsS0FBSyxDQUFDRSxLQUFLLEdBQUduQixTQUFTLENBQUNtQixLQUFLO1FBQy9CO1FBRUEsSUFBSWxCLElBQUlnQixNQUFNbEIsTUFBTTtRQUNwQixJQUFJLENBQUNlLFFBQVE7UUFDYixJQUFJLENBQUNiLEdBQUdhLE9BQU9ILFdBQVcsQ0FBQyxJQUFJO1FBRS9CLE1BQU9WLElBQUs7WUFDVixJQUFJQyxPQUFPZSxL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RyxFQUFFLENBQUNlLE1BQU0sQ0FBQy9ELG1CQUFtQmlPLE1BQU1qTCxLQUFLLEdBQUdoRCxtQkFBbUJnRDtvQkFDOUU7Z0JBQ0YsSUFBSSxpREFBaUQ7Z0JBRXJELElBQUksQ0FBQ21DLE9BQU8sR0FBRyxNQUFNLHVDQUF1QztnQkFFNUR5RyxPQUFPeUMsUUFBUSxDQUFDeEUsU0FBUyxDQUFDLEVBQUUsRUFBRUEsU0FBUyxDQUFDLEVBQUUsR0FBRyx1QkFBdUI7Z0JBRXBFL0U7WUFDRjtRQVNGO1FBQUc7WUFDRDFHLEtBQUs7WUFDTE0sT0FBTyxTQUFTa1A7Z0JBQ2QsSUFBSSxJQUFJLENBQUN6SSxPQUFPLEVBQUU7b0JBQ2hCLHlDQUF5QztvQkFDekMsSUFBSSxDQUFDbkMsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO29CQUNiLElBQUksQ0FBQ2lDLE9BQU8sR0FBRztnQkFDakI7Z0JBRUFxSSxVQUFVSSxNQUFNLENBQUMsSUFBSSxDQUFDbEssUUFBUTtZQUNoQztRQUNGO0tBQUU7SUFFRixPQUFPOEo7QUFDVDtBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlY2hub3JhbWFfMjA1MC8uL25vZGVfbW9kdWxlcy9zcGxpdC10eXBlL2Rpc3QvaW5kZXguanM/ODk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNwbGl0VHlwZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2x1a2VQZWF2ZXkvU3BsaXRUeXBlXG4gKiBAdmVyc2lvbiAwLjMuNFxuICogQGF1dGhvciBMdWtlIFBlYXZleSA8bHdwZWF2ZXlAZ21haWwuY29tPlxuICovXG5cbi8vIFBvbHlmaWxsIHRoZSBmb2xsb3dpbmcgRE9NIG1ldGhvZHMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBpbiBJRSAxMS5cblxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBub2RlLm5vZGVUeXBlID09PSAxMSkgdGhpcy5hcHBlbmRDaGlsZChub2RlKTtlbHNlIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKG5vZGUpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUNoaWxkcmVuKCkge1xuICAgIHdoaWxlICh0aGlzLmxhc3RDaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmxhc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHRoaXMuYXBwZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbm9kZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBpZiAoIWkpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpKSB7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMucHJldmlvdXNTaWJsaW5nLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5hcHBlbmQpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgICB9XG5cbiAgICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZHJlbikge1xuICAgICAgRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkcmVuID0gcmVwbGFjZUNoaWxkcmVuO1xuICAgICAgRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkcmVuID0gcmVwbGFjZUNoaWxkcmVuO1xuICAgIH1cblxuICAgIGlmICghRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZVdpdGgpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gcmVwbGFjZVdpdGg7XG4gICAgICBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoO1xuICAgIH1cbiAgfVxufSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbi8qKlxuICogU2hhbGxvdyBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IHdpdGggdGhlIHRhcmdldCBvYmplY3QuIE9ubHlcbiAqIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBleGlzdCBvbiB0aGUgdGFyZ2V0IG9iamVjdC4gTm9uLXdyaXRhYmxlIHByb3BlcnRpZXNcbiAqIG9uIHRoZSB0YXJnZXQgb2JqZWN0IHdpbGwgbm90IGJlIG92ZXItd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0KHRhcmdldCkpLnJlZHVjZShmdW5jdGlvbiAoZXh0ZW5kZWQsIGtleSkge1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdCh0YXJnZXQpLCBrZXkpO1xuICAgIHZhciBuZXdWYWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iamVjdCksIGtleSk7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHRlbmRlZCwga2V5LCBuZXdWYWx1ZSB8fCBjdXJyZW50VmFsdWUpO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdXNlciBzdXBwbGllZCBzZXR0aW5ncyBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlU2V0dGluZ3MoKSB7XG4gIHZhciBzZXR0aW5ncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBvYmplY3QgPSBleHRlbmQoc2V0dGluZ3MpOyAvLyBgc3BsaXRgIG1heSBiZSB1c2VkIGFzIGFuIGFsaWFzIGZvciB0aGUgYHR5cGVzYCBvcHRpb25cbiAgLy8gUGFyc2UgdGhlIGB0eXBlc2Agc2V0dGluZ3MgaW50byBhbiBhcnJheSBvZiB2YWxpZCBzcGxpdCB0eXBlcy5cbiAgLy8gSWYgYHR5cGVzYCBpcyBleHBsaWNpdGx5IHNldCB0byBhbiBlbXB0eSBzdHJpbmcgb3IgYXJyYXksIHRleHQgd2lsbCBub3QgYmVcbiAgLy8gc3BsaXQgYXQgYWxsLlxuXG4gIHZhciB0eXBlcztcblxuICBpZiAob2JqZWN0LnR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0eXBlcyA9IG9iamVjdC50eXBlcztcbiAgfSBlbHNlIGlmIChvYmplY3Quc3BsaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHR5cGVzID0gb2JqZWN0LnNwbGl0O1xuICB9XG5cbiAgaWYgKHR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBvYmplY3QudHlwZXMgPSAoaXNTdHJpbmcodHlwZXMpIHx8IGlzQXJyYXkodHlwZXMpID8gU3RyaW5nKHR5cGVzKSA6ICcnKS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIFN0cmluZyh0eXBlKS50cmltKCk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gLygobGluZSl8KHdvcmQpfChjaGFyKSkvaS50ZXN0KHR5cGUpO1xuICAgIH0pO1xuICB9IC8vIFN1cHBvcnQgYHBvc2l0aW9uOiBhYnNvbHV0ZWAgYXMgYW4gYWxpYXMgZm9yIGBhYnNvbHV0ZTogdHJ1ZWBcblxuXG4gIGlmIChvYmplY3QuYWJzb2x1dGUgfHwgb2JqZWN0LnBvc2l0aW9uKSB7XG4gICAgb2JqZWN0LmFic29sdXRlID0gb2JqZWN0LmFic29sdXRlIHx8IC9hYnNvbHV0ZS8udGVzdChzZXR0aW5ncy5wb3NpdGlvbik7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBgdHlwZXNgIGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IHZhbHVlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2Ygc3BsaXQgdHlwZXNcbiAqIEByZXR1cm4ge3tsaW5lczogYm9vbGVhbiwgd29yZHM6IGJvb2xlYW4sIGNoYXJzOiBib29sZWFufX1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVR5cGVzKHZhbHVlKSB7XG4gIHZhciB0eXBlcyA9IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHtcbiAgICBub25lOiAhdHlwZXMsXG4gICAgbGluZXM6IC9saW5lL2kudGVzdCh0eXBlcyksXG4gICAgd29yZHM6IC93b3JkL2kudGVzdCh0eXBlcyksXG4gICAgY2hhcnM6IC9jaGFyL2kudGVzdCh0eXBlcylcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBpbnB1dGAgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIGBFbGVtZW50YFxuICogLSBgVGV4dGBcbiAqIC0gYERvY3VtZW50RnJhZ21lbnRgXG4gKi9cblxuZnVuY3Rpb24gaXNOb2RlKGlucHV0KSB7XG4gIHJldHVybiBpc09iamVjdChpbnB1dCkgJiYgL14oMXwzfDExKSQvLnRlc3QoaW5wdXQubm9kZVR5cGUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKiBPcmlnaW5hbCBzb3VyY2U6IExvZGFzaFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpXG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09PSAwO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZWAsIGVsc2UgYGZhbHNlYFxuICogQGV4YW1wbGVcbiAqIGlzQXJyYXlMaWtlKG5ldyBBcnJheSgpKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2RpdicpKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSlcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBpc0FycmF5TGlrZSgoKSA9PiB7fSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogaXNBcnJheUxpa2Uoe2ZvbzogJ2Jhcid9KVxuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAqIGlzQXJyYXlMaWtlKG51bGwpXG4gKiAvLyA9PiBmYWxzZVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvZXJjZXMgYHZhbHVlYCB0byBhbiBgQXJyYXlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7YW55W119XG4gKiBAZXhhbXBsZVxuICogLy8gSWYgYHZhbHVlYCBpcyBhbnkgYEFycmF5YCwgcmV0dXJucyBvcmlnaW5hbCBgQXJyYXlgXG4gKiBsZXQgYXJyID0gWzEsIDJdXG4gKiB0b0FycmF5KGFycilcbiAqIC8vID0+IGFyclxuICpcbiAqIC8vIElmIGB2YWx1ZWAgaXMgYW4gYEFycmF5TGlrZWAsIGl0cyBlcXVpdmFsZW50IHRvIGBBcnJheS5mcm9tKHZhbHVlKWBcbiAqIGxldCBub2RlTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2RpdicpXG4gKiB0b0FycmF5KG5vZGVMaXN0KVxuICogLy8gPT4gSFRNTEVsZW1lbnRbXSBzXG4gKlxuICogLy8gSWYgdmFsdWUgaXMgZmFsc3ksIHJldHVybnMgZW1wdHkgYXJyYXlcbiAqIHRvQXJyYXkobnVsbClcbiAqIC8vID0+IFtdXG4gKlxuICogLy8gRm9yIGFueSBvdGhlciB0eXBlIG9mIHZhbHVlLCBpdHMgZXF1aXZhbGVudCB0byBgQXJyYXkub2YodmFsdWUpYFxuICogbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICogdG9BcnJheShlbGVtZW50KVxuICogLy8gPT4gW2VsZW1lbnRdXG4gKlxuICovXG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJldHVybiBpc0FycmF5TGlrZSh2YWx1ZSkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWx1ZSkgOiBbdmFsdWVdO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyB0YXJnZXQgZWxlbWVudHMgZm9yIHRoZSBzcGxpdFR5cGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IHRhcmdldCBDYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAxLiBgc3RyaW5nYCAtIEEgY3NzIHNlbGVjdG9yXG4gKiAyLiBgSFRNTEVsZW1lbnRgIC0gQSBzaW5nbGUgZWxlbWVudFxuICogMy4gYE5vZGVMaXN0YCAtIEEgbm9kZUxpc3RcbiAqIDQuIGBFbGVtZW50W11gIC0gQW4gYXJyYXkgb2YgZWxlbWVudHNcbiAqIDUuIGBBcnJheTxOb2RlTGlzdHxFbGVtZW50W10+YCAtIEFuIG5lc3RlZCBhcnJheSBvZiBlbGVtZW50c1xuICogQHJldHVybnMge0VsZW1lbnRbXX0gQSBmbGF0IGFycmF5IEhUTUwgZWxlbWVudHNcbiAqIEByZXR1cm4gQSBmbGF0IGFycmF5IG9mIGVsZW1lbnRzIG9yIGVtcHR5IGFycmF5IGlmIG5vIGVsZW1lbnRzIGFyZSBmb3VuZFxuICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldEVsZW1lbnRzKHRhcmdldCkge1xuICB2YXIgZWxlbWVudHMgPSB0YXJnZXQ7IC8vIElmIGB0YXJnZXRgIGlzIGEgc2VsZWN0b3Igc3RyaW5nLi4uXG5cbiAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcbiAgICBpZiAoL14oI1thLXpdXFx3KykkLy50ZXN0KHRhcmdldC50cmltKCkpKSB7XG4gICAgICAvLyBJZiBgdGFyZ2V0YCBpcyBhbiBJRCwgdXNlIGBnZXRFbGVtZW50QnlJZGBcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0LnRyaW0oKS5zbGljZSgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVsc2UgdXNlIGBxdWVyeVNlbGVjdG9yQWxsYFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCk7XG4gICAgfVxuICB9IC8vIFJldHVybiBhIGZsYXR0ZW5lZCBhcnJheSBvZiBlbGVtZW50c1xuXG5cbiAgcmV0dXJuIHRvQXJyYXkoZWxlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0KSwgX3RvQ29uc3VtYWJsZUFycmF5KHRvQXJyYXkoZWxlbWVudCkuZmlsdGVyKGlzTm9kZSkpKTtcbiAgfSwgW10pO1xufVxuXG52YXIgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzO1xuXG52YXIgZXhwYW5kbyA9IFwiX3NwbGl0dHlwZVwiO1xudmFyIGNhY2hlID0ge307XG52YXIgdWlkID0gMDtcbi8qKlxuICogU3RvcmVzIGRhdGEgYXNzb2NpYXRlZCB3aXRoIERPTSBlbGVtZW50cyBvciBvdGhlciBvYmplY3RzLiBUaGlzIGlzIGFcbiAqIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBqUXVlcnkncyBkYXRhIG1ldGhvZC5cbiAqXG4gKiBAc2lnbmF0dXJlIERhdGEob3duZXIpXG4gKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBkYXRhIHN0b3JlIG9iamVjdCBmb3IgdGhlIGdpdmVuIG93bmVyLlxuICogQHBhcmFtIHtPYmplY3R9IG93bmVyIHRoZSBvYmplY3QgdGhhdCBkYXRhIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZGF0YSBvYmplY3QgZm9yIGdpdmVuIGBvd25lcmAuIElmIG5vIGRhdGEgZXhpc3RzXG4gKiAgICAgZm9yIHRoZSBnaXZlbiBvYmplY3QsIGNyZWF0ZXMgYSBuZXcgZGF0YSBzdG9yZSBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAc2lnbmF0dXJlIERhdGEob3duZXIsIGtleSlcbiAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3duZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2FueX0gdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBrZXkuIElmIGtleSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuc1xuICogICAgIHVuZGVmaW5lZC5cbiAqXG4gKiBAc2lnbmF0dXJlIERhdGEob3duZXIsIGtleSwgdmFsdWUpXG4gKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIgaW4gZGF0YSBzdG9yZVxuICogQHBhcmFtIHtPYmplY3R9IG93bmVyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBzZXQob3duZXIsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdChvd25lcikpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tkYXRhLnNldF0gb3duZXIgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlkID0gb3duZXJbZXhwYW5kb10gfHwgKG93bmVyW2V4cGFuZG9dID0gKyt1aWQpO1xuICB2YXIgZGF0YSA9IGNhY2hlW2lkXSB8fCAoY2FjaGVbaWRdID0ge30pO1xuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCEha2V5ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihrZXkpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICBjYWNoZVtpZF0gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0YSksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXQob3duZXIsIGtleSkge1xuICB2YXIgaWQgPSBpc09iamVjdChvd25lcikgPyBvd25lcltleHBhbmRvXSA6IG51bGw7XG4gIHZhciBkYXRhID0gaWQgJiYgY2FjaGVbaWRdIHx8IHt9O1xuXG4gIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIGRhdGFba2V5XTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gIHZhciBpZCA9IGVsZW1lbnQgJiYgZWxlbWVudFtleHBhbmRvXTtcblxuICBpZiAoaWQpIHtcbiAgICBkZWxldGUgZWxlbWVudFtpZF07XG4gICAgZGVsZXRlIGNhY2hlW2lkXTtcbiAgfVxufVxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIGRhdGFcbiAqL1xuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgT2JqZWN0LmtleXMoY2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICB9KTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCB0ZW1wb3JhcnkgZGF0YSBmcm9tIHRoZSBzdG9yZS5cbiAqL1xuXG5mdW5jdGlvbiBjbGVhbnVwKCkge1xuICBlbnRyaWVzKGNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIGlkID0gX3JlZjJbMF0sXG4gICAgICAgIF9yZWYyJCA9IF9yZWYyWzFdLFxuICAgICAgICBpc1Jvb3QgPSBfcmVmMiQuaXNSb290LFxuICAgICAgICBpc1NwbGl0ID0gX3JlZjIkLmlzU3BsaXQ7XG5cbiAgICBpZiAoIWlzUm9vdCB8fCAhaXNTcGxpdCkge1xuICAgICAgY2FjaGVbaWRdID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBjYWNoZVtpZF07XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gW3NlcGFyYXRvciA9ICcgJ11cbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBBcnJheSBvZiB3b3Jkc1xuICovXG5mdW5jdGlvbiB0b1dvcmRzKHZhbHVlKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcgJztcbiAgdmFyIHN0cmluZyA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykuc3BsaXQoc2VwYXJhdG9yKTtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiBsb2Rhc2gjc3BsaXQgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmXG4gKiBFZGl0b3JzXG4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gXCJcXFxcdWQ4MDAtXFxcXHVkZmZmXCI7XG52YXIgcnNDb21ib01hcmtzUmFuZ2UgPSBcIlxcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdWZlMjAtXFxcXHVmZTIzXCI7XG52YXIgcnNDb21ib1N5bWJvbHNSYW5nZSA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmMFwiO1xudmFyIHJzVmFyUmFuZ2UgPSBcIlxcXFx1ZmUwZVxcXFx1ZmUwZlwiO1xuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuXG52YXIgcnNBc3RyYWwgPSBcIltcIi5jb25jYXQocnNBc3RyYWxSYW5nZSwgXCJdXCIpO1xudmFyIHJzQ29tYm8gPSBcIltcIi5jb25jYXQocnNDb21ib01hcmtzUmFuZ2UpLmNvbmNhdChyc0NvbWJvU3ltYm9sc1JhbmdlLCBcIl1cIik7XG52YXIgcnNGaXR6ID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIjtcbnZhciByc01vZGlmaWVyID0gXCIoPzpcIi5jb25jYXQocnNDb21ibywgXCJ8XCIpLmNvbmNhdChyc0ZpdHosIFwiKVwiKTtcbnZhciByc05vbkFzdHJhbCA9IFwiW15cIi5jb25jYXQocnNBc3RyYWxSYW5nZSwgXCJdXCIpO1xudmFyIHJzUmVnaW9uYWwgPSBcIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIjtcbnZhciByc1N1cnJQYWlyID0gXCJbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl1cIjtcbnZhciByc1pXSiA9IFwiXFxcXHUyMDBkXCI7XG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cblxudmFyIHJlT3B0TW9kID0gXCJcIi5jb25jYXQocnNNb2RpZmllciwgXCI/XCIpO1xudmFyIHJzT3B0VmFyID0gXCJbXCIuY29uY2F0KHJzVmFyUmFuZ2UsIFwiXT9cIik7XG52YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJztcbnZhciByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW47XG52YXIgcnNTeW1ib2wgPSBcIig/OlwiLmNvbmNhdChbXCJcIi5jb25jYXQocnNOb25Bc3RyYWwpLmNvbmNhdChyc0NvbWJvLCBcIj9cIiksIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JyksIFwiXFxuKVwiKTtcbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG5cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAoXCJcIi5jb25jYXQocnNGaXR6LCBcIig/PVwiKS5jb25jYXQocnNGaXR6LCBcIil8XCIpLmNvbmNhdChyc1N5bWJvbCkuY29uY2F0KHJzU2VxKSwgJ2cnKTtcbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuXG52YXIgdW5pY29kZVJhbmdlID0gW3JzWldKLCByc0FzdHJhbFJhbmdlLCByc0NvbWJvTWFya3NSYW5nZSwgcnNDb21ib1N5bWJvbHNSYW5nZSwgcnNWYXJSYW5nZV07XG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKFwiW1wiLmNvbmNhdCh1bmljb2RlUmFuZ2Uuam9pbignJyksIFwiXVwiKSk7XG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cblxuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IFN0cmluZyh2YWx1ZSk7XG59XG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGNoYXJhY3RlcnMuIElmIGBzZXBhcmF0b3JgIGlzIG9taXR0ZWQsXG4gKiBpdCBiZWhhdmVzIGxpa2VzIHNwbGl0LnNwbGl0KCcnKS5cbiAqXG4gKiBVbmxpa2UgbmF0aXZlIHN0cmluZy5zcGxpdCgnJyksIGl0IGNhbiBzcGxpdCBzdHJpbmdzIHRoYXQgY29udGFpbiB1bmljb2RlXG4gKiBjaGFyYWN0ZXJzIGxpa2UgZW1vamlzIGFuZCBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbc2VwYXJhdG9yPScnXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAqIEBleGFtcGxlXG4gKiB0b0NoYXJzKCdmb28nKTtcbiAqIC8vID0+IFsnZicsICdvJywgJ28nXVxuICpcbiAqIHRvQ2hhcnMoJ2ZvbyBiYXInKTtcbiAqIC8vID0+IFtcImZcIiwgXCJvXCIsIFwib1wiLCBcIiBcIiwgXCJiXCIsIFwiYVwiLCBcInJcIl1cbiAqXG4gKiB0b0NoYXJzKCdm8J+YgG8nKTtcbiAqIC8vID0+IFsnZicsICfwn5iAJywgJ28nXVxuICpcbiAqIHRvQ2hhcnMoJ2Yt8J+YgC1vJywgLy0vKTtcbiAqIC8vID0+IFsnZicsICfwn5iAJywgJ28nXVxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ2hhcnMoc3RyaW5nKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gIGlmIChzdHJpbmcgJiYgaXNTdHJpbmcoc3RyaW5nKSkge1xuICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZWxlbWVudCB3aXRoIHRoZSB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICpcbiAqIGF0dHJpYnV0ZXMgY2FuIGluY2x1ZGUgc3RhbmRhcmQgSFRNTCBhdHRyaWJ1dGUsIGFzIHdlbGwgYXMgdGhlIGZvbGxvd2luZ1xuICogXCJzcGVjaWFsXCIgcHJvcGVydGllczpcbiAqICAgLSBjaGlsZHJlbjogSFRNTEVsZW1lbnQgfCBBcnJheUxpa2U8SFRNTEVsZW1lbnQ+XG4gKiAgIC0gdGV4dENvbnRlbnQ6IHN0cmluZ1xuICogICAtIGlubmVySFRNTDogc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcblxuICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAvLyBXaGVuIGNhbGxlZCB3aXRob3V0IHRoZSBzZWNvbmQgYXJndW1lbnQsIGl0cyBqdXN0IHJldHVybiB0aGUgcmVzdWx0XG4gICAgLy8gb2YgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnRgXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICB2YXIgcmF3VmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgdmFyIHZhbHVlID0gaXNTdHJpbmcocmF3VmFsdWUpID8gcmF3VmFsdWUudHJpbSgpIDogcmF3VmFsdWU7IC8vIElnbm9yZSBhdHRyaWJ1dGUgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBhbiBlbXB0eSBzdHJpbmdcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuICAgIGlmIChhdHRyaWJ1dGUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgIC8vIENoaWxkcmVuIGNhbiBiZSBvbmUgb3IgbW9yZSBFbGVtZW50cyBvciBET00gc3RyaW5nc1xuICAgICAgZWxlbWVudC5hcHBlbmQuYXBwbHkoZWxlbWVudCwgX3RvQ29uc3VtYWJsZUFycmF5KHRvQXJyYXkodmFsdWUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSBzdGFuZGFyZCBIVE1MIGF0dHJpYnV0ZXNcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIHNwbGl0Q2xhc3M6ICcnLFxuICBsaW5lQ2xhc3M6ICdsaW5lJyxcbiAgd29yZENsYXNzOiAnd29yZCcsXG4gIGNoYXJDbGFzczogJ2NoYXInLFxuICB0eXBlczogWydsaW5lcycsICd3b3JkcycsICdjaGFycyddLFxuICBhYnNvbHV0ZTogZmFsc2UsXG4gIHRhZ05hbWU6ICdkaXYnXG59O1xuXG4vKipcbiAqIFNwbGl0cyB0aGUgdGV4dCBjb250ZW50IG9mIGEgc2luZ2xlIFRleHROb2RlIGludG8gd29yZHMgYW5kL29yIGNoYXJhY3RlcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbnMgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHRleHQgbm9kZSBpbnNpZGUgdGhlIHRhcmdldCBlbGVtZW50LiBJdFxuICogcmVwbGFjZXMgdGhlIHRleHQgbm9kZSB3aXRoIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgc3BsaXQgdGV4dC5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNwbGl0IHdvcmQgYW5kIGNoYXJhY3RlciBlbGVtZW50cyBmcm9tIHRoaXMgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSB0ZXh0Tm9kZVxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gKiBAcmV0dXJuIHt7d29yZHM6IEVsZW1lbnRbXSwgY2hhcnM6IEVsZW1lbnRbXX19XG4gKi9cblxuZnVuY3Rpb24gc3BsaXRXb3Jkc0FuZENoYXJzKHRleHROb2RlLCBzZXR0aW5ncykge1xuICBzZXR0aW5ncyA9IGV4dGVuZChkZWZhdWx0cywgc2V0dGluZ3MpOyAvLyBUaGUgc3BsaXQgdHlwZXNcblxuICB2YXIgdHlwZXMgPSBwYXJzZVR5cGVzKHNldHRpbmdzLnR5cGVzKTsgLy8gdGhlIHRhZyBuYW1lIGZvciBzcGxpdCB0ZXh0IG5vZGVzXG5cbiAgdmFyIFRBR19OQU1FID0gc2V0dGluZ3MudGFnTmFtZTsgLy8gdmFsdWUgb2YgdGhlIHRleHQgbm9kZVxuXG4gIHZhciBWQUxVRSA9IHRleHROb2RlLm5vZGVWYWx1ZTsgLy8gYHNwbGl0VGV4dGAgaXMgYSB3cmFwcGVyIHRvIGhvbGQgdGhlIEhUTUwgc3RydWN0dXJlXG5cbiAgdmFyIHNwbGl0VGV4dCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsgLy8gQXJyYXlzIG9mIHNwbGl0IHdvcmQgYW5kIGNoYXJhY3RlciBlbGVtZW50c1xuXG4gIHZhciB3b3JkcyA9IFtdO1xuICB2YXIgY2hhcnMgPSBbXTtcblxuICBpZiAoL15cXHMvLnRlc3QoVkFMVUUpKSB7XG4gICAgc3BsaXRUZXh0LmFwcGVuZCgnICcpO1xuICB9IC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVkIHdvcmQgZWxlbWVudHMuXG5cblxuICB3b3JkcyA9IHRvV29yZHMoVkFMVUUpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBXT1JELCBpZHgsIGFycikge1xuICAgIC8vIExldCBgd29yZEVsZW1lbnRgIGJlIHRoZSB3cmFwcGVkIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IHdvcmRcbiAgICB2YXIgd29yZEVsZW1lbnQ7XG4gICAgdmFyIGNoYXJhY3RlckVsZW1lbnRzRm9yQ3VycmVudFdvcmQ7IC8vIC0+IElmIHNwbGl0dGluZyB0ZXh0IGludG8gY2hhcmFjdGVycy4uLlxuXG4gICAgaWYgKHR5cGVzLmNoYXJzKSB7XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgICAgY2hhcmFjdGVyRWxlbWVudHNGb3JDdXJyZW50V29yZCA9IHRvQ2hhcnMoV09SRCkubWFwKGZ1bmN0aW9uIChDSEFSKSB7XG4gICAgICAgIHZhciBjaGFyYWN0ZXJFbGVtZW50ID0gY3JlYXRlRWxlbWVudChUQUdfTkFNRSwge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJcIi5jb25jYXQoc2V0dGluZ3Muc3BsaXRDbGFzcywgXCIgXCIpLmNvbmNhdChzZXR0aW5ncy5jaGFyQ2xhc3MpLFxuICAgICAgICAgIHN0eWxlOiAnZGlzcGxheTogaW5saW5lLWJsb2NrOycsXG4gICAgICAgICAgY2hpbGRyZW46IENIQVJcbiAgICAgICAgfSk7XG4gICAgICAgIHNldChjaGFyYWN0ZXJFbGVtZW50LCAnaXNDaGFyJywgdHJ1ZSk7XG4gICAgICAgIGNoYXJzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjaGFycyksIFtjaGFyYWN0ZXJFbGVtZW50XSk7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJFbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSAvLyBFTkQgSUY7XG5cblxuICAgIGlmICh0eXBlcy53b3JkcyB8fCB0eXBlcy5saW5lcykge1xuICAgICAgLy8gLT4gSWYgU3BsaXR0aW5nIFRleHQgSW50byBXb3Jkcy4uLlxuICAgICAgLy8gICAgQ3JlYXRlIGFuIGVsZW1lbnQgdG8gd3JhcCB0aGUgY3VycmVudCB3b3JkLiBJZiB3ZSBhcmUgYWxzb1xuICAgICAgLy8gICAgc3BsaXR0aW5nIHRleHQgaW50byBjaGFyYWN0ZXJzLCB0aGUgd29yZCBlbGVtZW50IHdpbGwgY29udGFpbiB0aGVcbiAgICAgIC8vICAgIHdyYXBwZWQgY2hhcmFjdGVyIG5vZGVzIGZvciB0aGlzIHdvcmQuIElmIG5vdCwgaXQgd2lsbCBjb250YWluIHRoZVxuICAgICAgLy8gICAgcGxhaW4gdGV4dCBjb250ZW50IChXT1JEKVxuICAgICAgd29yZEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFRBR19OQU1FLCB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJcIi5jb25jYXQoc2V0dGluZ3Mud29yZENsYXNzLCBcIiBcIikuY29uY2F0KHNldHRpbmdzLnNwbGl0Q2xhc3MpLFxuICAgICAgICBzdHlsZTogXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IFwiLmNvbmNhdCh0eXBlcy53b3JkcyAmJiBzZXR0aW5ncy5hYnNvbHV0ZSA/IFwicG9zaXRpb246IHJlbGF0aXZlO1wiIDogJycpLFxuICAgICAgICBjaGlsZHJlbjogdHlwZXMuY2hhcnMgPyBjaGFyYWN0ZXJFbGVtZW50c0ZvckN1cnJlbnRXb3JkIDogV09SRFxuICAgICAgfSk7XG4gICAgICBzZXQod29yZEVsZW1lbnQsIHtcbiAgICAgICAgaXNXb3JkOiB0cnVlLFxuICAgICAgICBpc1dvcmRTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNXb3JkRW5kOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHNwbGl0VGV4dC5hcHBlbmRDaGlsZCh3b3JkRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIC0+IElmIE5PVCBzcGxpdHRpbmcgaW50byB3b3JkcyBPUiBsaW5lcy4uLlxuICAgICAgLy8gICAgQXBwZW5kIHRoZSBjaGFyYWN0ZXJzIGVsZW1lbnRzIGRpcmVjdGx5IHRvIHNwbGl0VGV4dC5cbiAgICAgIGNoYXJhY3RlckVsZW1lbnRzRm9yQ3VycmVudFdvcmQuZm9yRWFjaChmdW5jdGlvbiAoY2hhcmFjdGVyRWxlbWVudCkge1xuICAgICAgICBzcGxpdFRleHQuYXBwZW5kQ2hpbGQoY2hhcmFjdGVyRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaWR4IDwgYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIEFkZCBhIHNwYWNlIGFmdGVyIHRoZSB3b3JkLlxuICAgICAgc3BsaXRUZXh0LmFwcGVuZCgnICcpO1xuICAgIH0gLy8gSWYgbm90IHNwbGl0dGluZyB0ZXh0IGludG8gd29yZHMsIHdlIHJldHVybiBhbiBlbXB0eSBhcnJheVxuXG5cbiAgICByZXR1cm4gdHlwZXMud29yZHMgPyByZXN1bHQuY29uY2F0KHdvcmRFbGVtZW50KSA6IHJlc3VsdDtcbiAgfSwgW10pOyAvLyBFTkQgTE9PUDtcbiAgLy8gQWRkIGEgdHJhaWxpbmcgd2hpdGUgc3BhY2UgdG8gbWFpbnRhaW4gd29yZCBzcGFjaW5nXG5cbiAgaWYgKC9cXHMkLy50ZXN0KFZBTFVFKSkge1xuICAgIHNwbGl0VGV4dC5hcHBlbmQoJyAnKTtcbiAgfVxuXG4gIHRleHROb2RlLnJlcGxhY2VXaXRoKHNwbGl0VGV4dCk7XG4gIHJldHVybiB7XG4gICAgd29yZHM6IHdvcmRzLFxuICAgIGNoYXJzOiBjaGFyc1xuICB9O1xufVxuXG4vKipcbiAqIFNwbGl0cyB0aGUgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IGVsZW1lbnQgaW50byB3b3JkcyBhbmQvb3IgY2hhcmFjdGVycy5cbiAqIFRoZSBmdW5jdGlvbiBpcyByZWN1cnNpdmUsIGl0IHdpbGwgYWxzbyBzcGxpdCB0aGUgdGV4dCBjb250ZW50IG9mIGFueSBjaGlsZFxuICogZWxlbWVudHMgaW50byB3b3Jkcy9jaGFyYWN0ZXJzLCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXN0ZWQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIGFuIEhUTUwgRWxlbWVudCBvciBUZXh0IE5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nIHNwbGl0VHlwZSBzZXR0aW5nc1xuICovXG5cbmZ1bmN0aW9uIHNwbGl0KG5vZGUsIHNldHRpbmdzKSB7XG4gIHZhciB0eXBlID0gbm9kZS5ub2RlVHlwZTsgLy8gQXJyYXlzIG9mIHNwbGl0IHdvcmRzIGFuZCBjaGFyYWN0ZXJzXG5cbiAgdmFyIHdvcmRzQW5kQ2hhcnMgPSB7XG4gICAgd29yZHM6IFtdLFxuICAgIGNoYXJzOiBbXVxuICB9OyAvLyBPbmx5IHByb2NlZWQgaWYgYG5vZGVgIGlzIGFuIGBFbGVtZW50YCwgYEZyYWdtZW50YCwgb3IgYFRleHRgXG5cbiAgaWYgKCEvKDF8M3wxMSkvLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gd29yZHNBbmRDaGFycztcbiAgfSAvLyBBKSBJRiBgbm9kZWAgaXMgVGV4dE5vZGUgdGhhdCBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gd2hpdGUgc3BhY2UuLi5cbiAgLy8gICAgU3BsaXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZSBpbnRvIHdvcmRzIGFuZC9vciBjaGFyYWN0ZXJzXG4gIC8vICAgIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3BsaXQgd29yZCBhbmQgY2hhcmFjdGVyIGVsZW1lbnRzXG5cblxuICBpZiAodHlwZSA9PT0gMyAmJiAvXFxTLy50ZXN0KG5vZGUubm9kZVZhbHVlKSkge1xuICAgIHJldHVybiBzcGxpdFdvcmRzQW5kQ2hhcnMobm9kZSwgc2V0dGluZ3MpO1xuICB9IC8vIEIpIEVMU0UgYG5vZGVgIGlzIGFuICdFbGVtZW50J1xuICAvLyAgICBJdGVyYXRlIHRocm91Z2ggaXRzIGNoaWxkIG5vZGVzLCBjYWxsaW5nIHRoZSBgc3BsaXRgIGZ1bmN0aW9uXG4gIC8vICAgIHJlY3Vyc2l2ZWx5IGZvciBlYWNoIGNoaWxkIG5vZGUuXG5cblxuICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKTtcblxuICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICBzZXQobm9kZSwgJ2lzU3BsaXQnLCB0cnVlKTsgLy8gd2UgbmVlZCB0byBzZXQgYSBmZXcgc3R5bGVzIG9uIG5lc3RlZCBodG1sIGVsZW1lbnRzXG5cbiAgICBpZiAoIWdldChub2RlKS5pc1Jvb3QpIHtcbiAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7IC8vIFRvIG1haW50YWluIG9yaWdpbmFsIHNwYWNpbmcgYXJvdW5kIG5lc3RlZCBlbGVtZW50cyB3aGVuIHdlIGFyZVxuICAgICAgLy8gc3BsaXR0aW5nIHRleHQgaW50byBsaW5lcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBzcGFjZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgc3RvcmUgdGhhdCB2YWx1ZSBmb3IgbGF0ZXIuXG4gICAgICAvLyBOb3RlOiB0aGlzIHdhcyBuZWNlc3NhcnkgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3Qgc3BhY2luZyB3aGVuIG5lc3RlZFxuICAgICAgLy8gZWxlbWVudHMgZG8gbm90IGFsaWduIHdpdGggd29yZCBib3VuZGFyaWVzLiBGb3IgZXhhbXBsZSwgYSBuZXN0ZWRcbiAgICAgIC8vIGVsZW1lbnQgb25seSB3cmFwcyBwYXJ0IG9mIGEgd29yZC5cblxuICAgICAgdmFyIG5leHRTaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIHZhciBwcmV2U2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgdmFyIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgdmFyIHRleHRBZnRlciA9IG5leHRTaWJsaW5nID8gbmV4dFNpYmxpbmcudGV4dENvbnRlbnQgOiAnICc7XG4gICAgICB2YXIgdGV4dEJlZm9yZSA9IHByZXZTaWJsaW5nID8gcHJldlNpYmxpbmcudGV4dENvbnRlbnQgOiAnICc7XG4gICAgICBzZXQobm9kZSwge1xuICAgICAgICBpc1dvcmRFbmQ6IC9cXHMkLy50ZXN0KHRleHQpIHx8IC9eXFxzLy50ZXN0KHRleHRBZnRlciksXG4gICAgICAgIGlzV29yZFN0YXJ0OiAvXlxccy8udGVzdCh0ZXh0KSB8fCAvXFxzJC8udGVzdCh0ZXh0QmVmb3JlKVxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZCBub2RlcywgY2FsbGluZyBgc3BsaXRgIHJlY3Vyc2l2ZWx5XG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHNwbGl0IHdvcmRzIGFuZCBjaGFyc1xuXG5cbiAgcmV0dXJuIGNoaWxkTm9kZXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgdmFyIF9zcGxpdCA9IHNwbGl0KGNoaWxkLCBzZXR0aW5ncyksXG4gICAgICAgIHdvcmRzID0gX3NwbGl0LndvcmRzLFxuICAgICAgICBjaGFycyA9IF9zcGxpdC5jaGFycztcblxuICAgIHJldHVybiB7XG4gICAgICB3b3JkczogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQud29yZHMpLCBfdG9Db25zdW1hYmxlQXJyYXkod29yZHMpKSxcbiAgICAgIGNoYXJzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdC5jaGFycyksIF90b0NvbnN1bWFibGVBcnJheShjaGFycykpXG4gICAgfTtcbiAgfSwgd29yZHNBbmRDaGFycyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGVpZ2h0IGFuZCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIG9mZnNldCBwYXJlbnQuXG4gKiBTaG91bGQgYmUgZXF1aXZhbGVudCB0byBvZmZzZXRUb3AgYW5kIG9mZnNldEhlaWdodCwgYnV0IHdpdGggc3ViLXBpeGVsXG4gKiBwcmVjaXNpb24uXG4gKlxuICogVE9ETyBuZWVkcyB3b3JrXG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUsIGlzV29yZCwgc2V0dGluZ3MsIHNjcm9sbFBvcykge1xuICBpZiAoIXNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogaXNXb3JkID8gbm9kZS5vZmZzZXRUb3AgOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBub2RlLm9mZnNldFBhcmVudDtcblxuICB2YXIgX3Njcm9sbFBvcyA9IF9zbGljZWRUb0FycmF5KHNjcm9sbFBvcywgMiksXG4gICAgICBzY3JvbGxYID0gX3Njcm9sbFBvc1swXSxcbiAgICAgIHNjcm9sbFkgPSBfc2Nyb2xsUG9zWzFdO1xuXG4gIHZhciBwYXJlbnRYID0gMDtcbiAgdmFyIHBhcmVudFkgPSAwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgdmFyIHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcGFyZW50WCA9IHBhcmVudFJlY3QueCArIHNjcm9sbFg7XG4gICAgcGFyZW50WSA9IHBhcmVudFJlY3QueSArIHNjcm9sbFk7XG4gIH1cblxuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodCxcbiAgICAgIHggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUueCxcbiAgICAgIHkgPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUueTtcblxuICB2YXIgdG9wID0geSArIHNjcm9sbFkgLSBwYXJlbnRZO1xuICB2YXIgbGVmdCA9IHggKyBzY3JvbGxYIC0gcGFyZW50WDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdFxuICB9O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IFwidW4tc3BsaXRzXCIgdGV4dCBpbnRvIHdvcmRzLlxuICogVGhpcyBpcyB1c2VkIHdoZW4gc3BsaXR0aW5nIHRleHQgaW50byBsaW5lcyBidXQgbm90IHdvcmRzLlxuICogV2UgaW5pdGlhbGx5IHNwbGl0IHRoZSB0ZXh0IGludG8gd29yZHMgc28gd2UgY2FuIG1haW50YWluIHRoZSBjb3JyZWN0IGxpbmVcbiAqIGJyZWFrcy4gT25jZSB0ZXh0IGhhcyBiZWVuIHNwbGl0IGludG8gbGluZXMsIHdlIFwidW4tc3BsaXRcIiB0aGUgd29yZHMuLi5cbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cblxuZnVuY3Rpb24gdW5TcGxpdFdvcmRzKGVsZW1lbnQpIHtcbiAgaWYgKCFnZXQoZWxlbWVudCkuaXNXb3JkKSB7XG4gICAgdG9BcnJheShlbGVtZW50LmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIHVuU3BsaXRXb3JkcyhjaGlsZCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucmVwbGFjZVdpdGguYXBwbHkoZWxlbWVudCwgX3RvQ29uc3VtYWJsZUFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykpO1xuICB9XG59XG5cbnZhciBjcmVhdGVGcmFnbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufTtcblxuZnVuY3Rpb24gcmVwb3NpdGlvbkFmdGVyU3BsaXQoZWxlbWVudCwgc2V0dGluZ3MsIHNjcm9sbFBvcykge1xuICB2YXIgdHlwZXMgPSBwYXJzZVR5cGVzKHNldHRpbmdzLnR5cGVzKTtcbiAgdmFyIFRBR19OQU1FID0gc2V0dGluZ3MudGFnTmFtZTtcbiAgdmFyIG5vZGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICB2YXIgd29yZHNJbkVhY2hMaW5lID0gW107XG4gIHZhciB3b3Jkc0luQ3VycmVudExpbmUgPSBbXTtcbiAgdmFyIGxpbmVPZmZzZXRZID0gbnVsbDtcbiAgdmFyIGVsZW1lbnRIZWlnaHQ7XG4gIHZhciBlbGVtZW50V2lkdGg7XG4gIHZhciBjb250ZW50Qm94O1xuICB2YXIgbGluZXMgPSBbXTtcbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqKiBHRVQgU1RZTEVTIEFORCBQT1NJVElPTlNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvLyBUaGVyZSBpcyBubyBidWlsdC1pbiB3YXkgdG8gZGV0ZWN0IG5hdHVyYWwgbGluZSBicmVha3MgaW4gdGV4dCAod2hlbiBhXG4gIC8vIGJsb2NrIG9mIHRleHQgd3JhcHMgdG8gZml0IGl0cyBjb250YWluZXIpLiBUbyBzcGxpdCB0ZXh0IGludG8gbGluZXMsIHdlXG4gIC8vIGhhdmUgdG8gZGV0ZWN0IGxpbmUgYnJlYWtzIGJ5IGNoZWNraW5nIHRoZSB0b3Agb2Zmc2V0IG9mIHdvcmRzLiBUaGlzIGlzXG4gIC8vIHdoeSB0ZXh0IHdhcyBzcGxpdCBpbnRvIHdvcmRzIGZpcnN0LiBUbyBhcHBseSBhYnNvbHV0ZVxuICAvLyBwb3NpdGlvbmluZywgaXRzIGFsc28gbmVjZXNzYXJ5IHRvIHJlY29yZCB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgZXZlcnlcbiAgLy8gc3BsaXQgbm9kZSAobGluZXMsIHdvcmRzLCBjaGFyYWN0ZXJzKS5cbiAgLy8gVG8gY29uc29saWRhdGUgRE9NIGdldHRpbmcvc2V0dGluZ3MsIHRoaXMgaXMgYWxsIGRvbmUgYXQgdGhlIHNhbWUgdGltZSxcbiAgLy8gYmVmb3JlIGFjdHVhbGx5IHNwbGl0dGluZyB0ZXh0IGludG8gbGluZXMsIHdoaWNoIGludm9sdmVzIHJlc3RydWN0dXJpbmdcbiAgLy8gdGhlIERPTSBhZ2Fpbi5cbiAgLy8gQ2FjaGUgdGhlIGVsZW1lbnQncyBwYXJlbnQgYW5kIG5leHQgc2libGluZyAoZm9yIERPTSByZW1vdmFsKS5cblxuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB2YXIgbmV4dFNpYmxpbmcgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZzsgLy8gYSB3cmFwcGVyIGZvciB0aGUgbmV3IEhUTUwgc3RydWN0dXJlXG5cbiAgdmFyIHNwbGl0VGV4dCA9IGNyZWF0ZUZyYWdtZW50KCk7IC8vIGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgZWxlbWVudFxuXG4gIHZhciBjcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgYWxpZ24gPSBjcy50ZXh0QWxpZ247XG4gIHZhciBmb250U2l6ZSA9IHBhcnNlRmxvYXQoY3MuZm9udFNpemUpO1xuICB2YXIgbGluZVRocmVzaG9sZCA9IGZvbnRTaXplICogMC4yOyAvLyBJRiB1c2luZyBhYnNvbHV0ZSBwb3NpdGlvbi4uLlxuXG4gIGlmIChzZXR0aW5ncy5hYnNvbHV0ZSkge1xuICAgIC8vIExldCBjb250ZW50Qm94IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB3aWR0aCBhbmQgb2Zmc2V0IHBvc2l0aW9uIG9mXG4gICAgLy8gdGhlIGVsZW1lbnQncyBjb250ZW50IGJveCAodGhlIGFyZWEgaW5zaWRlIHBhZGRpbmcgYm94KS4gVGhpcyBpcyBuZWVkZWRcbiAgICAvLyAoZm9yIGFic29sdXRlIHBvc2l0aW9uaW5nKSB0byBzZXQgdGhlIHdpZHRoIGFuZCBwb3NpdGlvbiBvZiBsaW5lXG4gICAgLy8gZWxlbWVudHMsIHdoaWNoIGhhdmUgbm90IGJlZW4gY3JlYXRlZCB5ZXQuXG4gICAgY29udGVudEJveCA9IHtcbiAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICAgIHRvcDogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aFxuICAgIH07IC8vIExldCBlbGVtZW50V2lkdGggYW5kIGVsZW1lbnRIZWlnaHQgYmUgdGhlIGFjdHVhbCB3aWR0aC9oZWlnaHQgb2YgdGhlXG4gICAgLy8gZWxlbWVudC4gQWxzbyBjaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgaW5saW5lIGhlaWdodCBvciB3aWR0aCBzdHlsZXNcbiAgICAvLyBhbHJlYWR5IHNldC4gSWYgaXQgZG9lcywgY2FjaGUgdGhvc2UgdmFsdWVzIGZvciBsYXRlci5cblxuICAgIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0OyAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgaW5saW5lIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIGVsZW1lbnRcblxuICAgIHNldChlbGVtZW50LCB7XG4gICAgICBjc3NXaWR0aDogZWxlbWVudC5zdHlsZS53aWR0aCxcbiAgICAgIGNzc0hlaWdodDogZWxlbWVudC5zdHlsZS5oZWlnaHRcbiAgICB9KTtcbiAgfSAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgbm9kZSBpbiB0aGUgdGFyZ2V0IGVsZW1lbnRcblxuXG4gIHRvQXJyYXkobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBub2RlIGlzIGEgd29yZCBlbGVtZW50IG9yIGN1c3RvbSBodG1sIGVsZW1lbnRcbiAgICB2YXIgaXNXb3JkTGlrZSA9IG5vZGUucGFyZW50RWxlbWVudCA9PT0gZWxlbWVudDsgLy8gVE9ETyBuZWVkcyB3b3JrXG4gICAgLy8gR2V0IHRlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHNwbGl0IHRleHQgbm9kZXNcblxuICAgIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlLCBpc1dvcmRMaWtlLCBzZXR0aW5ncywgc2Nyb2xsUG9zKSxcbiAgICAgICAgd2lkdGggPSBfZ2V0UG9zaXRpb24ud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9nZXRQb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgIHRvcCA9IF9nZXRQb3NpdGlvbi50b3AsXG4gICAgICAgIGxlZnQgPSBfZ2V0UG9zaXRpb24ubGVmdDsgLy8gSWYgZWxlbWVudCBpcyBhIGA8YnI+YCB0YWcgcmV0dXJuIGhlcmVcblxuXG4gICAgaWYgKC9eYnIkL2kudGVzdChub2RlLm5vZGVOYW1lKSkgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVzLmxpbmVzICYmIGlzV29yZExpa2UpIHtcbiAgICAgIC8vIFdlIGNvbXBhcmUgdGhlIHRvcCBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgd29yZCB0byB0aGUgdG9wIG9mZnNldCBvZlxuICAgICAgLy8gcHJldmlvdXMgd29yZHMgb24gdGhlIGN1cnJlbnQgbGluZS4gSWYgdGhlIGRpZmZlcmVuY2UgaXMgZ3JlYXRlciB0aGFuXG4gICAgICAvLyBvdXIgZGVmaW5lZCB0aHJlc2hvbGQgKDIwJSksIHdlIGFzc3VtZSB0aGlzIHdvcmQgaXMgb24gYSBuZXcgbGluZS5cbiAgICAgIGlmIChsaW5lT2Zmc2V0WSA9PT0gbnVsbCB8fCB0b3AgLSBsaW5lT2Zmc2V0WSA+PSBsaW5lVGhyZXNob2xkKSB7XG4gICAgICAgIGxpbmVPZmZzZXRZID0gdG9wO1xuICAgICAgICB3b3Jkc0luRWFjaExpbmUucHVzaCh3b3Jkc0luQ3VycmVudExpbmUgPSBbXSk7XG4gICAgICB9IC8vIEFkZCB0aGUgY3VycmVudCB3b3JkIG5vZGUgdG8gdGhlIGxpbmUgYXJyYXlcblxuXG4gICAgICB3b3Jkc0luQ3VycmVudExpbmUucHVzaChub2RlKTtcbiAgICB9IC8vIEVORCBJRlxuXG5cbiAgICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBzcGxpdCB0ZXh0IG5vZGVzXG4gICAgICBzZXQobm9kZSwge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9KTsgLy8gRU5EIExPT1BcbiAgLy8gUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTVxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqKiBTUExJVCBMSU5FU1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuICBpZiAodHlwZXMubGluZXMpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgbGluZXMgb2YgdGV4dCAoc2VlIDExIGIpXG4gICAgLy8gTGV0IGBsaW5lYCBiZSB0aGUgYXJyYXkgb2Ygd29yZHMgaW4gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHdyYXBwZWQgbGluZSBlbGVtZW50cyAobGluZUVsZW1lbnRzKVxuICAgIGxpbmVzID0gd29yZHNJbkVhY2hMaW5lLm1hcChmdW5jdGlvbiAod29yZHNJblRoaXNMaW5lKSB7XG4gICAgICAvLyBDcmVhdGUgYW4gZWxlbWVudCB0byB3cmFwIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICB2YXIgbGluZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFRBR19OQU1FLCB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJcIi5jb25jYXQoc2V0dGluZ3Muc3BsaXRDbGFzcywgXCIgXCIpLmNvbmNhdChzZXR0aW5ncy5saW5lQ2xhc3MpLFxuICAgICAgICBzdHlsZTogXCJkaXNwbGF5OiBibG9jazsgdGV4dC1hbGlnbjogXCIuY29uY2F0KGFsaWduLCBcIjsgd2lkdGg6IDEwMCU7XCIpXG4gICAgICB9KTtcbiAgICAgIHNldChsaW5lRWxlbWVudCwgJ2lzTGluZScsIHRydWUpO1xuICAgICAgdmFyIGxpbmVEaW1lbnNpb25zID0ge1xuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMWU0XG4gICAgICB9OyAvLyBBcHBlbmQgdGhlIGBsaW5lRWxlbWVudGAgdG8gYGNvbnRhaW5lcmBcblxuICAgICAgc3BsaXRUZXh0LmFwcGVuZENoaWxkKGxpbmVFbGVtZW50KTsgLy8gSXRlcmF0ZSBvdmVyIHRoZSB3b3JkLWxldmVsIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAvLyBOb3RlOiB3b3JkT3JFbGVtZW50IGNhbiBlaXRoZXIgYmUgYSB3b3JkIG5vZGUgb3IgbmVzdGVkIGVsZW1lbnRcblxuICAgICAgd29yZHNJblRoaXNMaW5lLmZvckVhY2goZnVuY3Rpb24gKHdvcmRPckVsZW1lbnQsIGlkeCwgYXJyKSB7XG4gICAgICAgIHZhciBfZGF0YSRnZXQgPSBnZXQod29yZE9yRWxlbWVudCksXG4gICAgICAgICAgICBpc1dvcmRFbmQgPSBfZGF0YSRnZXQuaXNXb3JkRW5kLFxuICAgICAgICAgICAgdG9wID0gX2RhdGEkZ2V0LnRvcCxcbiAgICAgICAgICAgIGhlaWdodCA9IF9kYXRhJGdldC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIG5leHQgPSBhcnJbaWR4ICsgMV07IC8vIERldGVybWluZSBsaW5lIGhlaWdodCAvIHktcG9zaXRpb25cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBoZWlnaHQgYW5kIG9mZnNldFRvcCBvZiB0aGUgd29yZHMgd2hpY2ggd2UgYWxyZWFkeVxuICAgICAgICAvLyByZWNvcmRlZC4gQmVjYXVzZSBjdXN0b20gbmVzdGVkIGVsZW1lbnRzIGNvdWxkIGhhdmUgdGhlaXIgb3duXG4gICAgICAgIC8vIHN0eWxlcywgdGhlIHdvcmRzIG9uIGEgbGluZSBtYXkgbm90IGFsbCBiZSB0aGUgc2FtZSBoZWlnaHQgb3JcbiAgICAgICAgLy8geSBwb3NpdGlvbi4gU28gd2UgdGFrZSB0aGUgZ3JlYXRlc3QgaGVpZ2h0IC8geSAtIG9mZnNldCBvZiB0aGVcbiAgICAgICAgLy8gd29yZHMgb24gdGhpcyBsaW5lLlxuXG4gICAgICAgIGxpbmVEaW1lbnNpb25zLmhlaWdodCA9IE1hdGgubWF4KGxpbmVEaW1lbnNpb25zLmhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgbGluZURpbWVuc2lvbnMudG9wID0gTWF0aC5taW4obGluZURpbWVuc2lvbnMudG9wLCB0b3ApOyAvLyBhcHBlbmQgdGhlIGN1cnJlbnQgd29yZC9lbGVtZW50XG5cbiAgICAgICAgbGluZUVsZW1lbnQuYXBwZW5kQ2hpbGQod29yZE9yRWxlbWVudCk7IC8vIERldGVybWluZSBpZiB0aGVyZSBzaG91bGQgc3BhY2UgYWZ0ZXIgdGhlIGN1cnJlbnQgZWxlbWVudC4uLlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCB3b3JkIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgIC8vIFRPRE8gLSBsb2dpYyBmb3IgaGFuZGluZyBzcGFjaW5nIGNhbiBiZSBpbXByb3ZlZFxuXG4gICAgICAgIGlmIChpc1dvcmRFbmQgJiYgZ2V0KG5leHQpLmlzV29yZFN0YXJ0KSB7XG4gICAgICAgICAgbGluZUVsZW1lbnQuYXBwZW5kKCcgJyk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBFTkQgTE9PUFxuXG4gICAgICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAgICAgc2V0KGxpbmVFbGVtZW50LCB7XG4gICAgICAgICAgaGVpZ2h0OiBsaW5lRGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgdG9wOiBsaW5lRGltZW5zaW9ucy50b3BcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lRWxlbWVudDtcbiAgICB9KTsgLy8gRU5EIExPT1BcblxuICAgIGlmICghdHlwZXMud29yZHMpIHtcbiAgICAgIHVuU3BsaXRXb3JkcyhzcGxpdFRleHQpO1xuICAgIH0gLy8gMTAuIEluc2VydCB0aGUgbmV3IGNvbnRhaW5lclxuXG5cbiAgICBlbGVtZW50LnJlcGxhY2VDaGlsZHJlbihzcGxpdFRleHQpO1xuICB9XG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiogIFNFVCBBQlNPTFVURSBQT1NJVElPTlxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8vIEFwcGx5IGFic29sdXRlIHBvc2l0aW9uaW5nIHRvIGFsbCBjaGlsZCBlbGVtZW50cyBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gIC8vIFRoaXMgaW5jbHVkZXMgc3BsaXQgbGluZXMsIHdvcmRzLCBjaGFycywgYW5kIGN1c3RvbSBIVE1MIGVsZW1lbnRzIHRoYXQgd2VyZVxuICAvLyBpbmNsdWRlZCBieSB0aGUgdXNlci4gVGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIGNoaWxkIGVsZW1lbnRzIGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gcmVjb3JkZWQgYmVmb3JlIHNwbGl0dGluZyB0ZXh0IGludG8gbGluZXMuXG5cblxuICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAvLyBTZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcGFyZW50IGVsZW1lbnQgc28gaXQgZG9lcyBub3QgY29sbGFwc2VcbiAgICAvLyB3aGVuIGl0cyBjaGlsZHJlbiBhcmUgc2V0IHRvIGFic29sdXRlIHBvc2l0aW9uLlxuICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChlbGVtZW50LnN0eWxlLndpZHRoIHx8IGVsZW1lbnRXaWR0aCwgXCJweFwiKTtcbiAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGVsZW1lbnRIZWlnaHQsIFwicHhcIik7IC8vIEl0ZXJhdGUgb3ZlciBhbGwgY2hpbGQgZWxlbWVudHNcblxuICAgIHRvQXJyYXkobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBfZGF0YSRnZXQyID0gZ2V0KG5vZGUpLFxuICAgICAgICAgIGlzTGluZSA9IF9kYXRhJGdldDIuaXNMaW5lLFxuICAgICAgICAgIHRvcCA9IF9kYXRhJGdldDIudG9wLFxuICAgICAgICAgIGxlZnQgPSBfZGF0YSRnZXQyLmxlZnQsXG4gICAgICAgICAgd2lkdGggPSBfZGF0YSRnZXQyLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9kYXRhJGdldDIuaGVpZ2h0O1xuXG4gICAgICB2YXIgcGFyZW50RGF0YSA9IGdldChub2RlLnBhcmVudEVsZW1lbnQpO1xuICAgICAgdmFyIGlzQ2hpbGRPZkxpbmVOb2RlID0gIWlzTGluZSAmJiBwYXJlbnREYXRhLmlzTGluZTsgLy8gU2V0IHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgIC8vIC0+IElmIGBub2RlYCBhIGxpbmUgZWxlbWVudCwgd2UgdXNlIHRoZSB0b3Agb2Zmc2V0IG9mIGl0cyBmaXJzdCBjaGlsZFxuICAgICAgLy8gLT4gSWYgYG5vZGVgIHRoZSBjaGlsZCBvZiBsaW5lIGVsZW1lbnQsIHRoZW4gaXRzIHRvcCBvZmZzZXQgaXMgemVyb1xuXG4gICAgICBub2RlLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGlzQ2hpbGRPZkxpbmVOb2RlID8gdG9wIC0gcGFyZW50RGF0YS50b3AgOiB0b3AsIFwicHhcIik7IC8vIFNldCB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAgLy8gLT4gSUYgYG5vZGVgIGlzIGEgbGluZSBlbGVtZW50LCB0aGlzIGlzIGVxdWFsIHRvIHRoZSBwb3NpdGlvbiBsZWZ0IG9mXG4gICAgICAvLyAgICB0aGUgY29udGVudCBib3ggb2YgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAvLyAtPiBJRiBgbm9kZWAgaXMgdGhlIGNoaWxkIG9mIGEgbGluZSBlbGVtZW50LCB0aGUgdmFsdWUgaGFzIHRvIGFkanVzdGVkXG4gICAgICAvLyAgICBzbyBpdHMgcmVsYXRpdmUgdG8gdGhlIGxpbmUgZWxlbWVudFxuXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBpc0xpbmUgPyBcIlwiLmNvbmNhdChjb250ZW50Qm94LmxlZnQsIFwicHhcIikgOiBcIlwiLmNvbmNhdChsZWZ0IC0gKGlzQ2hpbGRPZkxpbmVOb2RlID8gY29udGVudEJveC5sZWZ0IDogMCksIFwicHhcIik7IC8vIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJyZW50IG5vZGUgdG8gdGhlIGNhY2hlZCB2YWx1ZS5cblxuICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIik7IC8vICBTZXQgdGhlIHdpZHRoIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAvLyAgSWYgaXRzIGEgbGluZSBlbGVtZW50LCB3aWR0aCBpcyBlcXVhbCB0byB0aGUgd2lkdGggb2YgdGhlIGNvbnRlbnRCb3guXG5cbiAgICAgIG5vZGUuc3R5bGUud2lkdGggPSBpc0xpbmUgPyBcIlwiLmNvbmNhdChjb250ZW50Qm94LndpZHRoLCBcInB4XCIpIDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIik7IC8vIEZpbmFsbHksIHNldCB0aGUgbm9kZSdzIHBvc2l0aW9uIHRvIGFic29sdXRlLlxuXG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB9KTtcbiAgfSAvLyBlbmQgaWY7XG4gIC8vIDE0LiBSZS1hdHRhY2ggdGhlIGVsZW1lbnQgdG8gdGhlIERPTVxuXG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChuZXh0U2libGluZykgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtZW50LCBuZXh0U2libGluZyk7ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG5cbnZhciBfZGVmYXVsdHMgPSBleHRlbmQoZGVmYXVsdHMsIHt9KTtcblxudmFyIFNwbGl0VHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhTcGxpdFR5cGUsIG51bGwsIFt7XG4gICAga2V5OiBcImNsZWFyRGF0YVwiLFxuXG4gICAgLyoqXG4gICAgICogQ0xlYXJzIGFsbCBkYXRhXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRGF0YSgpIHtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgc3BsaXRUeXBlIGluc3RhbmNlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERlZmF1bHRzXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgU3BsaXRUeXBlIGluc3RhbmNlcy5cbiAgICAgKiBUaGUgcHJvdmlkZWQgb2JqZWN0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGRlZmF1bHRzIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldHRpbmdzIHRvIG92ZXJyaWRlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIG5ldyBkZWZhdWx0IHNldHRpbmdzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFNwbGl0VHlwZS5zZXREZWZhdWx0cyh7IFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiIH0pXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICAgIF9kZWZhdWx0cyA9IGV4dGVuZChfZGVmYXVsdHMsIHBhcnNlU2V0dGluZ3Mob3B0aW9ucykpO1xuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGFyZ2V0IGVsZW1lbnRzIHRvIHRoZWlyIG9yaWdpbmFsIGh0bWwgY29udGVudFxuICAgICAqIEhhcyBubyBlZmZlY3Qgb24gdGhhdFxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVsZW1lbnRzIFRoZSB0YXJnZXQgZWxlbWVudHMgdG8gcmV2ZXJ0LiBPbmUgb2Y6XG4gICAgICogIC0ge3N0cmluZ30gQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiAgLSB7SFRNTEVsZW1lbnR9IEEgc2luZ2xlIGVsZW1lbnRcbiAgICAgKiAtICB7Tm9kZUxpc3R9IEEgTm9kZUxpc3Qgb3IgY29sbGVjdGlvblxuICAgICAqICAtIHtIVE1MRWxlbWVudFtdfSBBbiBhcnJheSBvZiBFbGVtZW50c1xuICAgICAqIC0gIHtBcnJheTxIVE1MRWxlbWVudHxOb2RlTGlzdHxIVE1MRWxlbWVudFtdPn0gQSBuZXN0ZWQgYXJyYXkgb2YgZWxlbWVudHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KGVsZW1lbnRzKSB7XG4gICAgICBnZXRUYXJnZXRFbGVtZW50cyhlbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX2RhdGEkZ2V0ID0gZ2V0KGVsZW1lbnQpLFxuICAgICAgICAgICAgaXNTcGxpdCA9IF9kYXRhJGdldC5pc1NwbGl0LFxuICAgICAgICAgICAgaHRtbCA9IF9kYXRhJGdldC5odG1sLFxuICAgICAgICAgICAgY3NzV2lkdGggPSBfZGF0YSRnZXQuY3NzV2lkdGgsXG4gICAgICAgICAgICBjc3NIZWlnaHQgPSBfZGF0YSRnZXQuY3NzSGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1NwbGl0KSB7XG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBjc3NXaWR0aCB8fCAnJztcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGNzc0hlaWdodCB8fCAnJztcbiAgICAgICAgICByZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNwbGl0VHlwZSBpbnN0YW5jZVxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCBwcm92aWRlcyBhIHdheSB0byBjcmVhdGUgYSBgU3BsaXRUeXBlYCBpbnN0YW5jZSB3aXRob3V0XG4gICAgICogdXNpbmcgdGhlIGBuZXdgIGtleXdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0YXJnZXQgZWxlbWVudHMgdG8gc3BsaXQuIE9uZSBvZjpcbiAgICAgKiAgLSB7c3RyaW5nfSBBIGNzcyBzZWxlY3RvclxuICAgICAqICAtIHtIVE1MRWxlbWVudH0gQSBzaW5nbGUgZWxlbWVudFxuICAgICAqIC0gIHtOb2RlTGlzdH0gQSBOb2RlTGlzdCBvciBjb2xsZWN0aW9uXG4gICAgICogIC0ge0hUTUxFbGVtZW50W119IEFuIGFycmF5IG9mIEVsZW1lbnRzXG4gICAgICogLSAge0FycmF5PEhUTUxFbGVtZW50fE5vZGVMaXN0fEhUTUxFbGVtZW50W10+fSBBIG5lc3RlZCBhcnJheSBvZiBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2V0dGluZ3MgZm9yIHRoZSBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTcGxpdFR5cGV9IHRoZSBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBTcGxpdFR5cGUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgU3BsaXRUeXBlYCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVsZW1lbnRzIFRoZSB0YXJnZXQgZWxlbWVudHMgdG8gc3BsaXQuIE9uZSBvZjpcbiAgICAgKiAgLSB7c3RyaW5nfSBBIGNzcyBzZWxlY3RvclxuICAgICAqICAtIHtIVE1MRWxlbWVudH0gQSBzaW5nbGUgZWxlbWVudFxuICAgICAqIC0gIHtOb2RlTGlzdH0gQSBOb2RlTGlzdCBvciBjb2xsZWN0aW9uXG4gICAgICogIC0ge0hUTUxFbGVtZW50W119IEFuIGFycmF5IG9mIEVsZW1lbnRzXG4gICAgICogLSAge0FycmF5PEhUTUxFbGVtZW50fE5vZGVMaXN0fEhUTUxFbGVtZW50W10+fSBBIG5lc3RlZCBhcnJheSBvZiBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2V0dGluZ3MgZm9yIHRoZSBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRhdGFcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgU3BsaXRUeXBlIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgYFNwbGl0VHlwZS5kZWZhdWx0c2AgdG8gYW4gb2JqZWN0IHdpbGwgbWVyZ2UgdGhhdCBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBleGlzdGluZyBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2V0dGluZ3MgdG8gb3ZlcnJpZGVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFNwbGl0VHlwZS5kZWZhdWx0cyA9IHsgXCJwb3NpdGlvblwiOiBcImFic29sdXRlXCIgfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgICBfZGVmYXVsdHMgPSBleHRlbmQoX2RlZmF1bHRzLCBwYXJzZVNldHRpbmdzKG9wdGlvbnMpKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBTcGxpdFR5cGUoZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BsaXRUeXBlKTtcblxuICAgIHRoaXMuaXNTcGxpdCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBleHRlbmQoX2RlZmF1bHRzLCBwYXJzZVNldHRpbmdzKG9wdGlvbnMpKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZ2V0VGFyZ2V0RWxlbWVudHMoZWxlbWVudHMpOyAvLyBTdGFydCB0aGUgc3BsaXQgcHJvY2Vzc1xuXG4gICAgdGhpcy5zcGxpdCgpO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdHMgdGhlIHRleHQgaW4gYWxsIHRhcmdldCBlbGVtZW50cy4gVGhpcyBtZXRob2QgaXMgY2FsbGVkXG4gICAqIGF1dG9tYXRpY2FsbHkgd2hlbiBhIG5ldyBTcGxpdFR5cGUgaW5zdGFuY2UgaXMgY3JlYXRlZC4gSXQgY2FuIGFsc28gYmVcbiAgICogY2FsbGVkIG1hbnVhbGx5IHRvIHJlLXNwbGl0IHRleHQgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHB1YmxpY1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTcGxpdFR5cGUsIFt7XG4gICAga2V5OiBcInNwbGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0JDEob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gUmV2ZXJ0IHRhcmdldCBlbGVtZW50cyAoaWYgdGhleSBhcmUgYWxyZWFkeSBzcGxpdClcbiAgICAgIC8vIE5vdGU6IHJldmVydCB3YXMgYWxyZWFkeSBjYWxsZWQgb25jZSBpbiB0aGUgY29uc3RydWN0b3IuIEhvd2V2ZXIsIHdlXG4gICAgICAvLyBuZWVkIHRvIGNhbGwgaXQgYWdhaW4gaGVyZSBzbyB0ZXh0IGlzIHJldmVydGVkIHdoZW4gdGhlIHVzZXIgbWFudWFsbHlcbiAgICAgIC8vIGNhbGxzIHRoZSBgc3BsaXRgIG1ldGhvZCB0byByZS1zcGxpdCB0ZXh0LlxuICAgICAgdGhpcy5yZXZlcnQoKTsgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGh0bWwgY29udGVudCBvZiBlYWNoIHRhcmdldCBlbGVtZW50XG5cbiAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBzZXQoZWxlbWVudCwgJ2h0bWwnLCBlbGVtZW50LmlubmVySFRNTCk7XG4gICAgICB9KTsgLy8gQ3JlYXRlIGFycmF5cyB0byBob2xkIHRoZSBzcGxpdCBsaW5lcywgd29yZHMsIGFuZCBjaGFyYWN0ZXJzXG5cbiAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICAgIHRoaXMuY2hhcnMgPSBbXTsgLy8gY2FjaGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIGJlZm9yZSBzcGxpdHRpbmdcblxuICAgICAgdmFyIHNjcm9sbFBvcyA9IFt3aW5kb3cucGFnZVhPZmZzZXQsIHdpbmRvdy5wYWdlWU9mZnNldF07IC8vIElmIG5ldyBvcHRpb25zIHdlcmUgcGFzc2VkIGludG8gdGhlIGBzcGxpdCgpYCBtZXRob2QsIHVwZGF0ZSBzZXR0aW5nc1xuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBleHRlbmQodGhpcy5zZXR0aW5ncywgcGFyc2VTZXR0aW5ncyhvcHRpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlcyA9IHBhcnNlVHlwZXModGhpcy5zZXR0aW5ncy50eXBlcyk7IC8vIElmIHRoZSBgdHlwZXNgIG9wdGlvbiBpcyBzZXQgdG8gYW4gZW1wdHkgYXJyYXksIHRleHQgd2lsbCBub3QgYmUgc3BsaXQuXG4gICAgICAvLyBAZXhhbXBsZSBuZXcgU3BsaXRUeXBlKCcjdGFyZ2V0JywgeyB0eXBlczogW10gfSlcblxuICAgICAgaWYgKHR5cGVzLm5vbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBTcGxpdCB0ZXh0IGluIGVhY2ggdGFyZ2V0IGVsZW1lbnRcblxuXG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzcGxpdCB0ZXh0IG5vZGVzIGZyb20gdGhpcyBlbGVtZW50IHRvIHRoZSBhcnJheXMgb2YgYWxsIHNwbGl0XG4gICAgICAgIC8vIHRleHQgbm9kZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgIHNldChlbGVtZW50LCAnaXNSb290JywgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIF9zcGxpdDIgPSBzcGxpdChlbGVtZW50LCBfdGhpcy5zZXR0aW5ncyksXG4gICAgICAgICAgICB3b3JkcyA9IF9zcGxpdDIud29yZHMsXG4gICAgICAgICAgICBjaGFycyA9IF9zcGxpdDIuY2hhcnM7XG5cbiAgICAgICAgX3RoaXMud29yZHMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLndvcmRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHdvcmRzKSk7XG4gICAgICAgIF90aGlzLmNoYXJzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5jaGFycyksIF90b0NvbnN1bWFibGVBcnJheShjaGFycykpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxpbmVzIHx8IF90aGlzLnNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgICAgICAgdmFyIGxpbmVzID0gcmVwb3NpdGlvbkFmdGVyU3BsaXQoZWxlbWVudCwgX3RoaXMuc2V0dGluZ3MsIHNjcm9sbFBvcyk7XG4gICAgICAgICAgX3RoaXMubGluZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLmxpbmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZXQgaXNTcGxpdCB0byB0cnVlIGZvciB0aGUgU3BsaXRUeXBlIGluc3RhbmNlXG5cbiAgICAgIHRoaXMuaXNTcGxpdCA9IHRydWU7IC8vIFNldCBzY3JvbGwgcG9zaXRpb24gdG8gY2FjaGVkIHZhbHVlLlxuXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsUG9zWzBdLCBzY3JvbGxQb3NbMV0pOyAvLyBDbGVhbiB1cCBzdG9yZWQgZGF0YVxuXG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGFyZ2V0IGVsZW1lbnQocykgYmFjayB0byB0aGVpciBvcmlnaW5hbCBodG1sIGNvbnRlbnRcbiAgICAgKiBEZWxldGVzIGFsbCBzdG9yZWQgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHRhcmdldCBlbGVtZW50c1xuICAgICAqIFJlc2V0cyB0aGUgcHJvcGVydGllcyBvbiB0aGUgc3BsaXRUeXBlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KCkge1xuICAgICAgaWYgKHRoaXMuaXNTcGxpdCkge1xuICAgICAgICAvLyBSZXNldCBpbnN0YW5jZSBwcm9wZXJ0aWVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLmxpbmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU3BsaXQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgU3BsaXRUeXBlLnJldmVydCh0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BsaXRUeXBlO1xufSgpO1xuXG5leHBvcnQgeyBTcGxpdFR5cGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImFwcGVuZCIsImxlbmd0aCIsImFyZ3VtZW50cyIsImkiLCJub2RlIiwidW5kZWZpbmVkIiwibm9kZVR5cGUiLCJhcHBlbmRDaGlsZCIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJTdHJpbmciLCJyZXBsYWNlQ2hpbGRyZW4iLCJsYXN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImFwcGx5IiwicmVwbGFjZVdpdGgiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiX2xlbiIsIm5vZGVzIiwiQXJyYXkiLCJfa2V5Iiwib3duZXJEb2N1bWVudCIsInJlcGxhY2VDaGlsZCIsImluc2VydEJlZm9yZSIsInByZXZpb3VzU2libGluZyIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJEb2N1bWVudEZyYWdtZW50IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsIl9vYmplY3RTcHJlYWQyIiwic291cmNlIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZyb20iLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwiZXJyIiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiZXh0ZW5kIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInJlZHVjZSIsImV4dGVuZGVkIiwiY3VycmVudFZhbHVlIiwibmV3VmFsdWUiLCJpc1N0cmluZyIsInBhcnNlU2V0dGluZ3MiLCJzZXR0aW5ncyIsInR5cGVzIiwic3BsaXQiLCJtYXAiLCJ0eXBlIiwidHJpbSIsImFic29sdXRlIiwicG9zaXRpb24iLCJwYXJzZVR5cGVzIiwibm9uZSIsImxpbmVzIiwid29yZHMiLCJjaGFycyIsImlzT2JqZWN0IiwiaXNOb2RlIiwiaW5wdXQiLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwidG9BcnJheSIsImdldFRhcmdldEVsZW1lbnRzIiwiZWxlbWVudHMiLCJnZXRFbGVtZW50QnlJZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZXN1bHQiLCJlbGVtZW50IiwiY29uY2F0IiwiZW50cmllcyIsImV4cGFuZG8iLCJjYWNoZSIsInVpZCIsInNldCIsIm93bmVyIiwiY29uc29sZSIsIndhcm4iLCJpZCIsImRhdGEiLCJnZXRQcm90b3R5cGVPZiIsImdldCIsInJlbW92ZSIsImNsZWFyIiwiY2xlYW51cCIsIl9yZWYiLCJfcmVmMiIsIl9yZWYyJCIsImlzUm9vdCIsImlzU3BsaXQiLCJ0b1dvcmRzIiwic2VwYXJhdG9yIiwic3RyaW5nIiwicmVwbGFjZSIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNBc3RyYWwiLCJyc0NvbWJvIiwicnNGaXR6IiwicnNNb2RpZmllciIsInJzTm9uQXN0cmFsIiwicnNSZWdpb25hbCIsInJzU3VyclBhaXIiLCJyc1pXSiIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJqb2luIiwicnNTZXEiLCJyc1N5bWJvbCIsInJlVW5pY29kZSIsIlJlZ0V4cCIsInVuaWNvZGVSYW5nZSIsInJlSGFzVW5pY29kZSIsImFzY2lpVG9BcnJheSIsImhhc1VuaWNvZGUiLCJ1bmljb2RlVG9BcnJheSIsIm1hdGNoIiwic3RyaW5nVG9BcnJheSIsInRvQ2hhcnMiLCJjcmVhdGVFbGVtZW50IiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZSIsInJhd1ZhbHVlIiwic2V0QXR0cmlidXRlIiwiZGVmYXVsdHMiLCJzcGxpdENsYXNzIiwibGluZUNsYXNzIiwid29yZENsYXNzIiwiY2hhckNsYXNzIiwidGFnTmFtZSIsInNwbGl0V29yZHNBbmRDaGFycyIsInRleHROb2RlIiwiVEFHX05BTUUiLCJWQUxVRSIsIm5vZGVWYWx1ZSIsInNwbGl0VGV4dCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJXT1JEIiwiaWR4Iiwid29yZEVsZW1lbnQiLCJjaGFyYWN0ZXJFbGVtZW50c0ZvckN1cnJlbnRXb3JkIiwiQ0hBUiIsImNoYXJhY3RlckVsZW1lbnQiLCJzdHlsZSIsImNoaWxkcmVuIiwiaXNXb3JkIiwiaXNXb3JkU3RhcnQiLCJpc1dvcmRFbmQiLCJ3b3Jkc0FuZENoYXJzIiwiY2hpbGROb2RlcyIsImRpc3BsYXkiLCJuZXh0U2libGluZyIsInByZXZTaWJsaW5nIiwidGV4dCIsInRleHRDb250ZW50IiwidGV4dEFmdGVyIiwidGV4dEJlZm9yZSIsImNoaWxkIiwiX3NwbGl0IiwiZ2V0UG9zaXRpb24iLCJzY3JvbGxQb3MiLCJ0b3AiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJfc2Nyb2xsUG9zIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJwYXJlbnRYIiwicGFyZW50WSIsImJvZHkiLCJwYXJlbnRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJfbm9kZSRnZXRCb3VuZGluZ0NsaWUiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ1blNwbGl0V29yZHMiLCJjcmVhdGVGcmFnbWVudCIsInJlcG9zaXRpb25BZnRlclNwbGl0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJ3b3Jkc0luRWFjaExpbmUiLCJ3b3Jkc0luQ3VycmVudExpbmUiLCJsaW5lT2Zmc2V0WSIsImVsZW1lbnRIZWlnaHQiLCJlbGVtZW50V2lkdGgiLCJjb250ZW50Qm94IiwicGFyZW50RWxlbWVudCIsIm5leHRFbGVtZW50U2libGluZyIsImNzIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFsaWduIiwidGV4dEFsaWduIiwiZm9udFNpemUiLCJwYXJzZUZsb2F0IiwibGluZVRocmVzaG9sZCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImNzc1dpZHRoIiwiY3NzSGVpZ2h0IiwiaXNXb3JkTGlrZSIsIl9nZXRQb3NpdGlvbiIsIm5vZGVOYW1lIiwid29yZHNJblRoaXNMaW5lIiwibGluZUVsZW1lbnQiLCJsaW5lRGltZW5zaW9ucyIsIndvcmRPckVsZW1lbnQiLCJfZGF0YSRnZXQiLCJNYXRoIiwibWF4IiwibWluIiwiX2RhdGEkZ2V0MiIsImlzTGluZSIsInBhcmVudERhdGEiLCJpc0NoaWxkT2ZMaW5lTm9kZSIsIl9kZWZhdWx0cyIsIlNwbGl0VHlwZSIsImNsZWFyRGF0YSIsInNldERlZmF1bHRzIiwib3B0aW9ucyIsInJldmVydCIsImh0bWwiLCJpbm5lckhUTUwiLCJjcmVhdGUiLCJzcGxpdCQxIiwiX3RoaXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiX3NwbGl0MiIsInNjcm9sbFRvIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/split-type/dist/index.js\n");

/***/ })

};
;