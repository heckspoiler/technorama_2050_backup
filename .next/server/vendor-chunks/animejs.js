"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/animejs";
exports.ids = ["vendor-chunks/animejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/animejs/lib/anime.es.js":
/*!**********************************************!*\
  !*** ./node_modules/animejs/lib/anime.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * anime.js v3.2.2\n * (c) 2023 Julian Garnier\n * Released under the MIT license\n * animejs.com\n */ // Defaults\nvar defaultInstanceSettings = {\n    update: null,\n    begin: null,\n    loopBegin: null,\n    changeBegin: null,\n    change: null,\n    changeComplete: null,\n    loopComplete: null,\n    complete: null,\n    loop: 1,\n    direction: \"normal\",\n    autoplay: true,\n    timelineOffset: 0\n};\nvar defaultTweenSettings = {\n    duration: 1000,\n    delay: 0,\n    endDelay: 0,\n    easing: \"easeOutElastic(1, .5)\",\n    round: 0\n};\nvar validTransforms = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"perspective\",\n    \"matrix\",\n    \"matrix3d\"\n];\n// Caching\nvar cache = {\n    CSS: {},\n    springs: {}\n};\n// Utils\nfunction minMax(val, min, max) {\n    return Math.min(Math.max(val, min), max);\n}\nfunction stringContains(str, text) {\n    return str.indexOf(text) > -1;\n}\nfunction applyArguments(func, args) {\n    return func.apply(null, args);\n}\nvar is = {\n    arr: function(a) {\n        return Array.isArray(a);\n    },\n    obj: function(a) {\n        return stringContains(Object.prototype.toString.call(a), \"Object\");\n    },\n    pth: function(a) {\n        return is.obj(a) && a.hasOwnProperty(\"totalLength\");\n    },\n    svg: function(a) {\n        return a instanceof SVGElement;\n    },\n    inp: function(a) {\n        return a instanceof HTMLInputElement;\n    },\n    dom: function(a) {\n        return a.nodeType || is.svg(a);\n    },\n    str: function(a) {\n        return typeof a === \"string\";\n    },\n    fnc: function(a) {\n        return typeof a === \"function\";\n    },\n    und: function(a) {\n        return typeof a === \"undefined\";\n    },\n    nil: function(a) {\n        return is.und(a) || a === null;\n    },\n    hex: function(a) {\n        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);\n    },\n    rgb: function(a) {\n        return /^rgb/.test(a);\n    },\n    hsl: function(a) {\n        return /^hsl/.test(a);\n    },\n    col: function(a) {\n        return is.hex(a) || is.rgb(a) || is.hsl(a);\n    },\n    key: function(a) {\n        return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== \"targets\" && a !== \"keyframes\";\n    }\n};\n// Easings\nfunction parseEasingParameters(string) {\n    var match = /\\(([^)]+)\\)/.exec(string);\n    return match ? match[1].split(\",\").map(function(p) {\n        return parseFloat(p);\n    }) : [];\n}\n// Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js\nfunction spring(string, duration) {\n    var params = parseEasingParameters(string);\n    var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);\n    var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);\n    var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);\n    var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);\n    var w0 = Math.sqrt(stiffness / mass);\n    var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n    var a = 1;\n    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n    function solver(t) {\n        var progress = duration ? duration * t / 1000 : t;\n        if (zeta < 1) {\n            progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n        } else {\n            progress = (a + b * progress) * Math.exp(-progress * w0);\n        }\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        return 1 - progress;\n    }\n    function getDuration() {\n        var cached = cache.springs[string];\n        if (cached) {\n            return cached;\n        }\n        var frame = 1 / 6;\n        var elapsed = 0;\n        var rest = 0;\n        while(true){\n            elapsed += frame;\n            if (solver(elapsed) === 1) {\n                rest++;\n                if (rest >= 16) {\n                    break;\n                }\n            } else {\n                rest = 0;\n            }\n        }\n        var duration = elapsed * frame * 1000;\n        cache.springs[string] = duration;\n        return duration;\n    }\n    return duration ? solver : getDuration;\n}\n// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\nfunction steps(steps) {\n    if (steps === void 0) steps = 10;\n    return function(t) {\n        return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);\n    };\n}\n// BezierEasing https://github.com/gre/bezier-easing\nvar bezier = function() {\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > 0.0000001 && ++i < 10);\n        return currentT;\n    }\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n        for(var i = 0; i < 4; ++i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function bezier(mX1, mY1, mX2, mY2) {\n        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n            return;\n        }\n        var sampleValues = new Float32Array(kSplineTableSize);\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            for(var i = 0; i < kSplineTableSize; ++i){\n                sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n            }\n        }\n        function getTForX(aX) {\n            var intervalStart = 0;\n            var currentSample = 1;\n            var lastSample = kSplineTableSize - 1;\n            for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n                intervalStart += kSampleStepSize;\n            }\n            --currentSample;\n            var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n            var guessForT = intervalStart + dist * kSampleStepSize;\n            var initialSlope = getSlope(guessForT, mX1, mX2);\n            if (initialSlope >= 0.001) {\n                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n            } else if (initialSlope === 0.0) {\n                return guessForT;\n            } else {\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        }\n        return function(x) {\n            if (mX1 === mY1 && mX2 === mY2) {\n                return x;\n            }\n            if (x === 0 || x === 1) {\n                return x;\n            }\n            return calcBezier(getTForX(x), mY1, mY2);\n        };\n    }\n    return bezier;\n}();\nvar penner = function() {\n    // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)\n    var eases = {\n        linear: function() {\n            return function(t) {\n                return t;\n            };\n        }\n    };\n    var functionEasings = {\n        Sine: function() {\n            return function(t) {\n                return 1 - Math.cos(t * Math.PI / 2);\n            };\n        },\n        Expo: function() {\n            return function(t) {\n                return t ? Math.pow(2, 10 * t - 10) : 0;\n            };\n        },\n        Circ: function() {\n            return function(t) {\n                return 1 - Math.sqrt(1 - t * t);\n            };\n        },\n        Back: function() {\n            return function(t) {\n                return t * t * (3 * t - 2);\n            };\n        },\n        Bounce: function() {\n            return function(t) {\n                var pow2, b = 4;\n                while(t < ((pow2 = Math.pow(2, --b)) - 1) / 11){}\n                return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);\n            };\n        },\n        Elastic: function(amplitude, period) {\n            if (amplitude === void 0) amplitude = 1;\n            if (period === void 0) period = .5;\n            var a = minMax(amplitude, 1, 10);\n            var p = minMax(period, .1, 2);\n            return function(t) {\n                return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);\n            };\n        }\n    };\n    var baseEasings = [\n        \"Quad\",\n        \"Cubic\",\n        \"Quart\",\n        \"Quint\"\n    ];\n    baseEasings.forEach(function(name, i) {\n        functionEasings[name] = function() {\n            return function(t) {\n                return Math.pow(t, i + 2);\n            };\n        };\n    });\n    Object.keys(functionEasings).forEach(function(name) {\n        var easeIn = functionEasings[name];\n        eases[\"easeIn\" + name] = easeIn;\n        eases[\"easeOut\" + name] = function(a, b) {\n            return function(t) {\n                return 1 - easeIn(a, b)(1 - t);\n            };\n        };\n        eases[\"easeInOut\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;\n            };\n        };\n        eases[\"easeOutIn\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;\n            };\n        };\n    });\n    return eases;\n}();\nfunction parseEasings(easing, duration) {\n    if (is.fnc(easing)) {\n        return easing;\n    }\n    var name = easing.split(\"(\")[0];\n    var ease = penner[name];\n    var args = parseEasingParameters(easing);\n    switch(name){\n        case \"spring\":\n            return spring(easing, duration);\n        case \"cubicBezier\":\n            return applyArguments(bezier, args);\n        case \"steps\":\n            return applyArguments(steps, args);\n        default:\n            return applyArguments(ease, args);\n    }\n}\n// Strings\nfunction selectString(str) {\n    try {\n        var nodes = document.querySelectorAll(str);\n        return nodes;\n    } catch (e) {\n        return;\n    }\n}\n// Arrays\nfunction filterArray(arr, callback) {\n    var len = arr.length;\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    var result = [];\n    for(var i = 0; i < len; i++){\n        if (i in arr) {\n            var val = arr[i];\n            if (callback.call(thisArg, val, i, arr)) {\n                result.push(val);\n            }\n        }\n    }\n    return result;\n}\nfunction flattenArray(arr) {\n    return arr.reduce(function(a, b) {\n        return a.concat(is.arr(b) ? flattenArray(b) : b);\n    }, []);\n}\nfunction toArray(o) {\n    if (is.arr(o)) {\n        return o;\n    }\n    if (is.str(o)) {\n        o = selectString(o) || o;\n    }\n    if (o instanceof NodeList || o instanceof HTMLCollection) {\n        return [].slice.call(o);\n    }\n    return [\n        o\n    ];\n}\nfunction arrayContains(arr, val) {\n    return arr.some(function(a) {\n        return a === val;\n    });\n}\n// Objects\nfunction cloneObject(o) {\n    var clone = {};\n    for(var p in o){\n        clone[p] = o[p];\n    }\n    return clone;\n}\nfunction replaceObjectProps(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o1){\n        o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];\n    }\n    return o;\n}\nfunction mergeObjects(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o2){\n        o[p] = is.und(o1[p]) ? o2[p] : o1[p];\n    }\n    return o;\n}\n// Colors\nfunction rgbToRgba(rgbValue) {\n    var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n    return rgb ? \"rgba(\" + rgb[1] + \",1)\" : rgbValue;\n}\nfunction hexToRgba(hexValue) {\n    var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    var hex = hexValue.replace(rgx, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n    });\n    var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    var r = parseInt(rgb[1], 16);\n    var g = parseInt(rgb[2], 16);\n    var b = parseInt(rgb[3], 16);\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",1)\";\n}\nfunction hslToRgba(hslValue) {\n    var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hslValue) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(hslValue);\n    var h = parseInt(hsl[1], 10) / 360;\n    var s = parseInt(hsl[2], 10) / 100;\n    var l = parseInt(hsl[3], 10) / 100;\n    var a = hsl[4] || 1;\n    function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    var r, g, b;\n    if (s == 0) {\n        r = g = b = l;\n    } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return \"rgba(\" + r * 255 + \",\" + g * 255 + \",\" + b * 255 + \",\" + a + \")\";\n}\nfunction colorToRgb(val) {\n    if (is.rgb(val)) {\n        return rgbToRgba(val);\n    }\n    if (is.hex(val)) {\n        return hexToRgba(val);\n    }\n    if (is.hsl(val)) {\n        return hslToRgba(val);\n    }\n}\n// Units\nfunction getUnit(val) {\n    var split = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);\n    if (split) {\n        return split[1];\n    }\n}\nfunction getTransformUnit(propName) {\n    if (stringContains(propName, \"translate\") || propName === \"perspective\") {\n        return \"px\";\n    }\n    if (stringContains(propName, \"rotate\") || stringContains(propName, \"skew\")) {\n        return \"deg\";\n    }\n}\n// Values\nfunction getFunctionValue(val, animatable) {\n    if (!is.fnc(val)) {\n        return val;\n    }\n    return val(animatable.target, animatable.id, animatable.total);\n}\nfunction getAttribute(el, prop) {\n    return el.getAttribute(prop);\n}\nfunction convertPxToUnit(el, value, unit) {\n    var valueUnit = getUnit(value);\n    if (arrayContains([\n        unit,\n        \"deg\",\n        \"rad\",\n        \"turn\"\n    ], valueUnit)) {\n        return value;\n    }\n    var cached = cache.CSS[value + unit];\n    if (!is.und(cached)) {\n        return cached;\n    }\n    var baseline = 100;\n    var tempEl = document.createElement(el.tagName);\n    var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;\n    parentEl.appendChild(tempEl);\n    tempEl.style.position = \"absolute\";\n    tempEl.style.width = baseline + unit;\n    var factor = baseline / tempEl.offsetWidth;\n    parentEl.removeChild(tempEl);\n    var convertedUnit = factor * parseFloat(value);\n    cache.CSS[value + unit] = convertedUnit;\n    return convertedUnit;\n}\nfunction getCSSValue(el, prop, unit) {\n    if (prop in el.style) {\n        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n        var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || \"0\";\n        return unit ? convertPxToUnit(el, value, unit) : value;\n    }\n}\nfunction getAnimationType(el, prop) {\n    if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {\n        return \"attribute\";\n    }\n    if (is.dom(el) && arrayContains(validTransforms, prop)) {\n        return \"transform\";\n    }\n    if (is.dom(el) && prop !== \"transform\" && getCSSValue(el, prop)) {\n        return \"css\";\n    }\n    if (el[prop] != null) {\n        return \"object\";\n    }\n}\nfunction getElementTransforms(el) {\n    if (!is.dom(el)) {\n        return;\n    }\n    var str = el.style.transform || \"\";\n    var reg = /(\\w+)\\(([^)]*)\\)/g;\n    var transforms = new Map();\n    var m;\n    while(m = reg.exec(str)){\n        transforms.set(m[1], m[2]);\n    }\n    return transforms;\n}\nfunction getTransformValue(el, propName, animatable, unit) {\n    var defaultVal = stringContains(propName, \"scale\") ? 1 : 0 + getTransformUnit(propName);\n    var value = getElementTransforms(el).get(propName) || defaultVal;\n    if (animatable) {\n        animatable.transforms.list.set(propName, value);\n        animatable.transforms[\"last\"] = propName;\n    }\n    return unit ? convertPxToUnit(el, value, unit) : value;\n}\nfunction getOriginalTargetValue(target, propName, unit, animatable) {\n    switch(getAnimationType(target, propName)){\n        case \"transform\":\n            return getTransformValue(target, propName, animatable, unit);\n        case \"css\":\n            return getCSSValue(target, propName, unit);\n        case \"attribute\":\n            return getAttribute(target, propName);\n        default:\n            return target[propName] || 0;\n    }\n}\nfunction getRelativeValue(to, from) {\n    var operator = /^(\\*=|\\+=|-=)/.exec(to);\n    if (!operator) {\n        return to;\n    }\n    var u = getUnit(to) || 0;\n    var x = parseFloat(from);\n    var y = parseFloat(to.replace(operator[0], \"\"));\n    switch(operator[0][0]){\n        case \"+\":\n            return x + y + u;\n        case \"-\":\n            return x - y + u;\n        case \"*\":\n            return x * y + u;\n    }\n}\nfunction validateValue(val, unit) {\n    if (is.col(val)) {\n        return colorToRgb(val);\n    }\n    if (/\\s/g.test(val)) {\n        return val;\n    }\n    var originalUnit = getUnit(val);\n    var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;\n    if (unit) {\n        return unitLess + unit;\n    }\n    return unitLess;\n}\n// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes\n// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744\nfunction getDistance(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nfunction getCircleLength(el) {\n    return Math.PI * 2 * getAttribute(el, \"r\");\n}\nfunction getRectLength(el) {\n    return getAttribute(el, \"width\") * 2 + getAttribute(el, \"height\") * 2;\n}\nfunction getLineLength(el) {\n    return getDistance({\n        x: getAttribute(el, \"x1\"),\n        y: getAttribute(el, \"y1\")\n    }, {\n        x: getAttribute(el, \"x2\"),\n        y: getAttribute(el, \"y2\")\n    });\n}\nfunction getPolylineLength(el) {\n    var points = el.points;\n    var totalLength = 0;\n    var previousPos;\n    for(var i = 0; i < points.numberOfItems; i++){\n        var currentPos = points.getItem(i);\n        if (i > 0) {\n            totalLength += getDistance(previousPos, currentPos);\n        }\n        previousPos = currentPos;\n    }\n    return totalLength;\n}\nfunction getPolygonLength(el) {\n    var points = el.points;\n    return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));\n}\n// Path animation\nfunction getTotalLength(el) {\n    if (el.getTotalLength) {\n        return el.getTotalLength();\n    }\n    switch(el.tagName.toLowerCase()){\n        case \"circle\":\n            return getCircleLength(el);\n        case \"rect\":\n            return getRectLength(el);\n        case \"line\":\n            return getLineLength(el);\n        case \"polyline\":\n            return getPolylineLength(el);\n        case \"polygon\":\n            return getPolygonLength(el);\n    }\n}\nfunction setDashoffset(el) {\n    var pathLength = getTotalLength(el);\n    el.setAttribute(\"stroke-dasharray\", pathLength);\n    return pathLength;\n}\n// Motion path\nfunction getParentSvgEl(el) {\n    var parentEl = el.parentNode;\n    while(is.svg(parentEl)){\n        if (!is.svg(parentEl.parentNode)) {\n            break;\n        }\n        parentEl = parentEl.parentNode;\n    }\n    return parentEl;\n}\nfunction getParentSvg(pathEl, svgData) {\n    var svg = svgData || {};\n    var parentSvgEl = svg.el || getParentSvgEl(pathEl);\n    var rect = parentSvgEl.getBoundingClientRect();\n    var viewBoxAttr = getAttribute(parentSvgEl, \"viewBox\");\n    var width = rect.width;\n    var height = rect.height;\n    var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(\" \") : [\n        0,\n        0,\n        width,\n        height\n    ]);\n    return {\n        el: parentSvgEl,\n        viewBox: viewBox,\n        x: viewBox[0] / 1,\n        y: viewBox[1] / 1,\n        w: width,\n        h: height,\n        vW: viewBox[2],\n        vH: viewBox[3]\n    };\n}\nfunction getPath(path, percent) {\n    var pathEl = is.str(path) ? selectString(path)[0] : path;\n    var p = percent || 100;\n    return function(property) {\n        return {\n            property: property,\n            el: pathEl,\n            svg: getParentSvg(pathEl),\n            totalLength: getTotalLength(pathEl) * (p / 100)\n        };\n    };\n}\nfunction getPathProgress(path, progress, isPathTargetInsideSVG) {\n    function point(offset) {\n        if (offset === void 0) offset = 0;\n        var l = progress + offset >= 1 ? progress + offset : 0;\n        return path.el.getPointAtLength(l);\n    }\n    var svg = getParentSvg(path.el, path.svg);\n    var p = point();\n    var p0 = point(-1);\n    var p1 = point(+1);\n    var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;\n    var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;\n    switch(path.property){\n        case \"x\":\n            return (p.x - svg.x) * scaleX;\n        case \"y\":\n            return (p.y - svg.y) * scaleY;\n        case \"angle\":\n            return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;\n    }\n}\n// Decompose value\nfunction decomposeValue(val, unit) {\n    // const rgx = /-?\\d*\\.?\\d+/g; // handles basic numbers\n    // const rgx = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var rgx = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + \"\";\n    return {\n        original: value,\n        numbers: value.match(rgx) ? value.match(rgx).map(Number) : [\n            0\n        ],\n        strings: is.str(val) || unit ? value.split(rgx) : []\n    };\n}\n// Animatables\nfunction parseTargets(targets) {\n    var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];\n    return filterArray(targetsArray, function(item, pos, self) {\n        return self.indexOf(item) === pos;\n    });\n}\nfunction getAnimatables(targets) {\n    var parsed = parseTargets(targets);\n    return parsed.map(function(t, i) {\n        return {\n            target: t,\n            id: i,\n            total: parsed.length,\n            transforms: {\n                list: getElementTransforms(t)\n            }\n        };\n    });\n}\n// Properties\nfunction normalizePropertyTweens(prop, tweenSettings) {\n    var settings = cloneObject(tweenSettings);\n    // Override duration if easing is a spring\n    if (/^spring/.test(settings.easing)) {\n        settings.duration = spring(settings.easing);\n    }\n    if (is.arr(prop)) {\n        var l = prop.length;\n        var isFromTo = l === 2 && !is.obj(prop[0]);\n        if (!isFromTo) {\n            // Duration divided by the number of tweens\n            if (!is.fnc(tweenSettings.duration)) {\n                settings.duration = tweenSettings.duration / l;\n            }\n        } else {\n            // Transform [from, to] values shorthand to a valid tween value\n            prop = {\n                value: prop\n            };\n        }\n    }\n    var propArray = is.arr(prop) ? prop : [\n        prop\n    ];\n    return propArray.map(function(v, i) {\n        var obj = is.obj(v) && !is.pth(v) ? v : {\n            value: v\n        };\n        // Default delay value should only be applied to the first tween\n        if (is.und(obj.delay)) {\n            obj.delay = !i ? tweenSettings.delay : 0;\n        }\n        // Default endDelay value should only be applied to the last tween\n        if (is.und(obj.endDelay)) {\n            obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;\n        }\n        return obj;\n    }).map(function(k) {\n        return mergeObjects(k, settings);\n    });\n}\nfunction flattenKeyframes(keyframes) {\n    var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {\n        return Object.keys(key);\n    })), function(p) {\n        return is.key(p);\n    }).reduce(function(a, b) {\n        if (a.indexOf(b) < 0) {\n            a.push(b);\n        }\n        return a;\n    }, []);\n    var properties = {};\n    var loop = function(i) {\n        var propName = propertyNames[i];\n        properties[propName] = keyframes.map(function(key) {\n            var newKey = {};\n            for(var p in key){\n                if (is.key(p)) {\n                    if (p == propName) {\n                        newKey.value = key[p];\n                    }\n                } else {\n                    newKey[p] = key[p];\n                }\n            }\n            return newKey;\n        });\n    };\n    for(var i = 0; i < propertyNames.length; i++)loop(i);\n    return properties;\n}\nfunction getProperties(tweenSettings, params) {\n    var properties = [];\n    var keyframes = params.keyframes;\n    if (keyframes) {\n        params = mergeObjects(flattenKeyframes(keyframes), params);\n    }\n    for(var p in params){\n        if (is.key(p)) {\n            properties.push({\n                name: p,\n                tweens: normalizePropertyTweens(params[p], tweenSettings)\n            });\n        }\n    }\n    return properties;\n}\n// Tweens\nfunction normalizeTweenValues(tween, animatable) {\n    var t = {};\n    for(var p in tween){\n        var value = getFunctionValue(tween[p], animatable);\n        if (is.arr(value)) {\n            value = value.map(function(v) {\n                return getFunctionValue(v, animatable);\n            });\n            if (value.length === 1) {\n                value = value[0];\n            }\n        }\n        t[p] = value;\n    }\n    t.duration = parseFloat(t.duration);\n    t.delay = parseFloat(t.delay);\n    return t;\n}\nfunction normalizeTweens(prop, animatable) {\n    var previousTween;\n    return prop.tweens.map(function(t) {\n        var tween = normalizeTweenValues(t, animatable);\n        var tweenValue = tween.value;\n        var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;\n        var toUnit = getUnit(to);\n        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);\n        var previousValue = previousTween ? previousTween.to.original : originalValue;\n        var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;\n        var fromUnit = getUnit(from) || getUnit(originalValue);\n        var unit = toUnit || fromUnit;\n        if (is.und(to)) {\n            to = previousValue;\n        }\n        tween.from = decomposeValue(from, unit);\n        tween.to = decomposeValue(getRelativeValue(to, from), unit);\n        tween.start = previousTween ? previousTween.end : 0;\n        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;\n        tween.easing = parseEasings(tween.easing, tween.duration);\n        tween.isPath = is.pth(tweenValue);\n        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);\n        tween.isColor = is.col(tween.from.original);\n        if (tween.isColor) {\n            tween.round = 1;\n        }\n        previousTween = tween;\n        return tween;\n    });\n}\n// Tween progress\nvar setProgressValue = {\n    css: function(t, p, v) {\n        return t.style[p] = v;\n    },\n    attribute: function(t, p, v) {\n        return t.setAttribute(p, v);\n    },\n    object: function(t, p, v) {\n        return t[p] = v;\n    },\n    transform: function(t, p, v, transforms, manual) {\n        transforms.list.set(p, v);\n        if (p === transforms.last || manual) {\n            var str = \"\";\n            transforms.list.forEach(function(value, prop) {\n                str += prop + \"(\" + value + \") \";\n            });\n            t.style.transform = str;\n        }\n    }\n};\n// Set Value helper\nfunction setTargetsValue(targets, properties) {\n    var animatables = getAnimatables(targets);\n    animatables.forEach(function(animatable) {\n        for(var property in properties){\n            var value = getFunctionValue(properties[property], animatable);\n            var target = animatable.target;\n            var valueUnit = getUnit(value);\n            var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n            var unit = valueUnit || getUnit(originalValue);\n            var to = getRelativeValue(validateValue(value, unit), originalValue);\n            var animType = getAnimationType(target, property);\n            setProgressValue[animType](target, property, to, animatable.transforms, true);\n        }\n    });\n}\n// Animations\nfunction createAnimation(animatable, prop) {\n    var animType = getAnimationType(animatable.target, prop.name);\n    if (animType) {\n        var tweens = normalizeTweens(prop, animatable);\n        var lastTween = tweens[tweens.length - 1];\n        return {\n            type: animType,\n            property: prop.name,\n            animatable: animatable,\n            tweens: tweens,\n            duration: lastTween.end,\n            delay: tweens[0].delay,\n            endDelay: lastTween.endDelay\n        };\n    }\n}\nfunction getAnimations(animatables, properties) {\n    return filterArray(flattenArray(animatables.map(function(animatable) {\n        return properties.map(function(prop) {\n            return createAnimation(animatable, prop);\n        });\n    })), function(a) {\n        return !is.und(a);\n    });\n}\n// Create Instance\nfunction getInstanceTimings(animations, tweenSettings) {\n    var animLength = animations.length;\n    var getTlOffset = function(anim) {\n        return anim.timelineOffset ? anim.timelineOffset : 0;\n    };\n    var timings = {};\n    timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration;\n    })) : tweenSettings.duration;\n    timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.delay;\n    })) : tweenSettings.delay;\n    timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration - anim.endDelay;\n    })) : tweenSettings.endDelay;\n    return timings;\n}\nvar instanceID = 0;\nfunction createNewInstance(params) {\n    var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n    var tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n    var properties = getProperties(tweenSettings, params);\n    var animatables = getAnimatables(params.targets);\n    var animations = getAnimations(animatables, properties);\n    var timings = getInstanceTimings(animations, tweenSettings);\n    var id = instanceID;\n    instanceID++;\n    return mergeObjects(instanceSettings, {\n        id: id,\n        children: [],\n        animatables: animatables,\n        animations: animations,\n        duration: timings.duration,\n        delay: timings.delay,\n        endDelay: timings.endDelay\n    });\n}\n// Core\nvar activeInstances = [];\nvar engine = function() {\n    var raf;\n    function play() {\n        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {\n            raf = requestAnimationFrame(step);\n        }\n    }\n    function step(t) {\n        // memo on algorithm issue:\n        // dangerous iteration over mutable `activeInstances`\n        // (that collection may be updated from within callbacks of `tick`-ed animation instances)\n        var activeInstancesLength = activeInstances.length;\n        var i = 0;\n        while(i < activeInstancesLength){\n            var activeInstance = activeInstances[i];\n            if (!activeInstance.paused) {\n                activeInstance.tick(t);\n                i++;\n            } else {\n                activeInstances.splice(i, 1);\n                activeInstancesLength--;\n            }\n        }\n        raf = i > 0 ? requestAnimationFrame(step) : undefined;\n    }\n    function handleVisibilityChange() {\n        if (!anime.suspendWhenDocumentHidden) {\n            return;\n        }\n        if (isDocumentHidden()) {\n            // suspend ticks\n            raf = cancelAnimationFrame(raf);\n        } else {\n            // first adjust animations to consider the time that ticks were suspended\n            activeInstances.forEach(function(instance) {\n                return instance._onDocumentVisibility();\n            });\n            engine();\n        }\n    }\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    }\n    return play;\n}();\nfunction isDocumentHidden() {\n    return !!document && document.hidden;\n}\n// Public Instance\nfunction anime(params) {\n    if (params === void 0) params = {};\n    var startTime = 0, lastTime = 0, now = 0;\n    var children, childrenLength = 0;\n    var resolve = null;\n    function makePromise(instance) {\n        var promise = window.Promise && new Promise(function(_resolve) {\n            return resolve = _resolve;\n        });\n        instance.finished = promise;\n        return promise;\n    }\n    var instance = createNewInstance(params);\n    var promise = makePromise(instance);\n    function toggleInstanceDirection() {\n        var direction = instance.direction;\n        if (direction !== \"alternate\") {\n            instance.direction = direction !== \"normal\" ? \"normal\" : \"reverse\";\n        }\n        instance.reversed = !instance.reversed;\n        children.forEach(function(child) {\n            return child.reversed = instance.reversed;\n        });\n    }\n    function adjustTime(time) {\n        return instance.reversed ? instance.duration - time : time;\n    }\n    function resetTime() {\n        startTime = 0;\n        lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);\n    }\n    function seekChild(time, child) {\n        if (child) {\n            child.seek(time - child.timelineOffset);\n        }\n    }\n    function syncInstanceChildren(time) {\n        if (!instance.reversePlayback) {\n            for(var i = 0; i < childrenLength; i++){\n                seekChild(time, children[i]);\n            }\n        } else {\n            for(var i$1 = childrenLength; i$1--;){\n                seekChild(time, children[i$1]);\n            }\n        }\n    }\n    function setAnimationsProgress(insTime) {\n        var i = 0;\n        var animations = instance.animations;\n        var animationsLength = animations.length;\n        while(i < animationsLength){\n            var anim = animations[i];\n            var animatable = anim.animatable;\n            var tweens = anim.tweens;\n            var tweenLength = tweens.length - 1;\n            var tween = tweens[tweenLength];\n            // Only check for keyframes if there is more than one tween\n            if (tweenLength) {\n                tween = filterArray(tweens, function(t) {\n                    return insTime < t.end;\n                })[0] || tween;\n            }\n            var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;\n            var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);\n            var strings = tween.to.strings;\n            var round = tween.round;\n            var numbers = [];\n            var toNumbersLength = tween.to.numbers.length;\n            var progress = void 0;\n            for(var n = 0; n < toNumbersLength; n++){\n                var value = void 0;\n                var toNumber = tween.to.numbers[n];\n                var fromNumber = tween.from.numbers[n] || 0;\n                if (!tween.isPath) {\n                    value = fromNumber + eased * (toNumber - fromNumber);\n                } else {\n                    value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);\n                }\n                if (round) {\n                    if (!(tween.isColor && n > 2)) {\n                        value = Math.round(value * round) / round;\n                    }\n                }\n                numbers.push(value);\n            }\n            // Manual Array.reduce for better performances\n            var stringsLength = strings.length;\n            if (!stringsLength) {\n                progress = numbers[0];\n            } else {\n                progress = strings[0];\n                for(var s = 0; s < stringsLength; s++){\n                    var a = strings[s];\n                    var b = strings[s + 1];\n                    var n$1 = numbers[s];\n                    if (!isNaN(n$1)) {\n                        if (!b) {\n                            progress += n$1 + \" \";\n                        } else {\n                            progress += n$1 + b;\n                        }\n                    }\n                }\n            }\n            setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);\n            anim.currentValue = progress;\n            i++;\n        }\n    }\n    function setCallback(cb) {\n        if (instance[cb] && !instance.passThrough) {\n            instance[cb](instance);\n        }\n    }\n    function countIteration() {\n        if (instance.remaining && instance.remaining !== true) {\n            instance.remaining--;\n        }\n    }\n    function setInstanceProgress(engineTime) {\n        var insDuration = instance.duration;\n        var insDelay = instance.delay;\n        var insEndDelay = insDuration - instance.endDelay;\n        var insTime = adjustTime(engineTime);\n        instance.progress = minMax(insTime / insDuration * 100, 0, 100);\n        instance.reversePlayback = insTime < instance.currentTime;\n        if (children) {\n            syncInstanceChildren(insTime);\n        }\n        if (!instance.began && instance.currentTime > 0) {\n            instance.began = true;\n            setCallback(\"begin\");\n        }\n        if (!instance.loopBegan && instance.currentTime > 0) {\n            instance.loopBegan = true;\n            setCallback(\"loopBegin\");\n        }\n        if (insTime <= insDelay && instance.currentTime !== 0) {\n            setAnimationsProgress(0);\n        }\n        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {\n            setAnimationsProgress(insDuration);\n        }\n        if (insTime > insDelay && insTime < insEndDelay) {\n            if (!instance.changeBegan) {\n                instance.changeBegan = true;\n                instance.changeCompleted = false;\n                setCallback(\"changeBegin\");\n            }\n            setCallback(\"change\");\n            setAnimationsProgress(insTime);\n        } else {\n            if (instance.changeBegan) {\n                instance.changeCompleted = true;\n                instance.changeBegan = false;\n                setCallback(\"changeComplete\");\n            }\n        }\n        instance.currentTime = minMax(insTime, 0, insDuration);\n        if (instance.began) {\n            setCallback(\"update\");\n        }\n        if (engineTime >= insDuration) {\n            lastTime = 0;\n            countIteration();\n            if (!instance.remaining) {\n                instance.paused = true;\n                if (!instance.completed) {\n                    instance.completed = true;\n                    setCallback(\"loopComplete\");\n                    setCallback(\"complete\");\n                    if (!instance.passThrough && \"Promise\" in window) {\n                        resolve();\n                        promise = makePromise(instance);\n                    }\n                }\n            } else {\n                startTime = now;\n                setCallback(\"loopComplete\");\n                instance.loopBegan = false;\n                if (instance.direction === \"alternate\") {\n                    toggleInstanceDirection();\n                }\n            }\n        }\n    }\n    instance.reset = function() {\n        var direction = instance.direction;\n        instance.passThrough = false;\n        instance.currentTime = 0;\n        instance.progress = 0;\n        instance.paused = true;\n        instance.began = false;\n        instance.loopBegan = false;\n        instance.changeBegan = false;\n        instance.completed = false;\n        instance.changeCompleted = false;\n        instance.reversePlayback = false;\n        instance.reversed = direction === \"reverse\";\n        instance.remaining = instance.loop;\n        children = instance.children;\n        childrenLength = children.length;\n        for(var i = childrenLength; i--;){\n            instance.children[i].reset();\n        }\n        if (instance.reversed && instance.loop !== true || direction === \"alternate\" && instance.loop === 1) {\n            instance.remaining++;\n        }\n        setAnimationsProgress(instance.reversed ? instance.duration : 0);\n    };\n    // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)\n    instance._onDocumentVisibility = resetTime;\n    // Set Value helper\n    instance.set = function(targets, properties) {\n        setTargetsValue(targets, properties);\n        return instance;\n    };\n    instance.tick = function(t) {\n        now = t;\n        if (!startTime) {\n            startTime = now;\n        }\n        setInstanceProgress((now + (lastTime - startTime)) * anime.speed);\n    };\n    instance.seek = function(time) {\n        setInstanceProgress(adjustTime(time));\n    };\n    instance.pause = function() {\n        instance.paused = true;\n        resetTime();\n    };\n    instance.play = function() {\n        if (!instance.paused) {\n            return;\n        }\n        if (instance.completed) {\n            instance.reset();\n        }\n        instance.paused = false;\n        activeInstances.push(instance);\n        resetTime();\n        engine();\n    };\n    instance.reverse = function() {\n        toggleInstanceDirection();\n        instance.completed = instance.reversed ? false : true;\n        resetTime();\n    };\n    instance.restart = function() {\n        instance.reset();\n        instance.play();\n    };\n    instance.remove = function(targets) {\n        var targetsArray = parseTargets(targets);\n        removeTargetsFromInstance(targetsArray, instance);\n    };\n    instance.reset();\n    if (instance.autoplay) {\n        instance.play();\n    }\n    return instance;\n}\n// Remove targets from animation\nfunction removeTargetsFromAnimations(targetsArray, animations) {\n    for(var a = animations.length; a--;){\n        if (arrayContains(targetsArray, animations[a].animatable.target)) {\n            animations.splice(a, 1);\n        }\n    }\n}\nfunction removeTargetsFromInstance(targetsArray, instance) {\n    var animations = instance.animations;\n    var children = instance.children;\n    removeTargetsFromAnimations(targetsArray, animations);\n    for(var c = children.length; c--;){\n        var child = children[c];\n        var childAnimations = child.animations;\n        removeTargetsFromAnimations(targetsArray, childAnimations);\n        if (!childAnimations.length && !child.children.length) {\n            children.splice(c, 1);\n        }\n    }\n    if (!animations.length && !children.length) {\n        instance.pause();\n    }\n}\nfunction removeTargetsFromActiveInstances(targets) {\n    var targetsArray = parseTargets(targets);\n    for(var i = activeInstances.length; i--;){\n        var instance = activeInstances[i];\n        removeTargetsFromInstance(targetsArray, instance);\n    }\n}\n// Stagger helpers\nfunction stagger(val, params) {\n    if (params === void 0) params = {};\n    var direction = params.direction || \"normal\";\n    var easing = params.easing ? parseEasings(params.easing) : null;\n    var grid = params.grid;\n    var axis = params.axis;\n    var fromIndex = params.from || 0;\n    var fromFirst = fromIndex === \"first\";\n    var fromCenter = fromIndex === \"center\";\n    var fromLast = fromIndex === \"last\";\n    var isRange = is.arr(val);\n    var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);\n    var val2 = isRange ? parseFloat(val[1]) : 0;\n    var unit = getUnit(isRange ? val[1] : val) || 0;\n    var start = params.start || 0 + (isRange ? val1 : 0);\n    var values = [];\n    var maxValue = 0;\n    return function(el, i, t) {\n        if (fromFirst) {\n            fromIndex = 0;\n        }\n        if (fromCenter) {\n            fromIndex = (t - 1) / 2;\n        }\n        if (fromLast) {\n            fromIndex = t - 1;\n        }\n        if (!values.length) {\n            for(var index = 0; index < t; index++){\n                if (!grid) {\n                    values.push(Math.abs(fromIndex - index));\n                } else {\n                    var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n                    var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n                    var toX = index % grid[0];\n                    var toY = Math.floor(index / grid[0]);\n                    var distanceX = fromX - toX;\n                    var distanceY = fromY - toY;\n                    var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n                    if (axis === \"x\") {\n                        value = -distanceX;\n                    }\n                    if (axis === \"y\") {\n                        value = -distanceY;\n                    }\n                    values.push(value);\n                }\n                maxValue = Math.max.apply(Math, values);\n            }\n            if (easing) {\n                values = values.map(function(val) {\n                    return easing(val / maxValue) * maxValue;\n                });\n            }\n            if (direction === \"reverse\") {\n                values = values.map(function(val) {\n                    return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);\n                });\n            }\n        }\n        var spacing = isRange ? (val2 - val1) / maxValue : val1;\n        return start + spacing * (Math.round(values[i] * 100) / 100) + unit;\n    };\n}\n// Timeline\nfunction timeline(params) {\n    if (params === void 0) params = {};\n    var tl = anime(params);\n    tl.duration = 0;\n    tl.add = function(instanceParams, timelineOffset) {\n        var tlIndex = activeInstances.indexOf(tl);\n        var children = tl.children;\n        if (tlIndex > -1) {\n            activeInstances.splice(tlIndex, 1);\n        }\n        function passThrough(ins) {\n            ins.passThrough = true;\n        }\n        for(var i = 0; i < children.length; i++){\n            passThrough(children[i]);\n        }\n        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));\n        insParams.targets = insParams.targets || params.targets;\n        var tlDuration = tl.duration;\n        insParams.autoplay = false;\n        insParams.direction = tl.direction;\n        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);\n        passThrough(tl);\n        tl.seek(insParams.timelineOffset);\n        var ins = anime(insParams);\n        passThrough(ins);\n        children.push(ins);\n        var timings = getInstanceTimings(children, params);\n        tl.delay = timings.delay;\n        tl.endDelay = timings.endDelay;\n        tl.duration = timings.duration;\n        tl.seek(0);\n        tl.reset();\n        if (tl.autoplay) {\n            tl.play();\n        }\n        return tl;\n    };\n    return tl;\n}\nanime.version = \"3.2.1\";\nanime.speed = 1;\n// TODO:#review: naming, documentation\nanime.suspendWhenDocumentHidden = true;\nanime.running = activeInstances;\nanime.remove = removeTargetsFromActiveInstances;\nanime.get = getOriginalTargetValue;\nanime.set = setTargetsValue;\nanime.convertPx = convertPxToUnit;\nanime.path = getPath;\nanime.setDashoffset = setDashoffset;\nanime.stagger = stagger;\nanime.timeline = timeline;\nanime.easing = parseEasings;\nanime.penner = penner;\nanime.random = function(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (anime);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsV0FBVztBQUVYLElBQUlBLDBCQUEwQjtJQUM1QkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLGdCQUFnQjtBQUNsQjtBQUVBLElBQUlDLHVCQUF1QjtJQUN6QkMsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFFQSxJQUFJQyxrQkFBa0I7SUFBQztJQUFjO0lBQWM7SUFBYztJQUFVO0lBQVc7SUFBVztJQUFXO0lBQVM7SUFBVTtJQUFVO0lBQVU7SUFBUTtJQUFTO0lBQVM7SUFBZTtJQUFVO0NBQVc7QUFFak4sVUFBVTtBQUVWLElBQUlDLFFBQVE7SUFDVkMsS0FBSyxDQUFDO0lBQ05DLFNBQVMsQ0FBQztBQUNaO0FBRUEsUUFBUTtBQUVSLFNBQVNDLE9BQU9DLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtGLEdBQUcsQ0FBQ0UsS0FBS0QsR0FBRyxDQUFDRixLQUFLQyxNQUFNQztBQUN0QztBQUVBLFNBQVNFLGVBQWVDLEdBQUcsRUFBRUMsSUFBSTtJQUMvQixPQUFPRCxJQUFJRSxPQUFPLENBQUNELFFBQVEsQ0FBQztBQUM5QjtBQUVBLFNBQVNFLGVBQWVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxPQUFPRCxLQUFLRSxLQUFLLENBQUMsTUFBTUQ7QUFDMUI7QUFFQSxJQUFJRSxLQUFLO0lBQ1BDLEtBQUssU0FBVUMsQ0FBQztRQUFJLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0Y7SUFBSTtJQUM3Q0csS0FBSyxTQUFVSCxDQUFDO1FBQUksT0FBT1YsZUFBZWMs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bUJBQW1CUyxVQUFVcFM7UUFDM0M4WSxHQUFHdmMsS0FBSyxHQUFHeVYsUUFBUXpWLEtBQUs7UUFDeEJ1YyxHQUFHdGMsUUFBUSxHQUFHd1YsUUFBUXhWLFFBQVE7UUFDOUJzYyxHQUFHeGMsUUFBUSxHQUFHMFYsUUFBUTFWLFFBQVE7UUFDOUJ3YyxHQUFHaEUsSUFBSSxDQUFDO1FBQ1JnRSxHQUFHaEMsS0FBSztRQUNSLElBQUlnQyxHQUFHM2MsUUFBUSxFQUFFO1lBQUUyYyxHQUFHdEcsSUFBSTtRQUFJO1FBQzlCLE9BQU9zRztJQUNUO0lBQ0EsT0FBT0E7QUFDVDtBQUVBcEcsTUFBTTJHLE9BQU8sR0FBRztBQUNoQjNHLE1BQU1rQyxLQUFLLEdBQUc7QUFDZCxzQ0FBc0M7QUFDdENsQyxNQUFNQyx5QkFBeUIsR0FBRztBQUNsQ0QsTUFBTTRHLE9BQU8sR0FBR2pIO0FBQ2hCSyxNQUFNd0UsTUFBTSxHQUFHSztBQUNmN0UsTUFBTTdILEdBQUcsR0FBR0U7QUFDWjJILE1BQU1oSSxHQUFHLEdBQUcwRztBQUNac0IsTUFBTTZHLFNBQVMsR0FBRzNRO0FBQ2xCOEosTUFBTWhGLElBQUksR0FBR0Q7QUFDYmlGLE1BQU1qRyxhQUFhLEdBQUdBO0FBQ3RCaUcsTUFBTThFLE9BQU8sR0FBR0E7QUFDaEI5RSxNQUFNbUcsUUFBUSxHQUFHQTtBQUNqQm5HLE1BQU1qVyxNQUFNLEdBQUd1STtBQUNmME4sTUFBTS9PLE1BQU0sR0FBR0E7QUFDZitPLE1BQU04RyxNQUFNLEdBQUcsU0FBVXZjLEdBQUcsRUFBRUMsR0FBRztJQUFJLE9BQU9DLEtBQUtvYixLQUFLLENBQUNwYixLQUFLcWMsTUFBTSxLQUFNdGMsQ0FBQUEsTUFBTUQsTUFBTSxNQUFNQTtBQUFLO0FBRS9GLGlFQUFleVYsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlY2hub3JhbWFfMjA1MC8uL25vZGVfbW9kdWxlcy9hbmltZWpzL2xpYi9hbmltZS5lcy5qcz85MzczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBhbmltZS5qcyB2My4yLjJcbiAqIChjKSAyMDIzIEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuLy8gRGVmYXVsdHNcblxudmFyIGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzID0ge1xuICB1cGRhdGU6IG51bGwsXG4gIGJlZ2luOiBudWxsLFxuICBsb29wQmVnaW46IG51bGwsXG4gIGNoYW5nZUJlZ2luOiBudWxsLFxuICBjaGFuZ2U6IG51bGwsXG4gIGNoYW5nZUNvbXBsZXRlOiBudWxsLFxuICBsb29wQ29tcGxldGU6IG51bGwsXG4gIGNvbXBsZXRlOiBudWxsLFxuICBsb29wOiAxLFxuICBkaXJlY3Rpb246ICdub3JtYWwnLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgdGltZWxpbmVPZmZzZXQ6IDBcbn07XG5cbnZhciBkZWZhdWx0VHdlZW5TZXR0aW5ncyA9IHtcbiAgZHVyYXRpb246IDEwMDAsXG4gIGRlbGF5OiAwLFxuICBlbmREZWxheTogMCxcbiAgZWFzaW5nOiAnZWFzZU91dEVsYXN0aWMoMSwgLjUpJyxcbiAgcm91bmQ6IDBcbn07XG5cbnZhciB2YWxpZFRyYW5zZm9ybXMgPSBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJywgJ3JvdGF0ZScsICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWicsICdzY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NjYWxlWicsICdza2V3JywgJ3NrZXdYJywgJ3NrZXdZJywgJ3BlcnNwZWN0aXZlJywgJ21hdHJpeCcsICdtYXRyaXgzZCddO1xuXG4vLyBDYWNoaW5nXG5cbnZhciBjYWNoZSA9IHtcbiAgQ1NTOiB7fSxcbiAgc3ByaW5nczoge31cbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIG1pbk1heCh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NvbnRhaW5zKHN0ciwgdGV4dCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YodGV4dCkgPiAtMTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBcmd1bWVudHMoZnVuYywgYXJncykge1xuICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbn1cblxudmFyIGlzID0ge1xuICBhcnI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGEpOyB9LFxuICBvYmo6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBzdHJpbmdDb250YWlucyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSksICdPYmplY3QnKTsgfSxcbiAgcHRoOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXMub2JqKGEpICYmIGEuaGFzT3duUHJvcGVydHkoJ3RvdGFsTGVuZ3RoJyk7IH0sXG4gIHN2ZzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBTVkdFbGVtZW50OyB9LFxuICBpbnA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudDsgfSxcbiAgZG9tOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5ub2RlVHlwZSB8fCBpcy5zdmcoYSk7IH0sXG4gIHN0cjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJzsgfSxcbiAgZm5jOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7IH0sXG4gIHVuZDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAndW5kZWZpbmVkJzsgfSxcbiAgbmlsOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXMudW5kKGEpIHx8IGEgPT09IG51bGw7IH0sXG4gIGhleDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGEpOyB9LFxuICByZ2I6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXnJnYi8udGVzdChhKTsgfSxcbiAgaHNsOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15oc2wvLnRlc3QoYSk7IH0sXG4gIGNvbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChpcy5oZXgoYSkgfHwgaXMucmdiKGEpIHx8IGlzLmhzbChhKSk7IH0sXG4gIGtleTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiAhZGVmYXVsdFR3ZWVuU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgYSAhPT0gJ3RhcmdldHMnICYmIGEgIT09ICdrZXlmcmFtZXMnOyB9LFxufTtcblxuLy8gRWFzaW5nc1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IC9cXCgoW14pXSspXFwpLy5leGVjKHN0cmluZyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXJzZUZsb2F0KHApOyB9KSA6IFtdO1xufVxuXG4vLyBTcHJpbmcgc29sdmVyIGluc3BpcmVkIGJ5IFdlYmtpdCBDb3B5cmlnaHQgwqkgMjAxNiBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG5cbmZ1bmN0aW9uIHNwcmluZyhzdHJpbmcsIGR1cmF0aW9uKSB7XG5cbiAgdmFyIHBhcmFtcyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpO1xuICB2YXIgbWFzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzBdKSA/IDEgOiBwYXJhbXNbMF0sIC4xLCAxMDApO1xuICB2YXIgc3RpZmZuZXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMV0pID8gMTAwIDogcGFyYW1zWzFdLCAuMSwgMTAwKTtcbiAgdmFyIGRhbXBpbmcgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1syXSkgPyAxMCA6IHBhcmFtc1syXSwgLjEsIDEwMCk7XG4gIHZhciB2ZWxvY2l0eSA9ICBtaW5NYXgoaXMudW5kKHBhcmFtc1szXSkgPyAwIDogcGFyYW1zWzNdLCAuMSwgMTAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcblxuICBmdW5jdGlvbiBzb2x2ZXIodCkge1xuICAgIHZhciBwcm9ncmVzcyA9IGR1cmF0aW9uID8gKGR1cmF0aW9uICogdCkgLyAxMDAwIDogdDtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5leHAoLXByb2dyZXNzICogemV0YSAqIHcwKSAqIChhICogTWF0aC5jb3Mod2QgKiBwcm9ncmVzcykgKyBiICogTWF0aC5zaW4od2QgKiBwcm9ncmVzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmVzcyA9IChhICsgYiAqIHByb2dyZXNzKSAqIE1hdGguZXhwKC1wcm9ncmVzcyAqIHcwKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgeyByZXR1cm4gdDsgfVxuICAgIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuc3ByaW5nc1tzdHJpbmddO1xuICAgIGlmIChjYWNoZWQpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICAgIHZhciBmcmFtZSA9IDEvNjtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgdmFyIHJlc3QgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGVsYXBzZWQgKz0gZnJhbWU7XG4gICAgICBpZiAoc29sdmVyKGVsYXBzZWQpID09PSAxKSB7XG4gICAgICAgIHJlc3QrKztcbiAgICAgICAgaWYgKHJlc3QgPj0gMTYpIHsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuICAgIGNhY2hlLnNwcmluZ3Nbc3RyaW5nXSA9IGR1cmF0aW9uO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbiA/IHNvbHZlciA6IGdldER1cmF0aW9uO1xuXG59XG5cbi8vIEJhc2ljIHN0ZXBzIGVhc2luZyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblxuZnVuY3Rpb24gc3RlcHMoc3RlcHMpIHtcbiAgaWYgKCBzdGVwcyA9PT0gdm9pZCAwICkgc3RlcHMgPSAxMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGguY2VpbCgobWluTWF4KHQsIDAuMDAwMDAxLCAxKSkgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTsgfTtcbn1cblxuLy8gQmV6aWVyRWFzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZ1xuXG52YXIgYmV6aWVyID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuXG4gIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHsgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMSB9XG4gIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMSB9XG4gIGZ1bmN0aW9uIEMoYUExKSAgICAgIHsgcmV0dXJuIDMuMCAqIGFBMSB9XG5cbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHsgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUIH1cbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpIH1cblxuICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkgeyBhQiA9IGN1cnJlbnRUOyB9IGVsc2UgeyBhQSA9IGN1cnJlbnRUOyB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gMC4wMDAwMDAxICYmICsraSA8IDEwKTtcbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cblxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgeyByZXR1cm4gYUd1ZXNzVDsgfVxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG5cbiAgZnVuY3Rpb24gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuXG4gICAgaWYgKCEoMCA8PSBtWDEgJiYgbVgxIDw9IDEgJiYgMCA8PSBtWDIgJiYgbVgyIDw9IDEpKSB7IHJldHVybjsgfVxuICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXG4gICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuXG4gICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDA7XG4gICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLS1jdXJyZW50U2FtcGxlO1xuXG4gICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gMC4wMDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7IHJldHVybiB4OyB9XG4gICAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKSB7IHJldHVybiB4OyB9XG4gICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIGJlemllcjtcblxufSkoKTtcblxudmFyIHBlbm5lciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQmFzZWQgb24galF1ZXJ5IFVJJ3MgaW1wbGVtZW5hdGlvbiBvZiBlYXNpbmcgZXF1YXRpb25zIGZyb20gUm9iZXJ0IFBlbm5lciAoaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZylcblxuICB2YXIgZWFzZXMgPSB7IGxpbmVhcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07IH0gfTtcblxuICB2YXIgZnVuY3Rpb25FYXNpbmdzID0ge1xuICAgIFNpbmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTsgfTsgfSxcbiAgICBFeHBvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDA7IH07IH0sXG4gICAgQ2lyYzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTsgfTsgfSxcbiAgICBCYWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiAoMyAqIHQgLSAyKTsgfTsgfSxcbiAgICBCb3VuY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgcG93MiwgYiA9IDQ7XG4gICAgICB3aGlsZSAodCA8ICgoIHBvdzIgPSBNYXRoLnBvdygyLCAtLWIpKSAtIDEpIC8gMTEpIHt9XG4gICAgICByZXR1cm4gMSAvIE1hdGgucG93KDQsIDMgLSBiKSAtIDcuNTYyNSAqIE1hdGgucG93KCggcG93MiAqIDMgLSAyICkgLyAyMiAtIHQsIDIpXG4gICAgfTsgfSxcbiAgICBFbGFzdGljOiBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICAgIGlmICggYW1wbGl0dWRlID09PSB2b2lkIDAgKSBhbXBsaXR1ZGUgPSAxO1xuICAgICAgaWYgKCBwZXJpb2QgPT09IHZvaWQgMCApIHBlcmlvZCA9IC41O1xuXG4gICAgICB2YXIgYSA9IG1pbk1heChhbXBsaXR1ZGUsIDEsIDEwKTtcbiAgICAgIHZhciBwID0gbWluTWF4KHBlcmlvZCwgLjEsIDIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAodCA9PT0gMCB8fCB0ID09PSAxKSA/IHQgOiBcbiAgICAgICAgICAtYSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLnNpbigoKCh0IC0gMSkgLSAocCAvIChNYXRoLlBJICogMikgKiBNYXRoLmFzaW4oMSAvIGEpKSkgKiAoTWF0aC5QSSAqIDIpKSAvIHApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYmFzZUVhc2luZ3MgPSBbJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnXTtcblxuICBiYXNlRWFzaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgZnVuY3Rpb25FYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucG93KHQsIGkgKyAyKTsgfTsgfTtcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZnVuY3Rpb25FYXNpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGVhc2VJbiA9IGZ1bmN0aW9uRWFzaW5nc1tuYW1lXTtcbiAgICBlYXNlc1snZWFzZUluJyArIG5hbWVdID0gZWFzZUluO1xuICAgIGVhc2VzWydlYXNlT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gZWFzZUluKGEsIGIpKDEgLSB0KTsgfTsgfTtcbiAgICBlYXNlc1snZWFzZUluT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgMC41ID8gZWFzZUluKGEsIGIpKHQgKiAyKSAvIDIgOiBcbiAgICAgIDEgLSBlYXNlSW4oYSwgYikodCAqIC0yICsgMikgLyAyOyB9OyB9O1xuICAgIGVhc2VzWydlYXNlT3V0SW4nICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAwLjUgPyAoMSAtIGVhc2VJbihhLCBiKSgxIC0gdCAqIDIpKSAvIDIgOiBcbiAgICAgIChlYXNlSW4oYSwgYikodCAqIDIgLSAxKSArIDEpIC8gMjsgfTsgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2VzO1xuXG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ3MoZWFzaW5nLCBkdXJhdGlvbikge1xuICBpZiAoaXMuZm5jKGVhc2luZykpIHsgcmV0dXJuIGVhc2luZzsgfVxuICB2YXIgbmFtZSA9IGVhc2luZy5zcGxpdCgnKCcpWzBdO1xuICB2YXIgZWFzZSA9IHBlbm5lcltuYW1lXTtcbiAgdmFyIGFyZ3MgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3ByaW5nJyA6IHJldHVybiBzcHJpbmcoZWFzaW5nLCBkdXJhdGlvbik7XG4gICAgY2FzZSAnY3ViaWNCZXppZXInIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGJlemllciwgYXJncyk7XG4gICAgY2FzZSAnc3RlcHMnIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKHN0ZXBzLCBhcmdzKTtcbiAgICBkZWZhdWx0IDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGVhc2UsIGFyZ3MpO1xuICB9XG59XG5cbi8vIFN0cmluZ3NcblxuZnVuY3Rpb24gc2VsZWN0U3RyaW5nKHN0cikge1xuICB0cnkge1xuICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc3RyKTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vLyBBcnJheXNcblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpIGluIGFycikge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbCwgaSwgYXJyKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChpcy5hcnIoYikgPyBmbGF0dGVuQXJyYXkoYikgOiBiKTsgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG8pIHtcbiAgaWYgKGlzLmFycihvKSkgeyByZXR1cm4gbzsgfVxuICBpZiAoaXMuc3RyKG8pKSB7IG8gPSBzZWxlY3RTdHJpbmcobykgfHwgbzsgfVxuICBpZiAobyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IG8gaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbikgeyByZXR1cm4gW10uc2xpY2UuY2FsbChvKTsgfVxuICByZXR1cm4gW29dO1xufVxuXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSA9PT0gdmFsOyB9KTtcbn1cblxuLy8gT2JqZWN0c1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChvKSB7XG4gIHZhciBjbG9uZSA9IHt9O1xuICBmb3IgKHZhciBwIGluIG8pIHsgY2xvbmVbcF0gPSBvW3BdOyB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU9iamVjdFByb3BzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMSkgeyBvW3BdID0gbzIuaGFzT3duUHJvcGVydHkocCkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8yKSB7IG9bcF0gPSBpcy51bmQobzFbcF0pID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuLy8gQ29sb3JzXG5cbmZ1bmN0aW9uIHJnYlRvUmdiYShyZ2JWYWx1ZSkge1xuICB2YXIgcmdiID0gL3JnYlxcKChcXGQrLFxccypbXFxkXSssXFxzKltcXGRdKylcXCkvZy5leGVjKHJnYlZhbHVlKTtcbiAgcmV0dXJuIHJnYiA/IChcInJnYmEoXCIgKyAocmdiWzFdKSArIFwiLDEpXCIpIDogcmdiVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGhleFRvUmdiYShoZXhWYWx1ZSkge1xuICB2YXIgcmd4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgdmFyIGhleCA9IGhleFZhbHVlLnJlcGxhY2Uocmd4LCBmdW5jdGlvbiAobSwgciwgZywgYikgeyByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiOyB9ICk7XG4gIHZhciByZ2IgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgdmFyIHIgPSBwYXJzZUludChyZ2JbMV0sIDE2KTtcbiAgdmFyIGcgPSBwYXJzZUludChyZ2JbMl0sIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChyZ2JbM10sIDE2KTtcbiAgcmV0dXJuIChcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsMSlcIik7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiYShoc2xWYWx1ZSkge1xuICB2YXIgaHNsID0gL2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLmV4ZWMoaHNsVmFsdWUpIHx8IC9oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKylcXCkvZy5leGVjKGhzbFZhbHVlKTtcbiAgdmFyIGggPSBwYXJzZUludChoc2xbMV0sIDEwKSAvIDM2MDtcbiAgdmFyIHMgPSBwYXJzZUludChoc2xbMl0sIDEwKSAvIDEwMDtcbiAgdmFyIGwgPSBwYXJzZUludChoc2xbM10sIDEwKSAvIDEwMDtcbiAgdmFyIGEgPSBoc2xbNF0gfHwgMTtcbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7IHQgKz0gMTsgfVxuICAgIGlmICh0ID4gMSkgeyB0IC09IDE7IH1cbiAgICBpZiAodCA8IDEvNikgeyByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDsgfVxuICAgIGlmICh0IDwgMS8yKSB7IHJldHVybiBxOyB9XG4gICAgaWYgKHQgPCAyLzMpIHsgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjsgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIHZhciByLCBnLCBiO1xuICBpZiAocyA9PSAwKSB7XG4gICAgciA9IGcgPSBiID0gbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gIH1cbiAgcmV0dXJuIChcInJnYmEoXCIgKyAociAqIDI1NSkgKyBcIixcIiArIChnICogMjU1KSArIFwiLFwiICsgKGIgKiAyNTUpICsgXCIsXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvUmdiKHZhbCkge1xuICBpZiAoaXMucmdiKHZhbCkpIHsgcmV0dXJuIHJnYlRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oZXgodmFsKSkgeyByZXR1cm4gaGV4VG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhzbCh2YWwpKSB7IHJldHVybiBoc2xUb1JnYmEodmFsKTsgfVxufVxuXG4vLyBVbml0c1xuXG5mdW5jdGlvbiBnZXRVbml0KHZhbCkge1xuICB2YXIgc3BsaXQgPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8oJXxweHxwdHxlbXxyZW18aW58Y218bW18ZXh8Y2h8cGN8dnd8dmh8dm1pbnx2bWF4fGRlZ3xyYWR8dHVybik/JC8uZXhlYyh2YWwpO1xuICBpZiAoc3BsaXQpIHsgcmV0dXJuIHNwbGl0WzFdOyB9XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpIHtcbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAndHJhbnNsYXRlJykgfHwgcHJvcE5hbWUgPT09ICdwZXJzcGVjdGl2ZScpIHsgcmV0dXJuICdweCc7IH1cbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdza2V3JykpIHsgcmV0dXJuICdkZWcnOyB9XG59XG5cbi8vIFZhbHVlc1xuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblZhbHVlKHZhbCwgYW5pbWF0YWJsZSkge1xuICBpZiAoIWlzLmZuYyh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgcmV0dXJuIHZhbChhbmltYXRhYmxlLnRhcmdldCwgYW5pbWF0YWJsZS5pZCwgYW5pbWF0YWJsZS50b3RhbCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgcHJvcCkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKHByb3ApO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSB7XG4gIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgaWYgKGFycmF5Q29udGFpbnMoW3VuaXQsICdkZWcnLCAncmFkJywgJ3R1cm4nXSwgdmFsdWVVbml0KSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgdmFyIGNhY2hlZCA9IGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdO1xuICBpZiAoIWlzLnVuZChjYWNoZWQpKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgdmFyIGJhc2VsaW5lID0gMTAwO1xuICB2YXIgdGVtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcbiAgdmFyIHBhcmVudEVsID0gKGVsLnBhcmVudE5vZGUgJiYgKGVsLnBhcmVudE5vZGUgIT09IGRvY3VtZW50KSkgPyBlbC5wYXJlbnROb2RlIDogZG9jdW1lbnQuYm9keTtcbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgdGVtcEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGVtcEVsLnN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyB1bml0O1xuICB2YXIgZmFjdG9yID0gYmFzZWxpbmUgLyB0ZW1wRWwub2Zmc2V0V2lkdGg7XG4gIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gIHZhciBjb252ZXJ0ZWRVbml0ID0gZmFjdG9yICogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdID0gY29udmVydGVkVW5pdDtcbiAgcmV0dXJuIGNvbnZlcnRlZFVuaXQ7XG59XG5cbmZ1bmN0aW9uIGdldENTU1ZhbHVlKGVsLCBwcm9wLCB1bml0KSB7XG4gIGlmIChwcm9wIGluIGVsLnN0eWxlKSB7XG4gICAgdmFyIHVwcGVyY2FzZVByb3BOYW1lID0gcHJvcC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IGVsLnN0eWxlW3Byb3BdIHx8IGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodXBwZXJjYXNlUHJvcE5hbWUpIHx8ICcwJztcbiAgICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uVHlwZShlbCwgcHJvcCkge1xuICBpZiAoaXMuZG9tKGVsKSAmJiAhaXMuaW5wKGVsKSAmJiAoIWlzLm5pbChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApKSB8fCAoaXMuc3ZnKGVsKSAmJiBlbFtwcm9wXSkpKSB7IHJldHVybiAnYXR0cmlidXRlJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiBhcnJheUNvbnRhaW5zKHZhbGlkVHJhbnNmb3JtcywgcHJvcCkpIHsgcmV0dXJuICd0cmFuc2Zvcm0nOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIChwcm9wICE9PSAndHJhbnNmb3JtJyAmJiBnZXRDU1NWYWx1ZShlbCwgcHJvcCkpKSB7IHJldHVybiAnY3NzJzsgfVxuICBpZiAoZWxbcHJvcF0gIT0gbnVsbCkgeyByZXR1cm4gJ29iamVjdCc7IH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpIHtcbiAgaWYgKCFpcy5kb20oZWwpKSB7IHJldHVybjsgfVxuICB2YXIgc3RyID0gZWwuc3R5bGUudHJhbnNmb3JtIHx8ICcnO1xuICB2YXIgcmVnICA9IC8oXFx3KylcXCgoW14pXSopXFwpL2c7XG4gIHZhciB0cmFuc2Zvcm1zID0gbmV3IE1hcCgpO1xuICB2YXIgbTsgd2hpbGUgKG0gPSByZWcuZXhlYyhzdHIpKSB7IHRyYW5zZm9ybXMuc2V0KG1bMV0sIG1bMl0pOyB9XG4gIHJldHVybiB0cmFuc2Zvcm1zO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1WYWx1ZShlbCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpIHtcbiAgdmFyIGRlZmF1bHRWYWwgPSBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NjYWxlJykgPyAxIDogMCArIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpO1xuICB2YXIgdmFsdWUgPSBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkuZ2V0KHByb3BOYW1lKSB8fCBkZWZhdWx0VmFsO1xuICBpZiAoYW5pbWF0YWJsZSkge1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtcy5saXN0LnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtc1snbGFzdCddID0gcHJvcE5hbWU7XG4gIH1cbiAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQsIGFuaW1hdGFibGUpIHtcbiAgc3dpdGNoIChnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcE5hbWUpKSB7XG4gICAgY2FzZSAndHJhbnNmb3JtJzogcmV0dXJuIGdldFRyYW5zZm9ybVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpO1xuICAgIGNhc2UgJ2Nzcyc6IHJldHVybiBnZXRDU1NWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0KTtcbiAgICBjYXNlICdhdHRyaWJ1dGUnOiByZXR1cm4gZ2V0QXR0cmlidXRlKHRhcmdldCwgcHJvcE5hbWUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiB0YXJnZXRbcHJvcE5hbWVdIHx8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSkge1xuICB2YXIgb3BlcmF0b3IgPSAvXihcXCo9fFxcKz18LT0pLy5leGVjKHRvKTtcbiAgaWYgKCFvcGVyYXRvcikgeyByZXR1cm4gdG87IH1cbiAgdmFyIHUgPSBnZXRVbml0KHRvKSB8fCAwO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoZnJvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdCh0by5yZXBsYWNlKG9wZXJhdG9yWzBdLCAnJykpO1xuICBzd2l0Y2ggKG9wZXJhdG9yWzBdWzBdKSB7XG4gICAgY2FzZSAnKyc6IHJldHVybiB4ICsgeSArIHU7XG4gICAgY2FzZSAnLSc6IHJldHVybiB4IC0geSArIHU7XG4gICAgY2FzZSAnKic6IHJldHVybiB4ICogeSArIHU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgaWYgKGlzLmNvbCh2YWwpKSB7IHJldHVybiBjb2xvclRvUmdiKHZhbCk7IH1cbiAgaWYgKC9cXHMvZy50ZXN0KHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgaWYgKHVuaXQpIHsgcmV0dXJuIHVuaXRMZXNzICsgdW5pdDsgfVxuICByZXR1cm4gdW5pdExlc3M7XG59XG5cbi8vIGdldFRvdGFsTGVuZ3RoKCkgZXF1aXZhbGVudCBmb3IgY2lyY2xlLCByZWN0LCBwb2x5bGluZSwgcG9seWdvbiBhbmQgbGluZSBzaGFwZXNcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9TZWJMYW1ibGEvM2UwNTUwYzQ5NmMyMzY3MDk3NDRcblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2lyY2xlTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBNYXRoLlBJICogMiAqIGdldEF0dHJpYnV0ZShlbCwgJ3InKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdExlbmd0aChlbCkge1xuICByZXR1cm4gKGdldEF0dHJpYnV0ZShlbCwgJ3dpZHRoJykgKiAyKSArIChnZXRBdHRyaWJ1dGUoZWwsICdoZWlnaHQnKSAqIDIpO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDEnKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTEnKX0sIFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MicpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MicpfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICB2YXIgcHJldmlvdXNQb3M7XG4gIGZvciAodmFyIGkgPSAwIDsgaSA8IHBvaW50cy5udW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFBvcyA9IHBvaW50cy5nZXRJdGVtKGkpO1xuICAgIGlmIChpID4gMCkgeyB0b3RhbExlbmd0aCArPSBnZXREaXN0YW5jZShwcmV2aW91c1BvcywgY3VycmVudFBvcyk7IH1cbiAgICBwcmV2aW91c1BvcyA9IGN1cnJlbnRQb3M7XG4gIH1cbiAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5Z29uTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCkgKyBnZXREaXN0YW5jZShwb2ludHMuZ2V0SXRlbShwb2ludHMubnVtYmVyT2ZJdGVtcyAtIDEpLCBwb2ludHMuZ2V0SXRlbSgwKSk7XG59XG5cbi8vIFBhdGggYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIGdldFRvdGFsTGVuZ3RoKGVsKSB7XG4gIGlmIChlbC5nZXRUb3RhbExlbmd0aCkgeyByZXR1cm4gZWwuZ2V0VG90YWxMZW5ndGgoKTsgfVxuICBzd2l0Y2goZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnY2lyY2xlJzogcmV0dXJuIGdldENpcmNsZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncmVjdCc6IHJldHVybiBnZXRSZWN0TGVuZ3RoKGVsKTtcbiAgICBjYXNlICdsaW5lJzogcmV0dXJuIGdldExpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlsaW5lJzogcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5Z29uJzogcmV0dXJuIGdldFBvbHlnb25MZW5ndGgoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldERhc2hvZmZzZXQoZWwpIHtcbiAgdmFyIHBhdGhMZW5ndGggPSBnZXRUb3RhbExlbmd0aChlbCk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHBhdGhMZW5ndGgpO1xuICByZXR1cm4gcGF0aExlbmd0aDtcbn1cblxuLy8gTW90aW9uIHBhdGhcblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnRWwoZWwpIHtcbiAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKGlzLnN2ZyhwYXJlbnRFbCkpIHtcbiAgICBpZiAoIWlzLnN2ZyhwYXJlbnRFbC5wYXJlbnROb2RlKSkgeyBicmVhazsgfVxuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gcGFyZW50RWw7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2ZyhwYXRoRWwsIHN2Z0RhdGEpIHtcbiAgdmFyIHN2ZyA9IHN2Z0RhdGEgfHwge307XG4gIHZhciBwYXJlbnRTdmdFbCA9IHN2Zy5lbCB8fCBnZXRQYXJlbnRTdmdFbChwYXRoRWwpO1xuICB2YXIgcmVjdCA9IHBhcmVudFN2Z0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdmlld0JveEF0dHIgPSBnZXRBdHRyaWJ1dGUocGFyZW50U3ZnRWwsICd2aWV3Qm94Jyk7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIHZpZXdCb3ggPSBzdmcudmlld0JveCB8fCAodmlld0JveEF0dHIgPyB2aWV3Qm94QXR0ci5zcGxpdCgnICcpIDogWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgcmV0dXJuIHtcbiAgICBlbDogcGFyZW50U3ZnRWwsXG4gICAgdmlld0JveDogdmlld0JveCxcbiAgICB4OiB2aWV3Qm94WzBdIC8gMSxcbiAgICB5OiB2aWV3Qm94WzFdIC8gMSxcbiAgICB3OiB3aWR0aCxcbiAgICBoOiBoZWlnaHQsXG4gICAgdlc6IHZpZXdCb3hbMl0sXG4gICAgdkg6IHZpZXdCb3hbM11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgsIHBlcmNlbnQpIHtcbiAgdmFyIHBhdGhFbCA9IGlzLnN0cihwYXRoKSA/IHNlbGVjdFN0cmluZyhwYXRoKVswXSA6IHBhdGg7XG4gIHZhciBwID0gcGVyY2VudCB8fCAxMDA7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICBlbDogcGF0aEVsLFxuICAgICAgc3ZnOiBnZXRQYXJlbnRTdmcocGF0aEVsKSxcbiAgICAgIHRvdGFsTGVuZ3RoOiBnZXRUb3RhbExlbmd0aChwYXRoRWwpICogKHAgLyAxMDApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQcm9ncmVzcyhwYXRoLCBwcm9ncmVzcywgaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHKSB7XG4gIGZ1bmN0aW9uIHBvaW50KG9mZnNldCkge1xuICAgIGlmICggb2Zmc2V0ID09PSB2b2lkIDAgKSBvZmZzZXQgPSAwO1xuXG4gICAgdmFyIGwgPSBwcm9ncmVzcyArIG9mZnNldCA+PSAxID8gcHJvZ3Jlc3MgKyBvZmZzZXQgOiAwO1xuICAgIHJldHVybiBwYXRoLmVsLmdldFBvaW50QXRMZW5ndGgobCk7XG4gIH1cbiAgdmFyIHN2ZyA9IGdldFBhcmVudFN2ZyhwYXRoLmVsLCBwYXRoLnN2Zyk7XG4gIHZhciBwID0gcG9pbnQoKTtcbiAgdmFyIHAwID0gcG9pbnQoLTEpO1xuICB2YXIgcDEgPSBwb2ludCgrMSk7XG4gIHZhciBzY2FsZVggPSBpc1BhdGhUYXJnZXRJbnNpZGVTVkcgPyAxIDogc3ZnLncgLyBzdmcudlc7XG4gIHZhciBzY2FsZVkgPSBpc1BhdGhUYXJnZXRJbnNpZGVTVkcgPyAxIDogc3ZnLmggLyBzdmcudkg7XG4gIHN3aXRjaCAocGF0aC5wcm9wZXJ0eSkge1xuICAgIGNhc2UgJ3gnOiByZXR1cm4gKHAueCAtIHN2Zy54KSAqIHNjYWxlWDtcbiAgICBjYXNlICd5JzogcmV0dXJuIChwLnkgLSBzdmcueSkgKiBzY2FsZVk7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIC8vIGNvbnN0IHJneCA9IC8tP1xcZCpcXC4/XFxkKy9nOyAvLyBoYW5kbGVzIGJhc2ljIG51bWJlcnNcbiAgLy8gY29uc3Qgcmd4ID0gL1srLV0/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgcmd4ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciB2YWx1ZSA9IHZhbGlkYXRlVmFsdWUoKGlzLnB0aCh2YWwpID8gdmFsLnRvdGFsTGVuZ3RoIDogdmFsKSwgdW5pdCkgKyAnJztcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgbnVtYmVyczogdmFsdWUubWF0Y2gocmd4KSA/IHZhbHVlLm1hdGNoKHJneCkubWFwKE51bWJlcikgOiBbMF0sXG4gICAgc3RyaW5nczogKGlzLnN0cih2YWwpIHx8IHVuaXQpID8gdmFsdWUuc3BsaXQocmd4KSA6IFtdXG4gIH1cbn1cblxuLy8gQW5pbWF0YWJsZXNcblxuZnVuY3Rpb24gcGFyc2VUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHRhcmdldHMgPyAoZmxhdHRlbkFycmF5KGlzLmFycih0YXJnZXRzKSA/IHRhcmdldHMubWFwKHRvQXJyYXkpIDogdG9BcnJheSh0YXJnZXRzKSkpIDogW107XG4gIHJldHVybiBmaWx0ZXJBcnJheSh0YXJnZXRzQXJyYXksIGZ1bmN0aW9uIChpdGVtLCBwb3MsIHNlbGYpIHsgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gcG9zOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICByZXR1cm4gcGFyc2VkLm1hcChmdW5jdGlvbiAodCwgaSkge1xuICAgIHJldHVybiB7dGFyZ2V0OiB0LCBpZDogaSwgdG90YWw6IHBhcnNlZC5sZW5ndGgsIHRyYW5zZm9ybXM6IHsgbGlzdDogZ2V0RWxlbWVudFRyYW5zZm9ybXModCkgfSB9O1xuICB9KTtcbn1cblxuLy8gUHJvcGVydGllc1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwcm9wLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5ncyA9IGNsb25lT2JqZWN0KHR3ZWVuU2V0dGluZ3MpO1xuICAvLyBPdmVycmlkZSBkdXJhdGlvbiBpZiBlYXNpbmcgaXMgYSBzcHJpbmdcbiAgaWYgKC9ec3ByaW5nLy50ZXN0KHNldHRpbmdzLmVhc2luZykpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSBzcHJpbmcoc2V0dGluZ3MuZWFzaW5nKTsgfVxuICBpZiAoaXMuYXJyKHByb3ApKSB7XG4gICAgdmFyIGwgPSBwcm9wLmxlbmd0aDtcbiAgICB2YXIgaXNGcm9tVG8gPSAobCA9PT0gMiAmJiAhaXMub2JqKHByb3BbMF0pKTtcbiAgICBpZiAoIWlzRnJvbVRvKSB7XG4gICAgICAvLyBEdXJhdGlvbiBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgdHdlZW5zXG4gICAgICBpZiAoIWlzLmZuYyh0d2VlblNldHRpbmdzLmR1cmF0aW9uKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24gLyBsOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBbZnJvbSwgdG9dIHZhbHVlcyBzaG9ydGhhbmQgdG8gYSB2YWxpZCB0d2VlbiB2YWx1ZVxuICAgICAgcHJvcCA9IHt2YWx1ZTogcHJvcH07XG4gICAgfVxuICB9XG4gIHZhciBwcm9wQXJyYXkgPSBpcy5hcnIocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICByZXR1cm4gcHJvcEFycmF5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHZhciBvYmogPSAoaXMub2JqKHYpICYmICFpcy5wdGgodikpID8gdiA6IHt2YWx1ZTogdn07XG4gICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmRlbGF5KSkgeyBvYmouZGVsYXkgPSAhaSA/IHR3ZWVuU2V0dGluZ3MuZGVsYXkgOiAwOyB9XG4gICAgLy8gRGVmYXVsdCBlbmREZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBsYXN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZW5kRGVsYXkpKSB7IG9iai5lbmREZWxheSA9IGkgPT09IHByb3BBcnJheS5sZW5ndGggLSAxID8gdHdlZW5TZXR0aW5ncy5lbmREZWxheSA6IDA7IH1cbiAgICByZXR1cm4gb2JqO1xuICB9KS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG1lcmdlT2JqZWN0cyhrLCBzZXR0aW5ncyk7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSB7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gT2JqZWN0LmtleXMoa2V5KTsgfSkpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gaXMua2V5KHApOyB9KVxuICAucmVkdWNlKGZ1bmN0aW9uIChhLGIpIHsgaWYgKGEuaW5kZXhPZihiKSA8IDApIHsgYS5wdXNoKGIpOyB9IHJldHVybiBhOyB9LCBbXSk7XG4gIHZhciBwcm9wZXJ0aWVzID0ge307XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBuZXdLZXkgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4ga2V5KSB7XG4gICAgICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgICAgICBpZiAocCA9PSBwcm9wTmFtZSkgeyBuZXdLZXkudmFsdWUgPSBrZXlbcF07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcykge1xuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICB2YXIga2V5ZnJhbWVzID0gcGFyYW1zLmtleWZyYW1lcztcbiAgaWYgKGtleWZyYW1lcykgeyBwYXJhbXMgPSBtZXJnZU9iamVjdHMoZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpLCBwYXJhbXMpOyB9XG4gIGZvciAodmFyIHAgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcCxcbiAgICAgICAgdHdlZW5zOiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwYXJhbXNbcF0sIHR3ZWVuU2V0dGluZ3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbi8vIFR3ZWVuc1xuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlblZhbHVlcyh0d2VlbiwgYW5pbWF0YWJsZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHR3ZWVuKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlbltwXSwgYW5pbWF0YWJsZSk7XG4gICAgaWYgKGlzLmFycih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBnZXRGdW5jdGlvblZhbHVlKHYsIGFuaW1hdGFibGUpOyB9KTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHsgdmFsdWUgPSB2YWx1ZVswXTsgfVxuICAgIH1cbiAgICB0W3BdID0gdmFsdWU7XG4gIH1cbiAgdC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodC5kdXJhdGlvbik7XG4gIHQuZGVsYXkgPSBwYXJzZUZsb2F0KHQuZGVsYXkpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpIHtcbiAgdmFyIHByZXZpb3VzVHdlZW47XG4gIHJldHVybiBwcm9wLnR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgdHdlZW4gPSBub3JtYWxpemVUd2VlblZhbHVlcyh0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgdHdlZW5WYWx1ZSA9IHR3ZWVuLnZhbHVlO1xuICAgIHZhciB0byA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMV0gOiB0d2VlblZhbHVlO1xuICAgIHZhciB0b1VuaXQgPSBnZXRVbml0KHRvKTtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSwgdG9Vbml0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLnRvLm9yaWdpbmFsIDogb3JpZ2luYWxWYWx1ZTtcbiAgICB2YXIgZnJvbSA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMF0gOiBwcmV2aW91c1ZhbHVlO1xuICAgIHZhciBmcm9tVW5pdCA9IGdldFVuaXQoZnJvbSkgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICB2YXIgdW5pdCA9IHRvVW5pdCB8fCBmcm9tVW5pdDtcbiAgICBpZiAoaXMudW5kKHRvKSkgeyB0byA9IHByZXZpb3VzVmFsdWU7IH1cbiAgICB0d2Vlbi5mcm9tID0gZGVjb21wb3NlVmFsdWUoZnJvbSwgdW5pdCk7XG4gICAgdHdlZW4udG8gPSBkZWNvbXBvc2VWYWx1ZShnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSwgdW5pdCk7XG4gICAgdHdlZW4uc3RhcnQgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi5lbmQgOiAwO1xuICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0ICsgdHdlZW4uZGVsYXkgKyB0d2Vlbi5kdXJhdGlvbiArIHR3ZWVuLmVuZERlbGF5O1xuICAgIHR3ZWVuLmVhc2luZyA9IHBhcnNlRWFzaW5ncyh0d2Vlbi5lYXNpbmcsIHR3ZWVuLmR1cmF0aW9uKTtcbiAgICB0d2Vlbi5pc1BhdGggPSBpcy5wdGgodHdlZW5WYWx1ZSk7XG4gICAgdHdlZW4uaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHID0gdHdlZW4uaXNQYXRoICYmIGlzLnN2ZyhhbmltYXRhYmxlLnRhcmdldCk7XG4gICAgdHdlZW4uaXNDb2xvciA9IGlzLmNvbCh0d2Vlbi5mcm9tLm9yaWdpbmFsKTtcbiAgICBpZiAodHdlZW4uaXNDb2xvcikgeyB0d2Vlbi5yb3VuZCA9IDE7IH1cbiAgICBwcmV2aW91c1R3ZWVuID0gdHdlZW47XG4gICAgcmV0dXJuIHR3ZWVuO1xuICB9KTtcbn1cblxuLy8gVHdlZW4gcHJvZ3Jlc3NcblxudmFyIHNldFByb2dyZXNzVmFsdWUgPSB7XG4gIGNzczogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc3R5bGVbcF0gPSB2OyB9LFxuICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnNldEF0dHJpYnV0ZShwLCB2KTsgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdFtwXSA9IHY7IH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHQsIHAsIHYsIHRyYW5zZm9ybXMsIG1hbnVhbCkge1xuICAgIHRyYW5zZm9ybXMubGlzdC5zZXQocCwgdik7XG4gICAgaWYgKHAgPT09IHRyYW5zZm9ybXMubGFzdCB8fCBtYW51YWwpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHRyYW5zZm9ybXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkgeyBzdHIgKz0gcHJvcCArIFwiKFwiICsgdmFsdWUgKyBcIikgXCI7IH0pO1xuICAgICAgdC5zdHlsZS50cmFuc2Zvcm0gPSBzdHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgVmFsdWUgaGVscGVyXG5cbmZ1bmN0aW9uIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHRhcmdldHMpO1xuICBhbmltYXRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShwcm9wZXJ0aWVzW3Byb3BlcnR5XSwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdGFyZ2V0ID0gYW5pbWF0YWJsZS50YXJnZXQ7XG4gICAgICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWVVbml0LCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB1bml0ID0gdmFsdWVVbml0IHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgdG8gPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbGlkYXRlVmFsdWUodmFsdWUsIHVuaXQpLCBvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW1UeXBlXSh0YXJnZXQsIHByb3BlcnR5LCB0bywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBBbmltYXRpb25zXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKSB7XG4gIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSk7XG4gIGlmIChhbmltVHlwZSkge1xuICAgIHZhciB0d2VlbnMgPSBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIGxhc3RUd2VlbiA9IHR3ZWVuc1t0d2VlbnMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFuaW1UeXBlLFxuICAgICAgcHJvcGVydHk6IHByb3AubmFtZSxcbiAgICAgIGFuaW1hdGFibGU6IGFuaW1hdGFibGUsXG4gICAgICB0d2VlbnM6IHR3ZWVucyxcbiAgICAgIGR1cmF0aW9uOiBsYXN0VHdlZW4uZW5kLFxuICAgICAgZGVsYXk6IHR3ZWVuc1swXS5kZWxheSxcbiAgICAgIGVuZERlbGF5OiBsYXN0VHdlZW4uZW5kRGVsYXlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcykge1xuICByZXR1cm4gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGFuaW1hdGFibGVzLm1hcChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKTtcbiAgICB9KTtcbiAgfSkpLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWlzLnVuZChhKTsgfSk7XG59XG5cbi8vIENyZWF0ZSBJbnN0YW5jZVxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgYW5pbUxlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICB2YXIgZ2V0VGxPZmZzZXQgPSBmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS50aW1lbGluZU9mZnNldCA/IGFuaW0udGltZWxpbmVPZmZzZXQgOiAwOyB9O1xuICB2YXIgdGltaW5ncyA9IHt9O1xuICB0aW1pbmdzLmR1cmF0aW9uID0gYW5pbUxlbmd0aCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb247IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb247XG4gIHRpbWluZ3MuZGVsYXkgPSBhbmltTGVuZ3RoID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5kZWxheTtcbiAgdGltaW5ncy5lbmREZWxheSA9IGFuaW1MZW5ndGggPyB0aW1pbmdzLmR1cmF0aW9uIC0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbiAtIGFuaW0uZW5kRGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXk7XG4gIHJldHVybiB0aW1pbmdzO1xufVxuXG52YXIgaW5zdGFuY2VJRCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcykge1xuICB2YXIgaW5zdGFuY2VTZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHR3ZWVuU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyhwYXJhbXMudGFyZ2V0cyk7XG4gIHZhciBhbmltYXRpb25zID0gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcyk7XG4gIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpO1xuICB2YXIgaWQgPSBpbnN0YW5jZUlEO1xuICBpbnN0YW5jZUlEKys7XG4gIHJldHVybiBtZXJnZU9iamVjdHMoaW5zdGFuY2VTZXR0aW5ncywge1xuICAgIGlkOiBpZCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYW5pbWF0YWJsZXM6IGFuaW1hdGFibGVzLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sXG4gICAgZGVsYXk6IHRpbWluZ3MuZGVsYXksXG4gICAgZW5kRGVsYXk6IHRpbWluZ3MuZW5kRGVsYXlcbiAgfSk7XG59XG5cbi8vIENvcmVcblxudmFyIGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhZjtcblxuICBmdW5jdGlvbiBwbGF5KCkge1xuICAgIGlmICghcmFmICYmICghaXNEb2N1bWVudEhpZGRlbigpIHx8ICFhbmltZS5zdXNwZW5kV2hlbkRvY3VtZW50SGlkZGVuKSAmJiBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGVwKHQpIHtcbiAgICAvLyBtZW1vIG9uIGFsZ29yaXRobSBpc3N1ZTpcbiAgICAvLyBkYW5nZXJvdXMgaXRlcmF0aW9uIG92ZXIgbXV0YWJsZSBgYWN0aXZlSW5zdGFuY2VzYFxuICAgIC8vICh0aGF0IGNvbGxlY3Rpb24gbWF5IGJlIHVwZGF0ZWQgZnJvbSB3aXRoaW4gY2FsbGJhY2tzIG9mIGB0aWNrYC1lZCBhbmltYXRpb24gaW5zdGFuY2VzKVxuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFjdGl2ZUluc3RhbmNlc0xlbmd0aCkge1xuICAgICAgdmFyIGFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UudGljayh0KTtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJhZiA9IGkgPiAwID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoIWFuaW1lLnN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4pIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoaXNEb2N1bWVudEhpZGRlbigpKSB7XG4gICAgICAvLyBzdXNwZW5kIHRpY2tzXG4gICAgICByYWYgPSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgIH0gZWxzZSB7IC8vIGlzIGJhY2sgdG8gYWN0aXZlIHRhYlxuICAgICAgLy8gZmlyc3QgYWRqdXN0IGFuaW1hdGlvbnMgdG8gY29uc2lkZXIgdGhlIHRpbWUgdGhhdCB0aWNrcyB3ZXJlIHN1c3BlbmRlZFxuICAgICAgYWN0aXZlSW5zdGFuY2VzLmZvckVhY2goXG4gICAgICAgIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UgLl9vbkRvY3VtZW50VmlzaWJpbGl0eSgpOyB9XG4gICAgICApO1xuICAgICAgZW5naW5lKCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXk7XG59KSgpO1xuXG5mdW5jdGlvbiBpc0RvY3VtZW50SGlkZGVuKCkge1xuICByZXR1cm4gISFkb2N1bWVudCAmJiBkb2N1bWVudC5oaWRkZW47XG59XG5cbi8vIFB1YmxpYyBJbnN0YW5jZVxuXG5mdW5jdGlvbiBhbmltZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IDAsIGxhc3RUaW1lID0gMCwgbm93ID0gMDtcbiAgdmFyIGNoaWxkcmVuLCBjaGlsZHJlbkxlbmd0aCA9IDA7XG4gIHZhciByZXNvbHZlID0gbnVsbDtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZShpbnN0YW5jZSkge1xuICAgIHZhciBwcm9taXNlID0gd2luZG93LlByb21pc2UgJiYgbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlKSB7IHJldHVybiByZXNvbHZlID0gX3Jlc29sdmU7IH0pO1xuICAgIGluc3RhbmNlLmZpbmlzaGVkID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcyk7XG4gIHZhciBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnN0YW5jZS5kaXJlY3Rpb247XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgIGluc3RhbmNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiAhPT0gJ25vcm1hbCcgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJztcbiAgICB9XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSAhaW5zdGFuY2UucmV2ZXJzZWQ7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnJldmVyc2VkID0gaW5zdGFuY2UucmV2ZXJzZWQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGltZSgpIHtcbiAgICBzdGFydFRpbWUgPSAwO1xuICAgIGxhc3RUaW1lID0gYWRqdXN0VGltZShpbnN0YW5jZS5jdXJyZW50VGltZSkgKiAoMSAvIGFuaW1lLnNwZWVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlZWtDaGlsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpXSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hpbGRyZW5MZW5ndGg7IGkkMS0tOykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baSQxXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGFuaW1hdGlvbnNMZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGFuaW1hdGlvbnNMZW5ndGgpIHtcbiAgICAgIHZhciBhbmltID0gYW5pbWF0aW9uc1tpXTtcbiAgICAgIHZhciBhbmltYXRhYmxlID0gYW5pbS5hbmltYXRhYmxlO1xuICAgICAgdmFyIHR3ZWVucyA9IGFuaW0udHdlZW5zO1xuICAgICAgdmFyIHR3ZWVuTGVuZ3RoID0gdHdlZW5zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbdHdlZW5MZW5ndGhdO1xuICAgICAgLy8gT25seSBjaGVjayBmb3Iga2V5ZnJhbWVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHdlZW5cbiAgICAgIGlmICh0d2Vlbkxlbmd0aCkgeyB0d2VlbiA9IGZpbHRlckFycmF5KHR3ZWVucywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpbnNUaW1lIDwgdC5lbmQpOyB9KVswXSB8fCB0d2VlbjsgfVxuICAgICAgdmFyIGVsYXBzZWQgPSBtaW5NYXgoaW5zVGltZSAtIHR3ZWVuLnN0YXJ0IC0gdHdlZW4uZGVsYXksIDAsIHR3ZWVuLmR1cmF0aW9uKSAvIHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgdmFyIGVhc2VkID0gaXNOYU4oZWxhcHNlZCkgPyAxIDogdHdlZW4uZWFzaW5nKGVsYXBzZWQpO1xuICAgICAgdmFyIHN0cmluZ3MgPSB0d2Vlbi50by5zdHJpbmdzO1xuICAgICAgdmFyIHJvdW5kID0gdHdlZW4ucm91bmQ7XG4gICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgdmFyIHRvTnVtYmVyc0xlbmd0aCA9IHR3ZWVuLnRvLm51bWJlcnMubGVuZ3RoO1xuICAgICAgdmFyIHByb2dyZXNzID0gKHZvaWQgMCk7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRvTnVtYmVyc0xlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgdG9OdW1iZXIgPSB0d2Vlbi50by5udW1iZXJzW25dO1xuICAgICAgICB2YXIgZnJvbU51bWJlciA9IHR3ZWVuLmZyb20ubnVtYmVyc1tuXSB8fCAwO1xuICAgICAgICBpZiAoIXR3ZWVuLmlzUGF0aCkge1xuICAgICAgICAgIHZhbHVlID0gZnJvbU51bWJlciArIChlYXNlZCAqICh0b051bWJlciAtIGZyb21OdW1iZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFBhdGhQcm9ncmVzcyh0d2Vlbi52YWx1ZSwgZWFzZWQgKiB0b051bWJlciwgdHdlZW4uaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICBpZiAoISh0d2Vlbi5pc0NvbG9yICYmIG4gPiAyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcm91bmQpIC8gcm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBNYW51YWwgQXJyYXkucmVkdWNlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VzXG4gICAgICB2YXIgc3RyaW5nc0xlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgaWYgKCFzdHJpbmdzTGVuZ3RoKSB7XG4gICAgICAgIHByb2dyZXNzID0gbnVtYmVyc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gc3RyaW5nc1swXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdHJpbmdzTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgYSA9IHN0cmluZ3Nbc107XG4gICAgICAgICAgdmFyIGIgPSBzdHJpbmdzW3MgKyAxXTtcbiAgICAgICAgICB2YXIgbiQxID0gbnVtYmVyc1tzXTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG4kMSkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyAnICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltLnR5cGVdKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltLnByb3BlcnR5LCBwcm9ncmVzcywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zKTtcbiAgICAgIGFuaW0uY3VycmVudFZhbHVlID0gcHJvZ3Jlc3M7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FsbGJhY2soY2IpIHtcbiAgICBpZiAoaW5zdGFuY2VbY2JdICYmICFpbnN0YW5jZS5wYXNzVGhyb3VnaCkgeyBpbnN0YW5jZVtjYl0oaW5zdGFuY2UpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEl0ZXJhdGlvbigpIHtcbiAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nICYmIGluc3RhbmNlLnJlbWFpbmluZyAhPT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UucmVtYWluaW5nLS07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5zdGFuY2VQcm9ncmVzcyhlbmdpbmVUaW1lKSB7XG4gICAgdmFyIGluc0R1cmF0aW9uID0gaW5zdGFuY2UuZHVyYXRpb247XG4gICAgdmFyIGluc0RlbGF5ID0gaW5zdGFuY2UuZGVsYXk7XG4gICAgdmFyIGluc0VuZERlbGF5ID0gaW5zRHVyYXRpb24gLSBpbnN0YW5jZS5lbmREZWxheTtcbiAgICB2YXIgaW5zVGltZSA9IGFkanVzdFRpbWUoZW5naW5lVGltZSk7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSBtaW5NYXgoKGluc1RpbWUgLyBpbnNEdXJhdGlvbikgKiAxMDAsIDAsIDEwMCk7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gaW5zVGltZSA8IGluc3RhbmNlLmN1cnJlbnRUaW1lO1xuICAgIGlmIChjaGlsZHJlbikgeyBzeW5jSW5zdGFuY2VDaGlsZHJlbihpbnNUaW1lKTsgfVxuICAgIGlmICghaW5zdGFuY2UuYmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5iZWdhbiA9IHRydWU7XG4gICAgICBzZXRDYWxsYmFjaygnYmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKCFpbnN0YW5jZS5sb29wQmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlbWFpbmluZykge1xuICAgICAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWluc3RhbmNlLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdjb21wbGV0ZScpO1xuICAgICAgICAgIGlmICghaW5zdGFuY2UucGFzc1Rocm91Z2ggJiYgJ1Byb21pc2UnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmRpcmVjdGlvbiA9PT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgICAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zdGFuY2UucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGluc3RhbmNlLnBhc3NUaHJvdWdoID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gMDtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9IGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnO1xuICAgIGluc3RhbmNlLnJlbWFpbmluZyA9IGluc3RhbmNlLmxvb3A7XG4gICAgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW5MZW5ndGg7IGktLTspIHsgaW5zdGFuY2UuY2hpbGRyZW5baV0ucmVzZXQoKTsgfVxuICAgIGlmIChpbnN0YW5jZS5yZXZlcnNlZCAmJiBpbnN0YW5jZS5sb29wICE9PSB0cnVlIHx8IChkaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnICYmIGluc3RhbmNlLmxvb3AgPT09IDEpKSB7IGluc3RhbmNlLnJlbWFpbmluZysrOyB9XG4gICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gOiAwKTtcbiAgfTtcblxuICAvLyBpbnRlcm5hbCBtZXRob2QgKGZvciBlbmdpbmUpIHRvIGFkanVzdCBhbmltYXRpb24gdGltaW5ncyBiZWZvcmUgcmVzdG9yaW5nIGVuZ2luZSB0aWNrcyAockFGKVxuICBpbnN0YW5jZS5fb25Eb2N1bWVudFZpc2liaWxpdHkgPSByZXNldFRpbWU7XG5cbiAgLy8gU2V0IFZhbHVlIGhlbHBlclxuXG4gIGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLnRpY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgbm93ID0gdDtcbiAgICBpZiAoIXN0YXJ0VGltZSkgeyBzdGFydFRpbWUgPSBub3c7IH1cbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKChub3cgKyAobGFzdFRpbWUgLSBzdGFydFRpbWUpKSAqIGFuaW1lLnNwZWVkKTtcbiAgfTtcblxuICBpbnN0YW5jZS5zZWVrID0gZnVuY3Rpb24odGltZSkge1xuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoYWRqdXN0VGltZSh0aW1lKSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWluc3RhbmNlLnBhdXNlZCkgeyByZXR1cm47IH1cbiAgICBpZiAoaW5zdGFuY2UuY29tcGxldGVkKSB7IGluc3RhbmNlLnJlc2V0KCk7IH1cbiAgICBpbnN0YW5jZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhY3RpdmVJbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgcmVzZXRUaW1lKCk7XG4gICAgZW5naW5lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gaW5zdGFuY2UucmV2ZXJzZWQgPyBmYWxzZSA6IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnJlc2V0KCk7XG4gICAgaW5zdGFuY2UucGxheSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlbW92ZSA9IGZ1bmN0aW9uKHRhcmdldHMpIHtcbiAgICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UodGFyZ2V0c0FycmF5LCBpbnN0YW5jZSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzZXQoKTtcblxuICBpZiAoaW5zdGFuY2UuYXV0b3BsYXkpIHsgaW5zdGFuY2UucGxheSgpOyB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xuXG59XG5cbi8vIFJlbW92ZSB0YXJnZXRzIGZyb20gYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnMpIHtcbiAgZm9yICh2YXIgYSA9IGFuaW1hdGlvbnMubGVuZ3RoOyBhLS07KSB7XG4gICAgaWYgKGFycmF5Q29udGFpbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zW2FdLmFuaW1hdGFibGUudGFyZ2V0KSkge1xuICAgICAgYW5pbWF0aW9ucy5zcGxpY2UoYSwgMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UodGFyZ2V0c0FycmF5LCBpbnN0YW5jZSkge1xuICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gIHZhciBjaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuO1xuICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgZm9yICh2YXIgYyA9IGNoaWxkcmVuLmxlbmd0aDsgYy0tOykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2NdO1xuICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGNoaWxkQW5pbWF0aW9ucyk7XG4gICAgaWYgKCFjaGlsZEFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHsgY2hpbGRyZW4uc3BsaWNlKGMsIDEpOyB9XG4gIH1cbiAgaWYgKCFhbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGRyZW4ubGVuZ3RoKSB7IGluc3RhbmNlLnBhdXNlKCk7IH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BY3RpdmVJbnN0YW5jZXModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBmb3IgKHZhciBpID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUluc3RhbmNlKHRhcmdldHNBcnJheSwgaW5zdGFuY2UpO1xuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4yLjEnO1xuYW5pbWUuc3BlZWQgPSAxO1xuLy8gVE9ETzojcmV2aWV3OiBuYW1pbmcsIGRvY3VtZW50YXRpb25cbmFuaW1lLnN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4gPSB0cnVlO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHNGcm9tQWN0aXZlSW5zdGFuY2VzO1xuYW5pbWUuZ2V0ID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZTtcbmFuaW1lLnNldCA9IHNldFRhcmdldHNWYWx1ZTtcbmFuaW1lLmNvbnZlcnRQeCA9IGNvbnZlcnRQeFRvVW5pdDtcbmFuaW1lLnBhdGggPSBnZXRQYXRoO1xuYW5pbWUuc2V0RGFzaG9mZnNldCA9IHNldERhc2hvZmZzZXQ7XG5hbmltZS5zdGFnZ2VyID0gc3RhZ2dlcjtcbmFuaW1lLnRpbWVsaW5lID0gdGltZWxpbmU7XG5hbmltZS5lYXNpbmcgPSBwYXJzZUVhc2luZ3M7XG5hbmltZS5wZW5uZXIgPSBwZW5uZXI7XG5hbmltZS5yYW5kb20gPSBmdW5jdGlvbiAobWluLCBtYXgpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47IH07XG5cbmV4cG9ydCBkZWZhdWx0IGFuaW1lO1xuIl0sIm5hbWVzIjpbImRlZmF1bHRJbnN0YW5jZVNldHRpbmdzIiwidXBkYXRlIiwiYmVnaW4iLCJsb29wQmVnaW4iLCJjaGFuZ2VCZWdpbiIsImNoYW5nZSIsImNoYW5nZUNvbXBsZXRlIiwibG9vcENvbXBsZXRlIiwiY29tcGxldGUiLCJsb29wIiwiZGlyZWN0aW9uIiwiYXV0b3BsYXkiLCJ0aW1lbGluZU9mZnNldCIsImRlZmF1bHRUd2VlblNldHRpbmdzIiwiZHVyYXRpb24iLCJkZWxheSIsImVuZERlbGF5IiwiZWFzaW5nIiwicm91bmQiLCJ2YWxpZFRyYW5zZm9ybXMiLCJjYWNoZSIsIkNTUyIsInNwcmluZ3MiLCJtaW5NYXgiLCJ2YWwiLCJtaW4iLCJtYXgiLCJNYXRoIiwic3RyaW5nQ29udGFpbnMiLCJzdHIiLCJ0ZXh0IiwiaW5kZXhPZiIsImFwcGx5QXJndW1lbnRzIiwiZnVuYyIsImFyZ3MiLCJhcHBseSIsImlzIiwiYXJyIiwiYSIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInB0aCIsImhhc093blByb3BlcnR5Iiwic3ZnIiwiU1ZHRWxlbWVudCIsImlucCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJkb20iLCJub2RlVHlwZSIsImZuYyIsInVuZCIsIm5pbCIsImhleCIsInRlc3QiLCJyZ2IiLCJoc2wiLCJjb2wiLCJrZXkiLCJwYXJzZUVhc2luZ1BhcmFtZXRlcnMiLCJzdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJzcGxpdCIsIm1hcCIsInAiLCJwYXJzZUZsb2F0Iiwic3ByaW5nIiwicGFyYW1zIiwibWFzcyIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJ2ZWxvY2l0eSIsIncwIiwic3FydCIsInpldGEiLCJ3ZCIsImIiLCJzb2x2ZXIiLCJ0IiwicHJvZ3Jlc3MiLCJleHAiLCJjb3MiLCJzaW4iLCJnZXREdXJhdGlvbiIsImNhY2hlZCIsImZyYW1lIiwiZWxhcHNlZCIsInJlc3QiLCJzdGVwcyIsImNlaWwiLCJiZXppZXIiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiQSIsImFBMSIsImFBMiIsIkIiLCJDIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiaSIsImFicyIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsIm1ZMSIsIm1ZMiIsInNhbXBsZVZhbHVlcyIsIkZsb2F0MzJBcnJheSIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIngiLCJwZW5uZXIiLCJlYXNlcyIsImxpbmVhciIsImZ1bmN0aW9uRWFzaW5ncyIsIlNpbmUiLCJQSSIsIkV4cG8iLCJwb3ciLCJDaXJjIiwiQmFjayIsIkJvdW5jZSIsInBvdzIiLCJFbGFzdGljIiwiYW1wbGl0dWRlIiwicGVyaW9kIiwiYXNpbiIsImJhc2VFYXNpbmdzIiwiZm9yRWFjaCIsIm5hbWUiLCJrZXlzIiwiZWFzZUluIiwicGFyc2VFYXNpbmdzIiwiZWFzZSIsInNlbGVjdFN0cmluZyIsIm5vZGVzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZSIsImZpbHRlckFycmF5IiwiY2FsbGJhY2siLCJsZW4iLCJsZW5ndGgiLCJ0aGlzQXJnIiwiYXJndW1lbnRzIiwicmVzdWx0IiwicHVzaCIsImZsYXR0ZW5BcnJheSIsInJlZHVjZSIsImNvbmNhdCIsInRvQXJyYXkiLCJvIiwiTm9kZUxpc3QiLCJIVE1MQ29sbGVjdGlvbiIsInNsaWNlIiwiYXJyYXlDb250YWlucyIsInNvbWUiLCJjbG9uZU9iamVjdCIsImNsb25lIiwicmVwbGFjZU9iamVjdFByb3BzIiwibzEiLCJvMiIsIm1lcmdlT2JqZWN0cyIsInJnYlRvUmdiYSIsInJnYlZhbHVlIiwiaGV4VG9SZ2JhIiwiaGV4VmFsdWUiLCJyZ3giLCJyZXBsYWNlIiwibSIsInIiLCJnIiwicGFyc2VJbnQiLCJoc2xUb1JnYmEiLCJoc2xWYWx1ZSIsImgiLCJzIiwibCIsImh1ZTJyZ2IiLCJxIiwiY29sb3JUb1JnYiIsImdldFVuaXQiLCJnZXRUcmFuc2Zvcm1Vbml0IiwicHJvcE5hbWUiLCJnZXRGdW5jdGlvblZhbHVlIiwiYW5pbWF0YWJsZSIsInRhcmdldCIsImlkIiwidG90YWwiLCJnZXRBdHRyaWJ1dGUiLCJlbCIsInByb3AiLCJjb252ZXJ0UHhUb1VuaXQiLCJ2YWx1ZSIsInVuaXQiLCJ2YWx1ZVVuaXQiLCJiYXNlbGluZSIsInRlbXBFbCIsImNyZWF0ZUVsZW1lbnQiLCJ0YWdOYW1lIiwicGFyZW50RWwiLCJwYXJlbnROb2RlIiwiYm9keSIsImFwcGVuZENoaWxkIiwic3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiZmFjdG9yIiwib2Zmc2V0V2lkdGgiLCJyZW1vdmVDaGlsZCIsImNvbnZlcnRlZFVuaXQiLCJnZXRDU1NWYWx1ZSIsInVwcGVyY2FzZVByb3BOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdldEFuaW1hdGlvblR5cGUiLCJnZXRFbGVtZW50VHJhbnNmb3JtcyIsInRyYW5zZm9ybSIsInJlZyIsInRyYW5zZm9ybXMiLCJNYXAiLCJzZXQiLCJnZXRUcmFuc2Zvcm1WYWx1ZSIsImRlZmF1bHRWYWwiLCJnZXQiLCJsaXN0IiwiZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSIsImdldFJlbGF0aXZlVmFsdWUiLCJ0byIsImZyb20iLCJvcGVyYXRvciIsInUiLCJ5IiwidmFsaWRhdGVWYWx1ZSIsIm9yaWdpbmFsVW5pdCIsInVuaXRMZXNzIiwic3Vic3RyIiwiZ2V0RGlzdGFuY2UiLCJwMSIsInAyIiwiZ2V0Q2lyY2xlTGVuZ3RoIiwiZ2V0UmVjdExlbmd0aCIsImdldExpbmVMZW5ndGgiLCJnZXRQb2x5bGluZUxlbmd0aCIsInBvaW50cyIsInRvdGFsTGVuZ3RoIiwicHJldmlvdXNQb3MiLCJudW1iZXJPZkl0ZW1zIiwiY3VycmVudFBvcyIsImdldEl0ZW0iLCJnZXRQb2x5Z29uTGVuZ3RoIiwiZ2V0VG90YWxMZW5ndGgiLCJzZXREYXNob2Zmc2V0IiwicGF0aExlbmd0aCIsInNldEF0dHJpYnV0ZSIsImdldFBhcmVudFN2Z0VsIiwiZ2V0UGFyZW50U3ZnIiwicGF0aEVsIiwic3ZnRGF0YSIsInBhcmVudFN2Z0VsIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInZpZXdCb3hBdHRyIiwiaGVpZ2h0Iiwidmlld0JveCIsInciLCJ2VyIsInZIIiwiZ2V0UGF0aCIsInBhdGgiLCJwZXJjZW50IiwicHJvcGVydHkiLCJnZXRQYXRoUHJvZ3Jlc3MiLCJpc1BhdGhUYXJnZXRJbnNpZGVTVkciLCJwb2ludCIsIm9mZnNldCIsImdldFBvaW50QXRMZW5ndGgiLCJwMCIsInNjYWxlWCIsInNjYWxlWSIsImF0YW4yIiwiZGVjb21wb3NlVmFsdWUiLCJvcmlnaW5hbCIsIm51bWJlcnMiLCJOdW1iZXIiLCJzdHJpbmdzIiwicGFyc2VUYXJnZXRzIiwidGFyZ2V0cyIsInRhcmdldHNBcnJheSIsIml0ZW0iLCJwb3MiLCJzZWxmIiwiZ2V0QW5pbWF0YWJsZXMiLCJwYXJzZWQiLCJub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyIsInR3ZWVuU2V0dGluZ3MiLCJzZXR0aW5ncyIsImlzRnJvbVRvIiwicHJvcEFycmF5IiwidiIsImsiLCJmbGF0dGVuS2V5ZnJhbWVzIiwia2V5ZnJhbWVzIiwicHJvcGVydHlOYW1lcyIsInByb3BlcnRpZXMiLCJuZXdLZXkiLCJnZXRQcm9wZXJ0aWVzIiwidHdlZW5zIiwibm9ybWFsaXplVHdlZW5WYWx1ZXMiLCJ0d2VlbiIsIm5vcm1hbGl6ZVR3ZWVucyIsInByZXZpb3VzVHdlZW4iLCJ0d2VlblZhbHVlIiwidG9Vbml0Iiwib3JpZ2luYWxWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCJmcm9tVW5pdCIsInN0YXJ0IiwiZW5kIiwiaXNQYXRoIiwiaXNDb2xvciIsInNldFByb2dyZXNzVmFsdWUiLCJjc3MiLCJhdHRyaWJ1dGUiLCJvYmplY3QiLCJtYW51YWwiLCJsYXN0Iiwic2V0VGFyZ2V0c1ZhbHVlIiwiYW5pbWF0YWJsZXMiLCJhbmltVHlwZSIsImNyZWF0ZUFuaW1hdGlvbiIsImxhc3RUd2VlbiIsInR5cGUiLCJnZXRBbmltYXRpb25zIiwiZ2V0SW5zdGFuY2VUaW1pbmdzIiwiYW5pbWF0aW9ucyIsImFuaW1MZW5ndGgiLCJnZXRUbE9mZnNldCIsImFuaW0iLCJ0aW1pbmdzIiwiaW5zdGFuY2VJRCIsImNyZWF0ZU5ld0luc3RhbmNlIiwiaW5zdGFuY2VTZXR0aW5ncyIsImNoaWxkcmVuIiwiYWN0aXZlSW5zdGFuY2VzIiwiZW5naW5lIiwicmFmIiwicGxheSIsImlzRG9jdW1lbnRIaWRkZW4iLCJhbmltZSIsInN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdGVwIiwiYWN0aXZlSW5zdGFuY2VzTGVuZ3RoIiwiYWN0aXZlSW5zdGFuY2UiLCJwYXVzZWQiLCJ0aWNrIiwic3BsaWNlIiwidW5kZWZpbmVkIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaW5zdGFuY2UiLCJfb25Eb2N1bWVudFZpc2liaWxpdHkiLCJhZGRFdmVudExpc3RlbmVyIiwiaGlkZGVuIiwic3RhcnRUaW1lIiwibGFzdFRpbWUiLCJub3ciLCJjaGlsZHJlbkxlbmd0aCIsInJlc29sdmUiLCJtYWtlUHJvbWlzZSIsInByb21pc2UiLCJ3aW5kb3ciLCJQcm9taXNlIiwiX3Jlc29sdmUiLCJmaW5pc2hlZCIsInRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uIiwicmV2ZXJzZWQiLCJjaGlsZCIsImFkanVzdFRpbWUiLCJ0aW1lIiwicmVzZXRUaW1lIiwiY3VycmVudFRpbWUiLCJzcGVlZCIsInNlZWtDaGlsZCIsInNlZWsiLCJzeW5jSW5zdGFuY2VDaGlsZHJlbiIsInJldmVyc2VQbGF5YmFjayIsImkkMSIsInNldEFuaW1hdGlvbnNQcm9ncmVzcyIsImluc1RpbWUiLCJhbmltYXRpb25zTGVuZ3RoIiwidHdlZW5MZW5ndGgiLCJlYXNlZCIsImlzTmFOIiwidG9OdW1iZXJzTGVuZ3RoIiwibiIsInRvTnVtYmVyIiwiZnJvbU51bWJlciIsInN0cmluZ3NMZW5ndGgiLCJuJDEiLCJjdXJyZW50VmFsdWUiLCJzZXRDYWxsYmFjayIsImNiIiwicGFzc1Rocm91Z2giLCJjb3VudEl0ZXJhdGlvbiIsInJlbWFpbmluZyIsInNldEluc3RhbmNlUHJvZ3Jlc3MiLCJlbmdpbmVUaW1lIiwiaW5zRHVyYXRpb24iLCJpbnNEZWxheSIsImluc0VuZERlbGF5IiwiYmVnYW4iLCJsb29wQmVnYW4iLCJjaGFuZ2VCZWdhbiIsImNoYW5nZUNvbXBsZXRlZCIsImNvbXBsZXRlZCIsInJlc2V0IiwicGF1c2UiLCJyZXZlcnNlIiwicmVzdGFydCIsInJlbW92ZSIsInJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UiLCJyZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnMiLCJjIiwiY2hpbGRBbmltYXRpb25zIiwicmVtb3ZlVGFyZ2V0c0Zyb21BY3RpdmVJbnN0YW5jZXMiLCJzdGFnZ2VyIiwiZ3JpZCIsImF4aXMiLCJmcm9tSW5kZXgiLCJmcm9tRmlyc3QiLCJmcm9tQ2VudGVyIiwiZnJvbUxhc3QiLCJpc1JhbmdlIiwidmFsMSIsInZhbDIiLCJ2YWx1ZXMiLCJtYXhWYWx1ZSIsImluZGV4IiwiZnJvbVgiLCJmcm9tWSIsImZsb29yIiwidG9YIiwidG9ZIiwiZGlzdGFuY2VYIiwiZGlzdGFuY2VZIiwic3BhY2luZyIsInRpbWVsaW5lIiwidGwiLCJhZGQiLCJpbnN0YW5jZVBhcmFtcyIsInRsSW5kZXgiLCJpbnMiLCJpbnNQYXJhbXMiLCJ0bER1cmF0aW9uIiwidmVyc2lvbiIsInJ1bm5pbmciLCJjb252ZXJ0UHgiLCJyYW5kb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/animejs/lib/anime.es.js\n");

/***/ })

};
;