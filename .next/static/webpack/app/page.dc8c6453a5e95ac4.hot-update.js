"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/home/secondSection/video/videoComponent.js":
/*!***************************************************************!*\
  !*** ./components/home/secondSection/video/videoComponent.js ***!
  \***************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _videoComponent_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./videoComponent.module.css */ \"(app-pages-browser)/./components/home/secondSection/video/videoComponent.module.css\");\n/* harmony import */ var _videoComponent_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_videoComponent_module_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scrolly_video_dist_ScrollyVideo_cjs_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! scrolly-video/dist/ScrollyVideo.cjs.jsx */ \"(app-pages-browser)/./node_modules/scrolly-video/dist/ScrollyVideo.cjs.jsx\");\n/* harmony import */ var scrolly_video_dist_ScrollyVideo_cjs_jsx__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(scrolly_video_dist_ScrollyVideo_cjs_jsx__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst VideoComponent = ()=>{\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    //   useEffect(() => {\n    //     const handleScroll = () => {\n    //       const video = videoRef.current;\n    //       if (video) {\n    //         // The height of the viewport\n    //         const viewportHeight = window.innerHeight;\n    //         // Adjusted scroll position\n    //         const adjustedScrollY = window.scrollY - viewportHeight;\n    //         console.log('adscroll', adjustedScrollY);\n    //         // Check if the adjusted scroll position is positive\n    //         if (adjustedScrollY > 0) {\n    //           // Calculate the fraction of scroll relative to the adjusted position\n    //           const scrollFraction =\n    //             adjustedScrollY / (document.body.scrollHeight - 2 * viewportHeight);\n    //           const videoTime = scrollFraction * video.duration;\n    //           video.currentTime = Math.min(videoTime, video.duration);\n    //         }\n    //       }\n    //     };\n    //     window.addEventListener('scroll', handleScroll);\n    //     return () => {\n    //       window.removeEventListener('scroll', handleScroll);\n    //     };\n    //   }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_videoComponent_module_css__WEBPACK_IMPORTED_MODULE_3___default().videoContainer),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n            ref: videoRef,\n            autoPlay: true,\n            loop: true,\n            muted: true,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                    src: \"/videos/home/secondSection/mockup.mp4\",\n                    type: \"video/mp4\"\n                }, void 0, false, {\n                    fileName: \"/Users/Carlito/Desktop/ozelot/ozelot_repos/technorama_2050_backup/components/home/secondSection/video/videoComponent.js\",\n                    lineNumber: 42,\n                    columnNumber: 9\n                }, undefined),\n                \"Your browser doesn't support HTML5 video.\"\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/Carlito/Desktop/ozelot/ozelot_repos/technorama_2050_backup/components/home/secondSection/video/videoComponent.js\",\n            lineNumber: 41,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/Carlito/Desktop/ozelot/ozelot_repos/technorama_2050_backup/components/home/secondSection/video/videoComponent.js\",\n        lineNumber: 40,\n        columnNumber: 5\n    }, undefined);\n};\n_s(VideoComponent, \"0CLVWOVx+8g0ODBjgEMJWUwEryM=\");\n_c = VideoComponent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (VideoComponent);\nvar _c;\n$RefreshReg$(_c, \"VideoComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaG9tZS9zZWNvbmRTZWN0aW9uL3ZpZGVvL3ZpZGVvQ29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFaUQ7QUFDQTtBQUNrQjtBQUVuRSxNQUFNSyxpQkFBaUI7O0lBQ3JCLE1BQU1DLFdBQVdKLDZDQUFNQSxDQUFDO0lBRXhCLHNCQUFzQjtJQUN0QixtQ0FBbUM7SUFDbkMsd0NBQXdDO0lBQ3hDLHFCQUFxQjtJQUNyQix3Q0FBd0M7SUFDeEMscURBQXFEO0lBRXJELHNDQUFzQztJQUN0QyxtRUFBbUU7SUFDbkUsb0RBQW9EO0lBRXBELCtEQUErRDtJQUMvRCxxQ0FBcUM7SUFDckMsa0ZBQWtGO0lBQ2xGLG1DQUFtQztJQUNuQyxtRkFBbUY7SUFDbkYsK0RBQStEO0lBQy9ELHFFQUFxRTtJQUNyRSxZQUFZO0lBQ1osVUFBVTtJQUNWLFNBQVM7SUFFVCx1REFBdUQ7SUFFdkQscUJBQXFCO0lBQ3JCLDREQUE0RDtJQUM1RCxTQUFTO0lBQ1QsWUFBWTtJQUVaLHFCQUNFLDhEQUFDSztRQUFJQyxXQUFXTCxrRkFBcUI7a0JBQ25DLDRFQUFDTztZQUFNQyxLQUFLTDtZQUFVTSxRQUFRO1lBQUNDLElBQUk7WUFBQ0MsS0FBSzs7OEJBQ3ZDLDhEQUFDQztvQkFBT0MsS0FBSTtvQkFBd0NDLE1BQUs7Ozs7OztnQkFBYzs7Ozs7Ozs7Ozs7O0FBSy9FO0dBeENNWjtLQUFBQTtBQTBDTiwrREFBZUEsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hvbWUvc2Vjb25kU2VjdGlvbi92aWRlby92aWRlb0NvbXBvbmVudC5qcz8zNzJhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3ZpZGVvQ29tcG9uZW50Lm1vZHVsZS5jc3MnO1xuaW1wb3J0IFNjcm9sbHlWaWRlbyBmcm9tICdzY3JvbGx5LXZpZGVvL2Rpc3QvU2Nyb2xseVZpZGVvLmNqcy5qc3gnO1xuXG5jb25zdCBWaWRlb0NvbXBvbmVudCA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xuICAvLyAgICAgY29uc3QgaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAvLyAgICAgICBjb25zdCB2aWRlbyA9IHZpZGVvUmVmLmN1cnJlbnQ7XG4gIC8vICAgICAgIGlmICh2aWRlbykge1xuICAvLyAgICAgICAgIC8vIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gIC8vICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgLy8gICAgICAgICAvLyBBZGp1c3RlZCBzY3JvbGwgcG9zaXRpb25cbiAgLy8gICAgICAgICBjb25zdCBhZGp1c3RlZFNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWSAtIHZpZXdwb3J0SGVpZ2h0O1xuICAvLyAgICAgICAgIGNvbnNvbGUubG9nKCdhZHNjcm9sbCcsIGFkanVzdGVkU2Nyb2xsWSk7XG5cbiAgLy8gICAgICAgICAvLyBDaGVjayBpZiB0aGUgYWRqdXN0ZWQgc2Nyb2xsIHBvc2l0aW9uIGlzIHBvc2l0aXZlXG4gIC8vICAgICAgICAgaWYgKGFkanVzdGVkU2Nyb2xsWSA+IDApIHtcbiAgLy8gICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZnJhY3Rpb24gb2Ygc2Nyb2xsIHJlbGF0aXZlIHRvIHRoZSBhZGp1c3RlZCBwb3NpdGlvblxuICAvLyAgICAgICAgICAgY29uc3Qgc2Nyb2xsRnJhY3Rpb24gPVxuICAvLyAgICAgICAgICAgICBhZGp1c3RlZFNjcm9sbFkgLyAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSAyICogdmlld3BvcnRIZWlnaHQpO1xuICAvLyAgICAgICAgICAgY29uc3QgdmlkZW9UaW1lID0gc2Nyb2xsRnJhY3Rpb24gKiB2aWRlby5kdXJhdGlvbjtcbiAgLy8gICAgICAgICAgIHZpZGVvLmN1cnJlbnRUaW1lID0gTWF0aC5taW4odmlkZW9UaW1lLCB2aWRlby5kdXJhdGlvbik7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9O1xuXG4gIC8vICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcblxuICAvLyAgICAgcmV0dXJuICgpID0+IHtcbiAgLy8gICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XG4gIC8vICAgICB9O1xuICAvLyAgIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmlkZW9Db250YWluZXJ9PlxuICAgICAgPHZpZGVvIHJlZj17dmlkZW9SZWZ9IGF1dG9QbGF5IGxvb3AgbXV0ZWQ+XG4gICAgICAgIDxzb3VyY2Ugc3JjPVwiL3ZpZGVvcy9ob21lL3NlY29uZFNlY3Rpb24vbW9ja3VwLm1wNFwiIHR5cGU9XCJ2aWRlby9tcDRcIiAvPlxuICAgICAgICBZb3VyIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEhUTUw1IHZpZGVvLlxuICAgICAgPC92aWRlbz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvQ29tcG9uZW50O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwic3R5bGVzIiwiU2Nyb2xseVZpZGVvIiwiVmlkZW9Db21wb25lbnQiLCJ2aWRlb1JlZiIsImRpdiIsImNsYXNzTmFtZSIsInZpZGVvQ29udGFpbmVyIiwidmlkZW8iLCJyZWYiLCJhdXRvUGxheSIsImxvb3AiLCJtdXRlZCIsInNvdXJjZSIsInNyYyIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/home/secondSection/video/videoComponent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/scrolly-video/dist/ScrollyVideo.cjs.jsx":
/*!**************************************************************!*\
  !*** ./node_modules/scrolly-video/dist/ScrollyVideo.cjs.jsx ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\nvar uaParser = {exports: {}};\n\n(function (module, exports) {\n/////////////////////////////////////////////////////////////////////////////////\n/* UAParser.js v1.0.33\n   Copyright © 2012-2021 Faisal Salman <f@faisalman.com>\n   MIT License *//*\n   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.\n   Supports browser & node.js environment. \n   Demo   : https://faisalman.github.io/ua-parser-js\n   Source : https://github.com/faisalman/ua-parser-js */\n/////////////////////////////////////////////////////////////////////////////////\n\n(function (window, undefined$1) {\n\n    //////////////\n    // Constants\n    /////////////\n\n\n    var LIBVERSION  = '1.0.33',\n        EMPTY       = '',\n        UNKNOWN     = '?',\n        FUNC_TYPE   = 'function',\n        UNDEF_TYPE  = 'undefined',\n        OBJ_TYPE    = 'object',\n        STR_TYPE    = 'string',\n        MAJOR       = 'major',\n        MODEL       = 'model',\n        NAME        = 'name',\n        TYPE        = 'type',\n        VENDOR      = 'vendor',\n        VERSION     = 'version',\n        ARCHITECTURE= 'architecture',\n        CONSOLE     = 'console',\n        MOBILE      = 'mobile',\n        TABLET      = 'tablet',\n        SMARTTV     = 'smarttv',\n        WEARABLE    = 'wearable',\n        EMBEDDED    = 'embedded',\n        UA_MAX_LENGTH = 350;\n\n    var AMAZON  = 'Amazon',\n        APPLE   = 'Apple',\n        ASUS    = 'ASUS',\n        BLACKBERRY = 'BlackBerry',\n        BROWSER = 'Browser',\n        CHROME  = 'Chrome',\n        EDGE    = 'Edge',\n        FIREFOX = 'Firefox',\n        GOOGLE  = 'Google',\n        HUAWEI  = 'Huawei',\n        LG      = 'LG',\n        MICROSOFT = 'Microsoft',\n        MOTOROLA  = 'Motorola',\n        OPERA   = 'Opera',\n        SAMSUNG = 'Samsung',\n        SHARP   = 'Sharp',\n        SONY    = 'Sony',\n        XIAOMI  = 'Xiaomi',\n        ZEBRA   = 'Zebra',\n        FACEBOOK   = 'Facebook';\n\n    ///////////\n    // Helper\n    //////////\n\n    var extend = function (regexes, extensions) {\n            var mergedRegexes = {};\n            for (var i in regexes) {\n                if (extensions[i] && extensions[i].length % 2 === 0) {\n                    mergedRegexes[i] = extensions[i].concat(regexes[i]);\n                } else {\n                    mergedRegexes[i] = regexes[i];\n                }\n            }\n            return mergedRegexes;\n        },\n        enumerize = function (arr) {\n            var enums = {};\n            for (var i=0; i<arr.length; i++) {\n                enums[arr[i].toUpperCase()] = arr[i];\n            }\n            return enums;\n        },\n        has = function (str1, str2) {\n            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;\n        },\n        lowerize = function (str) {\n            return str.toLowerCase();\n        },\n        majorize = function (version) {\n            return typeof(version) === STR_TYPE ? version.replace(/[^\\d\\.]/g, EMPTY).split('.')[0] : undefined$1;\n        },\n        trim = function (str, len) {\n            if (typeof(str) === STR_TYPE) {\n                str = str.replace(/^\\s\\s*/, EMPTY);\n                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);\n            }\n    };\n\n    ///////////////\n    // Map helper\n    //////////////\n\n    var rgxMapper = function (ua, arrays) {\n\n            var i = 0, j, k, p, q, matches, match;\n\n            // loop through all regexes maps\n            while (i < arrays.length && !matches) {\n\n                var regex = arrays[i],       // even sequence (0,2,4,..)\n                    props = arrays[i + 1];   // odd sequence (1,3,5,..)\n                j = k = 0;\n\n                // try matching uastring with regexes\n                while (j < regex.length && !matches) {\n\n                    matches = regex[j++].exec(ua);\n\n                    if (!!matches) {\n                        for (p = 0; p < props.length; p++) {\n                            match = matches[++k];\n                            q = props[p];\n                            // check if given property is actually array\n                            if (typeof q === OBJ_TYPE && q.length > 0) {\n                                if (q.length === 2) {\n                                    if (typeof q[1] == FUNC_TYPE) {\n                                        // assign modified match\n                                        this[q[0]] = q[1].call(this, match);\n                                    } else {\n                                        // assign given value, ignore regex match\n                                        this[q[0]] = q[1];\n                                    }\n                                } else if (q.length === 3) {\n                                    // check whether function or regex\n                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                                        // call function (usually string mapper)\n                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;\n                                    } else {\n                                        // sanitize match using given regex\n                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;\n                                    }\n                                } else if (q.length === 4) {\n                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;\n                                }\n                            } else {\n                                this[q] = match ? match : undefined$1;\n                            }\n                        }\n                    }\n                }\n                i += 2;\n            }\n        },\n\n        strMapper = function (str, map) {\n\n            for (var i in map) {\n                // check if current value is array\n                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n                    for (var j = 0; j < map[i].length; j++) {\n                        if (has(map[i][j], str)) {\n                            return (i === UNKNOWN) ? undefined$1 : i;\n                        }\n                    }\n                } else if (has(map[i], str)) {\n                    return (i === UNKNOWN) ? undefined$1 : i;\n                }\n            }\n            return str;\n    };\n\n    ///////////////\n    // String map\n    //////////////\n\n    // Safari < 3.0\n    var oldSafariMap = {\n            '1.0'   : '/8',\n            '1.2'   : '/1',\n            '1.3'   : '/3',\n            '2.0'   : '/412',\n            '2.0.2' : '/416',\n            '2.0.3' : '/417',\n            '2.0.4' : '/419',\n            '?'     : '/'\n        },\n        windowsVersionMap = {\n            'ME'        : '4.90',\n            'NT 3.11'   : 'NT3.51',\n            'NT 4.0'    : 'NT4.0',\n            '2000'      : 'NT 5.0',\n            'XP'        : ['NT 5.1', 'NT 5.2'],\n            'Vista'     : 'NT 6.0',\n            '7'         : 'NT 6.1',\n            '8'         : 'NT 6.2',\n            '8.1'       : 'NT 6.3',\n            '10'        : ['NT 6.4', 'NT 10.0'],\n            'RT'        : 'ARM'\n    };\n\n    //////////////\n    // Regex map\n    /////////////\n\n    var regexes = {\n\n        browser : [[\n\n            /\\b(?:crmo|crios)\\/([\\w\\.]+)/i                                      // Chrome for Android/iOS\n            ], [VERSION, [NAME, 'Chrome']], [\n            /edg(?:e|ios|a)?\\/([\\w\\.]+)/i                                       // Microsoft Edge\n            ], [VERSION, [NAME, 'Edge']], [\n\n            // Presto based\n            /(opera mini)\\/([-\\w\\.]+)/i,                                        // Opera Mini\n            /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,                 // Opera Mobi/Tablet\n            /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i                           // Opera\n            ], [NAME, VERSION], [\n            /opios[\\/ ]+([\\w\\.]+)/i                                             // Opera mini on iphone >= 8.0\n            ], [VERSION, [NAME, OPERA+' Mini']], [\n            /\\bopr\\/([\\w\\.]+)/i                                                 // Opera Webkit\n            ], [VERSION, [NAME, OPERA]], [\n\n            // Mixed\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i,      // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n            // Trident based\n            /(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i,               // Avant/IEMobile/SlimBrowser\n            /(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i,                                  // Baidu Browser\n            /(?:ms|\\()(ie) ([\\w\\.]+)/i,                                         // Internet Explorer\n\n            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i,\n                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ\n            /(weibo)__([\\d\\.]+)/i                                               // Weibo\n            ], [NAME, VERSION], [\n            /(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i                 // UCBrowser\n            ], [VERSION, [NAME, 'UC'+BROWSER]], [\n            /microm.+\\bqbcore\\/([\\w\\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser\n            /\\bqbcore\\/([\\w\\.]+).+microm/i\n            ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [\n            /micromessenger\\/([\\w\\.]+)/i                                        // WeChat\n            ], [VERSION, [NAME, 'WeChat']], [\n            /konqueror\\/([\\w\\.]+)/i                                             // Konqueror\n            ], [VERSION, [NAME, 'Konqueror']], [\n            /trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i                       // IE11\n            ], [VERSION, [NAME, 'IE']], [\n            /yabrowser\\/([\\w\\.]+)/i                                             // Yandex\n            ], [VERSION, [NAME, 'Yandex']], [\n            /(avast|avg)\\/([\\w\\.]+)/i                                           // Avast/AVG Secure Browser\n            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [\n            /\\bfocus\\/([\\w\\.]+)/i                                               // Firefox Focus\n            ], [VERSION, [NAME, FIREFOX+' Focus']], [\n            /\\bopt\\/([\\w\\.]+)/i                                                 // Opera Touch\n            ], [VERSION, [NAME, OPERA+' Touch']], [\n            /coc_coc\\w+\\/([\\w\\.]+)/i                                            // Coc Coc Browser\n            ], [VERSION, [NAME, 'Coc Coc']], [\n            /dolfin\\/([\\w\\.]+)/i                                                // Dolphin\n            ], [VERSION, [NAME, 'Dolphin']], [\n            /coast\\/([\\w\\.]+)/i                                                 // Opera Coast\n            ], [VERSION, [NAME, OPERA+' Coast']], [\n            /miuibrowser\\/([\\w\\.]+)/i                                           // MIUI Browser\n            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [\n            /fxios\\/([-\\w\\.]+)/i                                                // Firefox for iOS\n            ], [VERSION, [NAME, FIREFOX]], [\n            /\\bqihu|(qi?ho?o?|360)browser/i                                     // 360\n            ], [[NAME, '360 '+BROWSER]], [\n            /(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i\n            ], [[NAME, /(.+)/, '$1 '+BROWSER], VERSION], [                      // Oculus/Samsung/Sailfish/Huawei Browser\n            /(comodo_dragon)\\/([\\w\\.]+)/i                                       // Comodo Dragon\n            ], [[NAME, /_/g, ' '], VERSION], [\n            /(electron)\\/([\\w\\.]+) safari/i,                                    // Electron-based App\n            /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,                   // Tesla\n            /m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i            // QQBrowser/Baidu App/2345 Browser\n            ], [NAME, VERSION], [\n            /(metasr)[\\/ ]?([\\w\\.]+)/i,                                         // SouGouBrowser\n            /(lbbrowser)/i,                                                     // LieBao Browser\n            /\\[(linkedin)app\\]/i                                                // LinkedIn App for iOS & Android\n            ], [NAME], [\n\n            // WebView\n            /((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i       // Facebook App for iOS & Android\n            ], [[NAME, FACEBOOK], VERSION], [\n            /safari (line)\\/([\\w\\.]+)/i,                                        // Line App for iOS\n            /\\b(line)\\/([\\w\\.]+)\\/iab/i,                                        // Line App for Android\n            /(chromium|instagram)[\\/ ]([-\\w\\.]+)/i                              // Chromium/Instagram\n            ], [NAME, VERSION], [\n            /\\bgsa\\/([\\w\\.]+) .*safari\\//i                                      // Google Search Appliance on iOS\n            ], [VERSION, [NAME, 'GSA']], [\n\n            /headlesschrome(?:\\/([\\w\\.]+)| )/i                                  // Chrome Headless\n            ], [VERSION, [NAME, CHROME+' Headless']], [\n\n            / wv\\).+(chrome)\\/([\\w\\.]+)/i                                       // Chrome WebView\n            ], [[NAME, CHROME+' WebView'], VERSION], [\n\n            /droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i           // Android Browser\n            ], [VERSION, [NAME, 'Android '+BROWSER]], [\n\n            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia\n            ], [NAME, VERSION], [\n\n            /version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i                      // Mobile Safari\n            ], [VERSION, [NAME, 'Mobile Safari']], [\n            /version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i                // Safari & Safari Mobile\n            ], [VERSION, NAME], [\n            /webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i                      // Safari < 3.0\n            ], [NAME, [VERSION, strMapper, oldSafariMap]], [\n\n            /(webkit|khtml)\\/([\\w\\.]+)/i\n            ], [NAME, VERSION], [\n\n            // Gecko based\n            /(navigator|netscape\\d?)\\/([-\\w\\.]+)/i                              // Netscape\n            ], [[NAME, 'Netscape'], VERSION], [\n            /mobile vr; rv:([\\w\\.]+)\\).+firefox/i                               // Firefox Reality\n            ], [VERSION, [NAME, FIREFOX+' Reality']], [\n            /ekiohf.+(flow)\\/([\\w\\.]+)/i,                                       // Flow\n            /(swiftfox)/i,                                                      // Swiftfox\n            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i,\n                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar\n            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,\n                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n            /(firefox)\\/([\\w\\.]+)/i,                                            // Other Firefox-based\n            /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,                         // Mozilla\n\n            // Other\n            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,\n                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser\n            /(links) \\(([\\w\\.]+)/i                                              // Links\n            ], [NAME, VERSION], [\n            \n            /(cobalt)\\/([\\w\\.]+)/i                                              // Cobalt\n            ], [NAME, [VERSION, /master.|lts./, \"\"]]\n        ],\n\n        cpu : [[\n\n            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i                     // AMD64 (x64)\n            ], [[ARCHITECTURE, 'amd64']], [\n\n            /(ia32(?=;))/i                                                      // IA32 (quicktime)\n            ], [[ARCHITECTURE, lowerize]], [\n\n            /((?:i[346]|x)86)[;\\)]/i                                            // IA32 (x86)\n            ], [[ARCHITECTURE, 'ia32']], [\n\n            /\\b(aarch64|arm(v?8e?l?|_?64))\\b/i                                 // ARM64\n            ], [[ARCHITECTURE, 'arm64']], [\n\n            /\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i                                   // ARMHF\n            ], [[ARCHITECTURE, 'armhf']], [\n\n            // PocketPC mistakenly identified as PowerPC\n            /windows (ce|mobile); ppc;/i\n            ], [[ARCHITECTURE, 'arm']], [\n\n            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i                            // PowerPC\n            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [\n\n            /(sun4\\w)[;\\)]/i                                                    // SPARC\n            ], [[ARCHITECTURE, 'sparc']], [\n\n            /((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i\n                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n            ], [[ARCHITECTURE, lowerize]]\n        ],\n\n        device : [[\n\n            //////////////////////////\n            // MOBILES & TABLETS\n            // Ordered by popularity\n            /////////////////////////\n\n            // Samsung\n            /\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [\n            /\\b((?:s[cgp]h|gt|sm)-\\w+|galaxy nexus)/i,\n            /samsung[- ]([-\\w]+)/i,\n            /sec-(sgh\\w+)/i\n            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [\n\n            // Apple\n            /\\((ip(?:hone|od)[\\w ]*);/i                                         // iPod/iPhone\n            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [\n            /\\((ipad);[-\\w\\),; ]+apple/i,                                       // iPad\n            /applecoremedia\\/[\\w\\.]+ \\((ipad)/i,\n            /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i\n            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [\n            /(macintosh);/i\n            ], [MODEL, [VENDOR, APPLE]], [\n\n            // Huawei\n            /\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i\n            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [\n            /(?:huawei|honor)([-\\w ]+)[;\\)]/i,\n            /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i\n            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [\n\n            // Xiaomi\n            /\\b(poco[\\w ]+)(?: bui|\\))/i,                                       // Xiaomi POCO\n            /\\b; (\\w+) build\\/hm\\1/i,                                           // Xiaomi Hongmi 'numeric' models\n            /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,                             // Xiaomi Hongmi\n            /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,                   // Xiaomi Redmi\n            /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i // Xiaomi Mi\n            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [\n            /\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i                        // Mi Pad tablets\n            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [\n\n            // OPPO\n            /; (\\w+) bui.+ oppo/i,\n            /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i\n            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [\n\n            // Vivo\n            /vivo (\\w+)(?: bui|\\))/i,\n            /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i\n            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [\n\n            // Realme\n            /\\b(rmx[12]\\d{3})(?: bui|;|\\))/i\n            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [\n\n            // Motorola\n            /\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,\n            /\\bmot(?:orola)?[- ](\\w*)/i,\n            /((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [\n            /\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i\n            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [\n\n            // LG\n            /((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i\n            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [\n            /(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i,\n            /\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i,\n            /\\blg-?([\\d\\w]+) bui/i\n            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [\n\n            // Lenovo\n            /(ideatab[-\\w ]+)/i,\n            /lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i\n            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [\n\n            // Nokia\n            /(?:maemo|nokia).*(n900|lumia \\d+)/i,\n            /nokia[-_ ]?([-\\w\\.]*)/i\n            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [\n\n            // Google\n            /(pixel c)\\b/i                                                      // Google Pixel C\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [\n            /droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i                         // Google Pixel\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [\n\n            // Sony\n            /droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [\n            /sony tablet [ps]/i,\n            /\\b(?:sony)?sgp\\w+(?: bui|\\))/i\n            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [\n\n            // OnePlus\n            / (kb2005|in20[12]5|be20[12][59])\\b/i,\n            /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i\n            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [\n\n            // Amazon\n            /(alexa)webm/i,\n            /(kf[a-z]{2}wi)( bui|\\))/i,                                         // Kindle Fire without Silk\n            /(kf[a-z]+)( bui|\\)).+silk\\//i                                      // Kindle Fire HD\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [\n            /((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i                     // Fire Phone\n            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [\n\n            // BlackBerry\n            /(playbook);[-\\w\\),; ]+(rim)/i                                      // BlackBerry PlayBook\n            ], [MODEL, VENDOR, [TYPE, TABLET]], [\n            /\\b((?:bb[a-f]|st[hv])100-\\d)/i,\n            /\\(bb10; (\\w+)/i                                                    // BlackBerry 10\n            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [\n\n            // Asus\n            /(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i\n            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [\n            / (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i\n            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [\n\n            // HTC\n            /(nexus 9)/i                                                        // HTC Nexus 9\n            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [\n            /(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,                         // HTC\n\n            // ZTE\n            /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,\n            /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [\n\n            // Acer\n            /droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i\n            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [\n\n            // Meizu\n            /droid.+; (m[1-5] note) bui/i,\n            /\\bmz-([-\\w]{2,})/i\n            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [\n\n            // Sharp\n            /\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i\n            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [\n\n            // MIXED\n            /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i,\n                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron\n            /(hp) ([\\w ]+\\w)/i,                                                 // HP iPAQ\n            /(asus)-?(\\w+)/i,                                                   // Asus\n            /(microsoft); (lumia[\\w ]+)/i,                                      // Microsoft Lumia\n            /(lenovo)[-_ ]?([-\\w]+)/i,                                          // Lenovo\n            /(jolla)/i,                                                         // Jolla\n            /(oppo) ?([\\w ]+) bui/i                                             // OPPO\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /(archos) (gamepad2?)/i,                                            // Archos\n            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(nook)[\\w ]+build\\/(\\w+)/i,                                        // Nook\n            /(dell) (strea[kpr\\d ]*[\\dko])/i,                                   // Dell Streak\n            /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,                                  // Le Pan Tablets\n            /(trinity)[- ]*(t\\d{3}) bui/i,                                      // Trinity Tablets\n            /(gigaset)[- ]+(q\\w{1,9}) bui/i,                                    // Gigaset Tablets\n            /(vodafone) ([\\w ]+)(?:\\)| bui)/i                                   // Vodafone\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /(surface duo)/i                                                    // Surface Duo\n            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [\n            /droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i                                 // Fairphone\n            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [\n            /(u304aa)/i                                                         // AT&T\n            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [\n            /\\bsie-(\\w*)/i                                                      // Siemens\n            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [\n            /\\b(rct\\w+) b/i                                                     // RCA Tablets\n            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [\n            /\\b(venue[\\d ]{2,7}) b/i                                            // Dell Venue Tablets\n            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [\n            /\\b(q(?:mv|ta)\\w+) b/i                                              // Verizon Tablet\n            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [\n            /\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i                       // Barnes & Noble Tablet\n            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [\n            /\\b(tm\\d{3}\\w+) b/i\n            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [\n            /\\b(k88) b/i                                                        // ZTE K Series Tablet\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [\n            /\\b(nx\\d{3}j) b/i                                                   // ZTE Nubia\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [\n            /\\b(gen\\d{3}) b.+49h/i                                              // Swiss GEN Mobile\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [\n            /\\b(zur\\d{3}) b/i                                                   // Swiss ZUR Tablet\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [\n            /\\b((zeki)?tb.*\\b) b/i                                              // Zeki Tablets\n            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [\n            /\\b([yr]\\d{2}) b/i,\n            /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i                                // Dragon Touch Tablet\n            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [\n            /\\b(ns-?\\w{0,9}) b/i                                                // Insignia Tablets\n            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [\n            /\\b((nxa|next)-?\\w{0,9}) b/i                                        // NextBook Tablets\n            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [\n            /\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones\n            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [\n            /\\b(lvtel\\-)?(v1[12]) b/i                                           // LvTel Phones\n            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [\n            /\\b(ph-1) /i                                                        // Essential PH-1\n            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [\n            /\\b(v(100md|700na|7011|917g).*\\b) b/i                               // Envizen Tablets\n            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [\n            /\\b(trio[-\\w\\. ]+) b/i                                              // MachSpeed Tablets\n            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [\n            /\\btu_(1491) b/i                                                    // Rotor Tablets\n            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [\n            /(shield[\\w ]+) b/i                                                 // Nvidia Shield Tablets\n            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [\n            /(sprint) (\\w+)/i                                                   // Sprint Phones\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n            /(kin\\.[onetw]{3})/i                                                // Microsoft Kin\n            ], [[MODEL, /\\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [\n            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i             // Zebra\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [\n            /droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [\n\n            ///////////////////\n            // CONSOLES\n            ///////////////////\n\n            /(ouya)/i,                                                          // Ouya\n            /(nintendo) ([wids3utch]+)/i                                        // Nintendo\n            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n            /droid.+; (shield) bui/i                                            // Nvidia\n            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [\n            /(playstation [345portablevi]+)/i                                   // Playstation\n            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [\n            /\\b(xbox(?: one)?(?!; xbox))[\\); ]/i                                // Microsoft Xbox\n            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [\n\n            ///////////////////\n            // SMARTTVS\n            ///////////////////\n\n            /smart-tv.+(samsung)/i                                              // Samsung\n            ], [VENDOR, [TYPE, SMARTTV]], [\n            /hbbtv.+maple;(\\d+)/i\n            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [\n            /(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i        // LG SmartTV\n            ], [[VENDOR, LG], [TYPE, SMARTTV]], [\n            /(apple) ?tv/i                                                      // Apple TV\n            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [\n            /crkey/i                                                            // Google Chromecast\n            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [\n            /droid.+aft(\\w)( bui|\\))/i                                          // Fire TV\n            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [\n            /\\(dtv[\\);].+(aquos)/i,\n            /(aquos-tv[\\w ]+)\\)/i                                               // Sharp\n            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[\n            /(bravia[\\w ]+)( bui|\\))/i                                              // Sony\n            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [\n            /(mitv-\\w{5}) bui/i                                                 // Xiaomi\n            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [\n            /\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,                          // Roku\n            /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w ]*; *(\\w[^;]*);([^;]*)/i               // HbbTV devices\n            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [\n            /\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i                   // SmartTV from Unidentified Vendors\n            ], [[TYPE, SMARTTV]], [\n\n            ///////////////////\n            // WEARABLES\n            ///////////////////\n\n            /((pebble))app/i                                                    // Pebble\n            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n            /droid.+; (glass) \\d/i                                              // Google Glass\n            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [\n            /droid.+; (wt63?0{2,3})\\)/i\n            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [\n            /(quest( 2)?)/i                                                     // Oculus Quest\n            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [\n\n            ///////////////////\n            // EMBEDDED\n            ///////////////////\n\n            /(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i                              // Tesla\n            ], [VENDOR, [TYPE, EMBEDDED]], [\n\n            ////////////////////\n            // MIXED (GENERIC)\n            ///////////////////\n\n            /droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i           // Android Phones from Unidentified Vendors\n            ], [MODEL, [TYPE, MOBILE]], [\n            /droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors\n            ], [MODEL, [TYPE, TABLET]], [\n            /\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i                      // Unidentifiable Tablet\n            ], [[TYPE, TABLET]], [\n            /(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile\n            ], [[TYPE, MOBILE]], [\n            /(android[-\\w\\. ]{0,9});.+buil/i                                    // Generic Android Device\n            ], [MODEL, [VENDOR, 'Generic']]\n        ],\n\n        engine : [[\n\n            /windows.+ edge\\/([\\w\\.]+)/i                                       // EdgeHTML\n            ], [VERSION, [NAME, EDGE+'HTML']], [\n\n            /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i                         // Blink\n            ], [VERSION, [NAME, 'Blink']], [\n\n            /(presto)\\/([\\w\\.]+)/i,                                             // Presto\n            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna\n            /ekioh(flow)\\/([\\w\\.]+)/i,                                          // Flow\n            /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,                           // KHTML/Tasman/Links\n            /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i                                       // iCab\n            ], [NAME, VERSION], [\n\n            /rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i                                     // Gecko\n            ], [VERSION, NAME]\n        ],\n\n        os : [[\n\n            // Windows\n            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)\n            ], [NAME, VERSION], [\n            /(windows) nt 6\\.2; (arm)/i,                                        // Windows RT\n            /(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i,            // Windows Phone\n            /(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i\n            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [\n            /(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i\n            ], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [\n\n            // iOS/macOS\n            /ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i,              // iOS\n            /cfnetwork\\/.+darwin/i\n            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [\n            /(mac os x) ?([\\w\\. ]*)/i,\n            /(macintosh|mac_powerpc\\b)(?!.+haiku)/i                             // Mac OS\n            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [\n\n            // Mobile OSes\n            /droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i                    // Android-x86/HarmonyOS\n            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS\n            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i,\n            /(blackberry)\\w*\\/([\\w\\.]*)/i,                                      // Blackberry\n            /(tizen|kaios)[\\/ ]([\\w\\.]+)/i,                                     // Tizen/KaiOS\n            /\\((series40);/i                                                    // Series 40\n            ], [NAME, VERSION], [\n            /\\(bb(10);/i                                                        // BlackBerry 10\n            ], [VERSION, [NAME, BLACKBERRY]], [\n            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i         // Symbian\n            ], [VERSION, [NAME, 'Symbian']], [\n            /mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i // Firefox OS\n            ], [VERSION, [NAME, FIREFOX+' OS']], [\n            /web0s;.+rt(tv)/i,\n            /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i                              // WebOS\n            ], [VERSION, [NAME, 'webOS']], [\n\n            // Google Chromecast\n            /crkey\\/([\\d\\.]+)/i                                                 // Google Chromecast\n            ], [VERSION, [NAME, CHROME+'cast']], [\n            /(cros) [\\w]+ ([\\w\\.]+\\w)/i                                         // Chromium OS\n            ], [[NAME, 'Chromium OS'], VERSION],[\n\n            // Console\n            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation\n            /(xbox); +xbox ([^\\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)\n\n            // Other\n            /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,                            // Joli/Palm\n            /(mint)[\\/\\(\\) ]?(\\w*)/i,                                           // Mint\n            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux\n            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,\n                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire\n            /(hurd|linux) ?([\\w\\.]*)/i,                                         // Hurd/Linux\n            /(gnu) ?([\\w\\.]*)/i,                                                // GNU\n            /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly\n            /(haiku) (\\w+)/i                                                    // Haiku\n            ], [NAME, VERSION], [\n            /(sunos) ?([\\w\\.\\d]*)/i                                             // Solaris\n            ], [[NAME, 'Solaris'], VERSION], [\n            /((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,                              // Solaris\n            /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,                                  // AIX\n            /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX\n            /(unix) ?([\\w\\.]*)/i                                                // UNIX\n            ], [NAME, VERSION]\n        ]\n    };\n\n    /////////////////\n    // Constructor\n    ////////////////\n\n    var UAParser = function (ua, extensions) {\n\n        if (typeof ua === OBJ_TYPE) {\n            extensions = ua;\n            ua = undefined$1;\n        }\n\n        if (!(this instanceof UAParser)) {\n            return new UAParser(ua, extensions).getResult();\n        }\n\n        var _ua = ua || ((typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);\n        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;\n\n        this.getBrowser = function () {\n            var _browser = {};\n            _browser[NAME] = undefined$1;\n            _browser[VERSION] = undefined$1;\n            rgxMapper.call(_browser, _ua, _rgxmap.browser);\n            _browser.major = majorize(_browser.version);\n            return _browser;\n        };\n        this.getCPU = function () {\n            var _cpu = {};\n            _cpu[ARCHITECTURE] = undefined$1;\n            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);\n            return _cpu;\n        };\n        this.getDevice = function () {\n            var _device = {};\n            _device[VENDOR] = undefined$1;\n            _device[MODEL] = undefined$1;\n            _device[TYPE] = undefined$1;\n            rgxMapper.call(_device, _ua, _rgxmap.device);\n            return _device;\n        };\n        this.getEngine = function () {\n            var _engine = {};\n            _engine[NAME] = undefined$1;\n            _engine[VERSION] = undefined$1;\n            rgxMapper.call(_engine, _ua, _rgxmap.engine);\n            return _engine;\n        };\n        this.getOS = function () {\n            var _os = {};\n            _os[NAME] = undefined$1;\n            _os[VERSION] = undefined$1;\n            rgxMapper.call(_os, _ua, _rgxmap.os);\n            return _os;\n        };\n        this.getResult = function () {\n            return {\n                ua      : this.getUA(),\n                browser : this.getBrowser(),\n                engine  : this.getEngine(),\n                os      : this.getOS(),\n                device  : this.getDevice(),\n                cpu     : this.getCPU()\n            };\n        };\n        this.getUA = function () {\n            return _ua;\n        };\n        this.setUA = function (ua) {\n            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;\n            return this;\n        };\n        this.setUA(_ua);\n        return this;\n    };\n\n    UAParser.VERSION = LIBVERSION;\n    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);\n    UAParser.CPU = enumerize([ARCHITECTURE]);\n    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);\n    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);\n\n    ///////////\n    // Export\n    //////////\n\n    // check js environment\n    {\n        // nodejs env\n        if (module.exports) {\n            exports = module.exports = UAParser;\n        }\n        exports.UAParser = UAParser;\n    }\n\n    // jQuery/Zepto specific (optional)\n    // Note:\n    //   In AMD env the global scope should be kept clean, but jQuery is an exception.\n    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,\n    //   and we should catch that.\n    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);\n    if ($ && !$.ua) {\n        var parser = new UAParser();\n        $.ua = parser.getResult();\n        $.ua.get = function () {\n            return parser.getUA();\n        };\n        $.ua.set = function (ua) {\n            parser.setUA(ua);\n            var result = parser.getResult();\n            for (var prop in result) {\n                $.ua[prop] = result[prop];\n            }\n        };\n    }\n\n})(typeof window === 'object' ? window : commonjsGlobal);\n}(uaParser, uaParser.exports));\n\nvar UAParser = uaParser.exports;\n\nvar mp4box_all = {};\n\n(function (exports) {\n// file:src/log.js\n/* \n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar Log = (function (){\n\t\tvar start = new Date();\n\t\tvar LOG_LEVEL_ERROR \t= 4;\n\t\tvar LOG_LEVEL_WARNING \t= 3;\n\t\tvar LOG_LEVEL_INFO \t\t= 2;\n\t\tvar LOG_LEVEL_DEBUG\t\t= 1;\n\t\tvar log_level = LOG_LEVEL_ERROR;\n\t\tvar logObject = {\n\t\t\tsetLogLevel : function(level) {\n\t\t\t\tif (level == this.debug) log_level = LOG_LEVEL_DEBUG;\n\t\t\t\telse if (level == this.info) log_level = LOG_LEVEL_INFO;\n\t\t\t\telse if (level == this.warn) log_level = LOG_LEVEL_WARNING;\n\t\t\t\telse if (level == this.error) log_level = LOG_LEVEL_ERROR;\n\t\t\t\telse log_level = LOG_LEVEL_ERROR;\n\t\t\t},\n\t\t\tdebug : function(module, msg) {\n\t\t\t\tif (console.debug === undefined) {\n\t\t\t\t\tconsole.debug = console.log;\n\t\t\t\t}\n\t\t\t\tif (LOG_LEVEL_DEBUG >= log_level) {\n\t\t\t\t\tconsole.debug(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t},\n\t\t\tlog : function(module, msg) {\n\t\t\t\tthis.debug(module.msg);\n\t\t\t},\n\t\t\tinfo : function(module, msg) {\n\t\t\t\tif (LOG_LEVEL_INFO >= log_level) {\n\t\t\t\t\tconsole.info(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t},\n\t\t\twarn : function(module, msg) {\n\t\t\t\tif (LOG_LEVEL_WARNING >= log_level) {\n\t\t\t\t\tconsole.warn(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t},\n\t\t\terror : function(module, msg) {\n\t\t\t\tif (LOG_LEVEL_ERROR >= log_level) {\n\t\t\t\t\tconsole.error(\"[\"+Log.getDurationString(new Date()-start,1000)+\"]\",\"[\"+module+\"]\",msg);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn logObject;\n\t})();\n\t\n/* Helper function to print a duration value in the form H:MM:SS.MS */\nLog.getDurationString = function(duration, _timescale) {\n\tvar neg;\n\t/* Helper function to print a number on a fixed number of digits */\n\tfunction pad(number, length) {\n\t\tvar str = '' + number;\n\t\tvar a = str.split('.');\t\t\n\t\twhile (a[0].length < length) {\n\t\t\ta[0] = '0' + a[0];\n\t\t}\n\t\treturn a.join('.');\n\t}\n\tif (duration < 0) {\n\t\tneg = true;\n\t\tduration = -duration;\n\t} else {\n\t\tneg = false;\t\n\t}\n\tvar timescale = _timescale || 1;\n\tvar duration_sec = duration/timescale;\n\tvar hours = Math.floor(duration_sec/3600);\n\tduration_sec -= hours * 3600;\n\tvar minutes = Math.floor(duration_sec/60);\n\tduration_sec -= minutes * 60;\t\t\n\tvar msec = duration_sec*1000;\n\tduration_sec = Math.floor(duration_sec);\n\tmsec -= duration_sec*1000;\n\tmsec = Math.floor(msec);\n\treturn (neg ? \"-\": \"\")+hours+\":\"+pad(minutes,2)+\":\"+pad(duration_sec,2)+\".\"+pad(msec,3);\n};\n\t\n/* Helper function to stringify HTML5 TimeRanges objects */\t\nLog.printRanges = function(ranges) {\n\tvar length = ranges.length;\n\tif (length > 0) {\n\t\tvar str = \"\";\n\t\tfor (var i = 0; i < length; i++) {\n\t\t  if (i > 0) str += \",\";\n\t\t  str += \"[\"+Log.getDurationString(ranges.start(i))+ \",\"+Log.getDurationString(ranges.end(i))+\"]\";\n\t\t}\n\t\treturn str;\n\t} else {\n\t\treturn \"(empty)\";\n\t}\n};\n\n{\n\texports.Log = Log;\n}\n// file:src/stream.js\nvar MP4BoxStream = function(arrayBuffer) {\n  if (arrayBuffer instanceof ArrayBuffer) {\n    this.buffer = arrayBuffer;\n    this.dataview = new DataView(arrayBuffer);\n  } else {\n    throw (\"Needs an array buffer\");\n  }\n  this.position = 0;\n};\n\n/*************************************************************************\n  Common API between MultiBufferStream and SimpleStream\n *************************************************************************/\nMP4BoxStream.prototype.getPosition = function() {\n  return this.position;\n};\n\nMP4BoxStream.prototype.getEndPosition = function() {\n  return this.buffer.byteLength;\n};\n\nMP4BoxStream.prototype.getLength = function() {\n  return this.buffer.byteLength;\n};\n\nMP4BoxStream.prototype.seek = function (pos) {\n  var npos = Math.max(0, Math.min(this.buffer.byteLength, pos));\n  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;\n  return true;\n};\n\nMP4BoxStream.prototype.isEos = function () {\n  return this.getPosition() >= this.getEndPosition();\n};\n\n/*************************************************************************\n  Read methods, simimar to DataStream but simpler\n *************************************************************************/\nMP4BoxStream.prototype.readAnyInt = function(size, signed) {\n  var res = 0;\n  if (this.position + size <= this.buffer.byteLength) {\n    switch (size) {\n      case 1:\n        if (signed) {\n          res = this.dataview.getInt8(this.position);\n        } else {\n          res = this.dataview.getUint8(this.position);\n        }\n        break;\n      case 2:\n        if (signed) {\n          res = this.dataview.getInt16(this.position);\n        } else {\n          res = this.dataview.getUint16(this.position);\n        }\n        break;\n      case 3:\n        if (signed) {\n          throw (\"No method for reading signed 24 bits values\");\n        } else {\n          res = this.dataview.getUint8(this.position) << 16;\n          res |= this.dataview.getUint8(this.position+1) << 8;\n          res |= this.dataview.getUint8(this.position+2);\n        }\n        break;\n      case 4:\n        if (signed) {\n          res = this.dataview.getInt32(this.position);\n        } else {\n          res = this.dataview.getUint32(this.position);\n        }\n        break;\n      case 8:\n        if (signed) {\n          throw (\"No method for reading signed 64 bits values\");\n        } else {\n          res = this.dataview.getUint32(this.position) << 32;\n          res |= this.dataview.getUint32(this.position+4);\n        }\n        break;\n      default:\n        throw (\"readInt method not implemented for size: \"+size);\n    }\n    this.position+= size;\n    return res;\n  } else {\n    throw (\"Not enough bytes in buffer\");\n  }\n};\n\nMP4BoxStream.prototype.readUint8 = function() {\n  return this.readAnyInt(1, false);\n};\n\nMP4BoxStream.prototype.readUint16 = function() {\n  return this.readAnyInt(2, false);\n};\n\nMP4BoxStream.prototype.readUint24 = function() {\n  return this.readAnyInt(3, false);\n};\n\nMP4BoxStream.prototype.readUint32 = function() {\n  return this.readAnyInt(4, false);\n};\n\nMP4BoxStream.prototype.readUint64 = function() {\n  return this.readAnyInt(8, false);\n};\n\nMP4BoxStream.prototype.readString = function(length) {\n  if (this.position + length <= this.buffer.byteLength) {\n    var s = \"\";\n    for (var i = 0; i < length; i++) {\n      s += String.fromCharCode(this.readUint8());\n    }\n    return s;\n  } else {\n    throw (\"Not enough bytes in buffer\");\n  }\n};\n\nMP4BoxStream.prototype.readCString = function() {\n  var arr = [];\n  while(true) {\n    var b = this.readUint8();\n    if (b !== 0) {\n      arr.push(b);\n    } else {\n      break;\n    }\n  }\n  return String.fromCharCode.apply(null, arr); \n};\n\nMP4BoxStream.prototype.readInt8 = function() {\n  return this.readAnyInt(1, true);\n};\n\nMP4BoxStream.prototype.readInt16 = function() {\n  return this.readAnyInt(2, true);\n};\n\nMP4BoxStream.prototype.readInt32 = function() {\n  return this.readAnyInt(4, true);\n};\n\nMP4BoxStream.prototype.readInt64 = function() {\n  return this.readAnyInt(8, false);\n};\n\nMP4BoxStream.prototype.readUint8Array = function(length) {\n  var arr = new Uint8Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readUint8();\n  }\n  return arr;\n};\n\nMP4BoxStream.prototype.readInt16Array = function(length) {\n  var arr = new Int16Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readInt16();\n  }\n  return arr;\n};\n\nMP4BoxStream.prototype.readUint16Array = function(length) {\n  var arr = new Int16Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readUint16();\n  }\n  return arr;\n};\n\nMP4BoxStream.prototype.readUint32Array = function(length) {\n  var arr = new Uint32Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readUint32();\n  }\n  return arr;\n};\n\nMP4BoxStream.prototype.readInt32Array = function(length) {\n  var arr = new Int32Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = this.readInt32();\n  }\n  return arr;\n};\n\n{\n  exports.MP4BoxStream = MP4BoxStream;\n}// file:src/DataStream.js\n/**\n  DataStream reads scalars, arrays and structs of data from an ArrayBuffer.\n  It's like a file-like DataView on steroids.\n\n  @param {ArrayBuffer} arrayBuffer ArrayBuffer to read from.\n  @param {?Number} byteOffset Offset from arrayBuffer beginning for the DataStream.\n  @param {?Boolean} endianness DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN (the default).\n  */\nvar DataStream = function(arrayBuffer, byteOffset, endianness) {\n  this._byteOffset = byteOffset || 0;\n  if (arrayBuffer instanceof ArrayBuffer) {\n    this.buffer = arrayBuffer;\n  } else if (typeof arrayBuffer == \"object\") {\n    this.dataView = arrayBuffer;\n    if (byteOffset) {\n      this._byteOffset += byteOffset;\n    }\n  } else {\n    this.buffer = new ArrayBuffer(arrayBuffer || 0);\n  }\n  this.position = 0;\n  this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;\n};\nDataStream.prototype = {};\n\nDataStream.prototype.getPosition = function() {\n  return this.position;\n};\n\n/**\n  Internal function to resize the DataStream buffer when required.\n  @param {number} extra Number of bytes to add to the buffer allocation.\n  @return {null}\n  */\nDataStream.prototype._realloc = function(extra) {\n  if (!this._dynamicSize) {\n    return;\n  }\n  var req = this._byteOffset + this.position + extra;\n  var blen = this._buffer.byteLength;\n  if (req <= blen) {\n    if (req > this._byteLength) {\n      this._byteLength = req;\n    }\n    return;\n  }\n  if (blen < 1) {\n    blen = 1;\n  }\n  while (req > blen) {\n    blen *= 2;\n  }\n  var buf = new ArrayBuffer(blen);\n  var src = new Uint8Array(this._buffer);\n  var dst = new Uint8Array(buf, 0, src.length);\n  dst.set(src);\n  this.buffer = buf;\n  this._byteLength = req;\n};\n\n/**\n  Internal function to trim the DataStream buffer when required.\n  Used for stripping out the extra bytes from the backing buffer when\n  the virtual byteLength is smaller than the buffer byteLength (happens after\n  growing the buffer with writes and not filling the extra space completely).\n\n  @return {null}\n  */\nDataStream.prototype._trimAlloc = function() {\n  if (this._byteLength == this._buffer.byteLength) {\n    return;\n  }\n  var buf = new ArrayBuffer(this._byteLength);\n  var dst = new Uint8Array(buf);\n  var src = new Uint8Array(this._buffer, 0, dst.length);\n  dst.set(src);\n  this.buffer = buf;\n};\n\n\n/**\n  Big-endian const to use as default endianness.\n  @type {boolean}\n  */\nDataStream.BIG_ENDIAN = false;\n\n/**\n  Little-endian const to use as default endianness.\n  @type {boolean}\n  */\nDataStream.LITTLE_ENDIAN = true;\n\n/**\n  Virtual byte length of the DataStream backing buffer.\n  Updated to be max of original buffer size and last written size.\n  If dynamicSize is false is set to buffer size.\n  @type {number}\n  */\nDataStream.prototype._byteLength = 0;\n\n/**\n  Returns the byte length of the DataStream object.\n  @type {number}\n  */\nObject.defineProperty(DataStream.prototype, 'byteLength',\n  { get: function() {\n    return this._byteLength - this._byteOffset;\n  }});\n\n/**\n  Set/get the backing ArrayBuffer of the DataStream object.\n  The setter updates the DataView to point to the new buffer.\n  @type {Object}\n  */\nObject.defineProperty(DataStream.prototype, 'buffer',\n  { get: function() {\n      this._trimAlloc();\n      return this._buffer;\n    },\n    set: function(v) {\n      this._buffer = v;\n      this._dataView = new DataView(this._buffer, this._byteOffset);\n      this._byteLength = this._buffer.byteLength;\n    } });\n\n/**\n  Set/get the byteOffset of the DataStream object.\n  The setter updates the DataView to point to the new byteOffset.\n  @type {number}\n  */\nObject.defineProperty(DataStream.prototype, 'byteOffset',\n  { get: function() {\n      return this._byteOffset;\n    },\n    set: function(v) {\n      this._byteOffset = v;\n      this._dataView = new DataView(this._buffer, this._byteOffset);\n      this._byteLength = this._buffer.byteLength;\n    } });\n\n/**\n  Set/get the backing DataView of the DataStream object.\n  The setter updates the buffer and byteOffset to point to the DataView values.\n  @type {Object}\n  */\nObject.defineProperty(DataStream.prototype, 'dataView',\n  { get: function() {\n      return this._dataView;\n    },\n    set: function(v) {\n      this._byteOffset = v.byteOffset;\n      this._buffer = v.buffer;\n      this._dataView = new DataView(this._buffer, this._byteOffset);\n      this._byteLength = this._byteOffset + v.byteLength;\n    } });\n\n/**\n  Sets the DataStream read/write position to given position.\n  Clamps between 0 and DataStream length.\n\n  @param {number} pos Position to seek to.\n  @return {null}\n  */\nDataStream.prototype.seek = function(pos) {\n  var npos = Math.max(0, Math.min(this.byteLength, pos));\n  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;\n};\n\n/**\n  Returns true if the DataStream seek pointer is at the end of buffer and\n  there's no more data to read.\n\n  @return {boolean} True if the seek pointer is at the end of the buffer.\n  */\nDataStream.prototype.isEof = function() {\n  return (this.position >= this._byteLength);\n};\n\n\n/**\n  Maps a Uint8Array into the DataStream buffer.\n\n  Nice for quickly reading in data.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint8Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapUint8Array = function(length) {\n  this._realloc(length * 1);\n  var arr = new Uint8Array(this._buffer, this.byteOffset+this.position, length);\n  this.position += length * 1;\n  return arr;\n};\n\n\n/**\n  Reads an Int32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int32Array.\n */\nDataStream.prototype.readInt32Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 4) : length;\n  var arr = new Int32Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads an Int16Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int16Array.\n */\nDataStream.prototype.readInt16Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 2) : length;\n  var arr = new Int16Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads an Int8Array of desired length from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Int8Array.\n */\nDataStream.prototype.readInt8Array = function(length) {\n  length = length == null ? (this.byteLength-this.position) : length;\n  var arr = new Int8Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Uint32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint32Array.\n */\nDataStream.prototype.readUint32Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 4) : length;\n  var arr = new Uint32Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Uint16Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint16Array.\n */\nDataStream.prototype.readUint16Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 2) : length;\n  var arr = new Uint16Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Uint8Array of desired length from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Uint8Array.\n */\nDataStream.prototype.readUint8Array = function(length) {\n  length = length == null ? (this.byteLength-this.position) : length;\n  var arr = new Uint8Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Float64Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Float64Array.\n */\nDataStream.prototype.readFloat64Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 8) : length;\n  var arr = new Float64Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n/**\n  Reads a Float32Array of desired length and endianness from the DataStream.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} The read Float32Array.\n */\nDataStream.prototype.readFloat32Array = function(length, e) {\n  length = length == null ? (this.byteLength-this.position / 4) : length;\n  var arr = new Float32Array(length);\n  DataStream.memcpy(arr.buffer, 0,\n                    this.buffer, this.byteOffset+this.position,\n                    length*arr.BYTES_PER_ELEMENT);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += arr.byteLength;\n  return arr;\n};\n\n\n/**\n  Reads a 32-bit int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readInt32 = function(e) {\n  var v = this._dataView.getInt32(this.position, e == null ? this.endianness : e);\n  this.position += 4;\n  return v;\n};\n\n/**\n  Reads a 16-bit int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readInt16 = function(e) {\n  var v = this._dataView.getInt16(this.position, e == null ? this.endianness : e);\n  this.position += 2;\n  return v;\n};\n\n/**\n  Reads an 8-bit int from the DataStream.\n\n  @return {number} The read number.\n */\nDataStream.prototype.readInt8 = function() {\n  var v = this._dataView.getInt8(this.position);\n  this.position += 1;\n  return v;\n};\n\n/**\n  Reads a 32-bit unsigned int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readUint32 = function(e) {\n  var v = this._dataView.getUint32(this.position, e == null ? this.endianness : e);\n  this.position += 4;\n  return v;\n};\n\n/**\n  Reads a 16-bit unsigned int from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readUint16 = function(e) {\n  var v = this._dataView.getUint16(this.position, e == null ? this.endianness : e);\n  this.position += 2;\n  return v;\n};\n\n/**\n  Reads an 8-bit unsigned int from the DataStream.\n\n  @return {number} The read number.\n */\nDataStream.prototype.readUint8 = function() {\n  var v = this._dataView.getUint8(this.position);\n  this.position += 1;\n  return v;\n};\n\n/**\n  Reads a 32-bit float from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readFloat32 = function(e) {\n  var v = this._dataView.getFloat32(this.position, e == null ? this.endianness : e);\n  this.position += 4;\n  return v;\n};\n\n/**\n  Reads a 64-bit float from the DataStream with the desired endianness.\n\n  @param {?boolean} e Endianness of the number.\n  @return {number} The read number.\n */\nDataStream.prototype.readFloat64 = function(e) {\n  var v = this._dataView.getFloat64(this.position, e == null ? this.endianness : e);\n  this.position += 8;\n  return v;\n};\n\n/**\n  Native endianness. Either DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN\n  depending on the platform endianness.\n\n  @type {boolean}\n */\nDataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n/**\n  Copies byteLength bytes from the src buffer at srcOffset to the\n  dst buffer at dstOffset.\n\n  @param {Object} dst Destination ArrayBuffer to write to.\n  @param {number} dstOffset Offset to the destination ArrayBuffer.\n  @param {Object} src Source ArrayBuffer to read from.\n  @param {number} srcOffset Offset to the source ArrayBuffer.\n  @param {number} byteLength Number of bytes to copy.\n */\nDataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {\n  var dstU8 = new Uint8Array(dst, dstOffset, byteLength);\n  var srcU8 = new Uint8Array(src, srcOffset, byteLength);\n  dstU8.set(srcU8);\n};\n\n/**\n  Converts array to native endianness in-place.\n\n  @param {Object} array Typed array to convert.\n  @param {boolean} arrayIsLittleEndian True if the data in the array is\n                                       little-endian. Set false for big-endian.\n  @return {Object} The converted typed array.\n */\nDataStream.arrayToNative = function(array, arrayIsLittleEndian) {\n  if (arrayIsLittleEndian == this.endianness) {\n    return array;\n  } else {\n    return this.flipArrayEndianness(array);\n  }\n};\n\n/**\n  Converts native endianness array to desired endianness in-place.\n\n  @param {Object} array Typed array to convert.\n  @param {boolean} littleEndian True if the converted array should be\n                                little-endian. Set false for big-endian.\n  @return {Object} The converted typed array.\n */\nDataStream.nativeToEndian = function(array, littleEndian) {\n  if (this.endianness == littleEndian) {\n    return array;\n  } else {\n    return this.flipArrayEndianness(array);\n  }\n};\n\n/**\n  Flips typed array endianness in-place.\n\n  @param {Object} array Typed array to flip.\n  @return {Object} The converted typed array.\n */\nDataStream.flipArrayEndianness = function(array) {\n  var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (var i=0; i<array.byteLength; i+=array.BYTES_PER_ELEMENT) {\n    for (var j=i+array.BYTES_PER_ELEMENT-1, k=i; j>k; j--, k++) {\n      var tmp = u8[k];\n      u8[k] = u8[j];\n      u8[j] = tmp;\n    }\n  }\n  return array;\n};\n\n/**\n  Seek position where DataStream#readStruct ran into a problem.\n  Useful for debugging struct parsing.\n\n  @type {number}\n */\nDataStream.prototype.failurePosition = 0;\n\nString.fromCharCodeUint8 = function(uint8arr) {\n    var arr = [];\n    for (var i = 0; i < uint8arr.length; i++) {\n      arr[i] = uint8arr[i];\n    }\n    return String.fromCharCode.apply(null, arr);\n};\n/**\n  Read a string of desired length and encoding from the DataStream.\n\n  @param {number} length The length of the string to read in bytes.\n  @param {?string} encoding The encoding of the string data in the DataStream.\n                            Defaults to ASCII.\n  @return {string} The read string.\n */\nDataStream.prototype.readString = function(length, encoding) {\n  if (encoding == null || encoding == \"ASCII\") {\n    return String.fromCharCodeUint8.apply(null, [this.mapUint8Array(length == null ? this.byteLength-this.position : length)]);\n  } else {\n    return (new TextDecoder(encoding)).decode(this.mapUint8Array(length));\n  }\n};\n\n/**\n  Read null-terminated string of desired length from the DataStream. Truncates\n  the returned string so that the null byte is not a part of it.\n\n  @param {?number} length The length of the string to read.\n  @return {string} The read string.\n */\nDataStream.prototype.readCString = function(length) {\n  var blen = this.byteLength-this.position;\n  var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);\n  var len = blen;\n  if (length != null) {\n    len = Math.min(length, blen);\n  }\n  for (var i = 0; i < len && u8[i] !== 0; i++); // find first zero byte\n  var s = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(i)]);\n  if (length != null) {\n    this.position += len-i;\n  } else if (i != blen) {\n    this.position += 1; // trailing zero if not at end of buffer\n  }\n  return s;\n};\n\n/* \n   TODO: fix endianness for 24/64-bit fields\n   TODO: check range/support for 64-bits numbers in JavaScript\n*/\nvar MAX_SIZE = Math.pow(2, 32);\n\nDataStream.prototype.readInt64 = function () {\n  return (this.readInt32()*MAX_SIZE)+this.readUint32();\n};\nDataStream.prototype.readUint64 = function () {\n\treturn (this.readUint32()*MAX_SIZE)+this.readUint32();\n};\n\nDataStream.prototype.readInt64 = function () {\n  return (this.readUint32()*MAX_SIZE)+this.readUint32();\n};\n\nDataStream.prototype.readUint24 = function () {\n\treturn (this.readUint8()<<16)+(this.readUint8()<<8)+this.readUint8();\n};\n\n{\n  exports.DataStream = DataStream;  \n}\n// file:src/DataStream-write.js\n/**\n  Saves the DataStream contents to the given filename.\n  Uses Chrome's anchor download property to initiate download.\n \n  @param {string} filename Filename to save as.\n  @return {null}\n  */\nDataStream.prototype.save = function(filename) {\n  var blob = new Blob([this.buffer]);\n  if (window.URL && URL.createObjectURL) {\n      var url = window.URL.createObjectURL(blob);\n      var a = document.createElement('a');\n      // Required in Firefox:\n      document.body.appendChild(a);\n      a.setAttribute('href', url);\n      a.setAttribute('download', filename);\n      // Required in Firefox:\n      a.setAttribute('target', '_self');\n      a.click();\n      window.URL.revokeObjectURL(url);\n  } else {\n      throw(\"DataStream.save: Can't create object URL.\");\n  }\n};\n\n/**\n  Whether to extend DataStream buffer when trying to write beyond its size.\n  If set, the buffer is reallocated to twice its current size until the\n  requested write fits the buffer.\n  @type {boolean}\n  */\nDataStream.prototype._dynamicSize = true;\nObject.defineProperty(DataStream.prototype, 'dynamicSize',\n  { get: function() {\n      return this._dynamicSize;\n    },\n    set: function(v) {\n      if (!v) {\n        this._trimAlloc();\n      }\n      this._dynamicSize = v;\n    } });\n\n/**\n  Internal function to trim the DataStream buffer when required.\n  Used for stripping out the first bytes when not needed anymore.\n\n  @return {null}\n  */\nDataStream.prototype.shift = function(offset) {\n  var buf = new ArrayBuffer(this._byteLength-offset);\n  var dst = new Uint8Array(buf);\n  var src = new Uint8Array(this._buffer, offset, dst.length);\n  dst.set(src);\n  this.buffer = buf;\n  this.position -= offset;\n};\n\n/**\n  Writes an Int32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeInt32Array = function(arr, e) {\n  this._realloc(arr.length * 4);\n  if (arr instanceof Int32Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapInt32Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeInt32(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes an Int16Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeInt16Array = function(arr, e) {\n  this._realloc(arr.length * 2);\n  if (arr instanceof Int16Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapInt16Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeInt16(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes an Int8Array to the DataStream.\n\n  @param {Object} arr The array to write.\n */\nDataStream.prototype.writeInt8Array = function(arr) {\n  this._realloc(arr.length * 1);\n  if (arr instanceof Int8Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapInt8Array(arr.length);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeInt8(arr[i]);\n    }\n  }\n};\n\n/**\n  Writes a Uint32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeUint32Array = function(arr, e) {\n  this._realloc(arr.length * 4);\n  if (arr instanceof Uint32Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapUint32Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeUint32(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes a Uint16Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeUint16Array = function(arr, e) {\n  this._realloc(arr.length * 2);\n  if (arr instanceof Uint16Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapUint16Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeUint16(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes a Uint8Array to the DataStream.\n\n  @param {Object} arr The array to write.\n */\nDataStream.prototype.writeUint8Array = function(arr) {\n  this._realloc(arr.length * 1);\n  if (arr instanceof Uint8Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapUint8Array(arr.length);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeUint8(arr[i]);\n    }\n  }\n};\n\n/**\n  Writes a Float64Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeFloat64Array = function(arr, e) {\n  this._realloc(arr.length * 8);\n  if (arr instanceof Float64Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapFloat64Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeFloat64(arr[i], e);\n    }\n  }\n};\n\n/**\n  Writes a Float32Array of specified endianness to the DataStream.\n\n  @param {Object} arr The array to write.\n  @param {?boolean} e Endianness of the data to write.\n */\nDataStream.prototype.writeFloat32Array = function(arr, e) {\n  this._realloc(arr.length * 4);\n  if (arr instanceof Float32Array &&\n      this.byteOffset+this.position % arr.BYTES_PER_ELEMENT === 0) {\n    DataStream.memcpy(this._buffer, this.byteOffset+this.position,\n                      arr.buffer, 0,\n                      arr.byteLength);\n    this.mapFloat32Array(arr.length, e);\n  } else {\n    for (var i=0; i<arr.length; i++) {\n      this.writeFloat32(arr[i], e);\n    }\n  }\n};\n\n\n/**\n  Writes a 32-bit int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeInt32 = function(v, e) {\n  this._realloc(4);\n  this._dataView.setInt32(this.position, v, e == null ? this.endianness : e);\n  this.position += 4;\n};\n\n/**\n  Writes a 16-bit int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeInt16 = function(v, e) {\n  this._realloc(2);\n  this._dataView.setInt16(this.position, v, e == null ? this.endianness : e);\n  this.position += 2;\n};\n\n/**\n  Writes an 8-bit int to the DataStream.\n\n  @param {number} v Number to write.\n */\nDataStream.prototype.writeInt8 = function(v) {\n  this._realloc(1);\n  this._dataView.setInt8(this.position, v);\n  this.position += 1;\n};\n\n/**\n  Writes a 32-bit unsigned int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeUint32 = function(v, e) {\n  this._realloc(4);\n  this._dataView.setUint32(this.position, v, e == null ? this.endianness : e);\n  this.position += 4;\n};\n\n/**\n  Writes a 16-bit unsigned int to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeUint16 = function(v, e) {\n  this._realloc(2);\n  this._dataView.setUint16(this.position, v, e == null ? this.endianness : e);\n  this.position += 2;\n};\n\n/**\n  Writes an 8-bit unsigned  int to the DataStream.\n\n  @param {number} v Number to write.\n */\nDataStream.prototype.writeUint8 = function(v) {\n  this._realloc(1);\n  this._dataView.setUint8(this.position, v);\n  this.position += 1;\n};\n\n/**\n  Writes a 32-bit float to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeFloat32 = function(v, e) {\n  this._realloc(4);\n  this._dataView.setFloat32(this.position, v, e == null ? this.endianness : e);\n  this.position += 4;\n};\n\n/**\n  Writes a 64-bit float to the DataStream with the desired endianness.\n\n  @param {number} v Number to write.\n  @param {?boolean} e Endianness of the number.\n */\nDataStream.prototype.writeFloat64 = function(v, e) {\n  this._realloc(8);\n  this._dataView.setFloat64(this.position, v, e == null ? this.endianness : e);\n  this.position += 8;\n};\n\n/**\n  Write a UCS-2 string of desired endianness to the DataStream. The\n  lengthOverride argument lets you define the number of characters to write.\n  If the string is shorter than lengthOverride, the extra space is padded with\n  zeroes.\n\n  @param {string} str The string to write.\n  @param {?boolean} endianness The endianness to use for the written string data.\n  @param {?number} lengthOverride The number of characters to write.\n */\nDataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {\n  if (lengthOverride == null) {\n    lengthOverride = str.length;\n  }\n  for (var i = 0; i < str.length && i < lengthOverride; i++) {\n    this.writeUint16(str.charCodeAt(i), endianness);\n  }\n  for (; i<lengthOverride; i++) {\n    this.writeUint16(0);\n  }\n};\n\n/**\n  Writes a string of desired length and encoding to the DataStream.\n\n  @param {string} s The string to write.\n  @param {?string} encoding The encoding for the written string data.\n                            Defaults to ASCII.\n  @param {?number} length The number of characters to write.\n */\nDataStream.prototype.writeString = function(s, encoding, length) {\n  var i = 0;\n  if (encoding == null || encoding == \"ASCII\") {\n    if (length != null) {\n      var len = Math.min(s.length, length);\n      for (i=0; i<len; i++) {\n        this.writeUint8(s.charCodeAt(i));\n      }\n      for (; i<length; i++) {\n        this.writeUint8(0);\n      }\n    } else {\n      for (i=0; i<s.length; i++) {\n        this.writeUint8(s.charCodeAt(i));\n      }\n    }\n  } else {\n    this.writeUint8Array((new TextEncoder(encoding)).encode(s.substring(0, length)));\n  }\n};\n\n/**\n  Writes a null-terminated string to DataStream and zero-pads it to length\n  bytes. If length is not given, writes the string followed by a zero.\n  If string is longer than length, the written part of the string does not have\n  a trailing zero.\n\n  @param {string} s The string to write.\n  @param {?number} length The number of characters to write.\n */\nDataStream.prototype.writeCString = function(s, length) {\n  var i = 0;\n  if (length != null) {\n    var len = Math.min(s.length, length);\n    for (i=0; i<len; i++) {\n      this.writeUint8(s.charCodeAt(i));\n    }\n    for (; i<length; i++) {\n      this.writeUint8(0);\n    }\n  } else {\n    for (i=0; i<s.length; i++) {\n      this.writeUint8(s.charCodeAt(i));\n    }\n    this.writeUint8(0);\n  }\n};\n\n/**\n  Writes a struct to the DataStream. Takes a structDefinition that gives the\n  types and a struct object that gives the values. Refer to readStruct for the\n  structure of structDefinition.\n\n  @param {Object} structDefinition Type definition of the struct.\n  @param {Object} struct The struct data object.\n  */\nDataStream.prototype.writeStruct = function(structDefinition, struct) {\n  for (var i = 0; i < structDefinition.length; i+=2) {\n    var t = structDefinition[i+1];\n    this.writeType(t, struct[structDefinition[i]], struct);\n  }\n};\n\n/**\n  Writes object v of type t to the DataStream.\n\n  @param {Object} t Type of data to write.\n  @param {Object} v Value of data to write.\n  @param {Object} struct Struct to pass to write callback functions.\n  */\nDataStream.prototype.writeType = function(t, v, struct) {\n  var tp;\n  if (typeof t == \"function\") {\n    return t(this, v);\n  } else if (typeof t == \"object\" && !(t instanceof Array)) {\n    return t.set(this, v, struct);\n  }\n  var lengthOverride = null;\n  var charset = \"ASCII\";\n  var pos = this.position;\n  if (typeof(t) == 'string' && /:/.test(t)) {\n    tp = t.split(\":\");\n    t = tp[0];\n    lengthOverride = parseInt(tp[1]);\n  }\n  if (typeof t == 'string' && /,/.test(t)) {\n    tp = t.split(\",\");\n    t = tp[0];\n    charset = parseInt(tp[1]);\n  }\n\n  switch(t) {\n    case 'uint8':\n      this.writeUint8(v);\n      break;\n    case 'int8':\n      this.writeInt8(v);\n      break;\n\n    case 'uint16':\n      this.writeUint16(v, this.endianness);\n      break;\n    case 'int16':\n      this.writeInt16(v, this.endianness);\n      break;\n    case 'uint32':\n      this.writeUint32(v, this.endianness);\n      break;\n    case 'int32':\n      this.writeInt32(v, this.endianness);\n      break;\n    case 'float32':\n      this.writeFloat32(v, this.endianness);\n      break;\n    case 'float64':\n      this.writeFloat64(v, this.endianness);\n      break;\n\n    case 'uint16be':\n      this.writeUint16(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'int16be':\n      this.writeInt16(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'uint32be':\n      this.writeUint32(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'int32be':\n      this.writeInt32(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'float32be':\n      this.writeFloat32(v, DataStream.BIG_ENDIAN);\n      break;\n    case 'float64be':\n      this.writeFloat64(v, DataStream.BIG_ENDIAN);\n      break;\n\n    case 'uint16le':\n      this.writeUint16(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'int16le':\n      this.writeInt16(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'uint32le':\n      this.writeUint32(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'int32le':\n      this.writeInt32(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'float32le':\n      this.writeFloat32(v, DataStream.LITTLE_ENDIAN);\n      break;\n    case 'float64le':\n      this.writeFloat64(v, DataStream.LITTLE_ENDIAN);\n      break;\n\n    case 'cstring':\n      this.writeCString(v, lengthOverride);\n      break;\n\n    case 'string':\n      this.writeString(v, charset, lengthOverride);\n      break;\n\n    case 'u16string':\n      this.writeUCS2String(v, this.endianness, lengthOverride);\n      break;\n\n    case 'u16stringle':\n      this.writeUCS2String(v, DataStream.LITTLE_ENDIAN, lengthOverride);\n      break;\n\n    case 'u16stringbe':\n      this.writeUCS2String(v, DataStream.BIG_ENDIAN, lengthOverride);\n      break;\n\n    default:\n      if (t.length == 3) {\n        var ta = t[1];\n        for (var i=0; i<v.length; i++) {\n          this.writeType(ta, v[i]);\n        }\n        break;\n      } else {\n        this.writeStruct(t, v);\n        break;\n      }\n  }\n  if (lengthOverride != null) {\n    this.position = pos;\n    this._realloc(lengthOverride);\n    this.position = pos + lengthOverride;\n  }\n};\n\n\nDataStream.prototype.writeUint64 = function (v) {\n\tvar h = Math.floor(v / MAX_SIZE);\n\tthis.writeUint32(h);\n\tthis.writeUint32(v & 0xFFFFFFFF);\n};\n\nDataStream.prototype.writeUint24 = function (v) {\n\tthis.writeUint8((v & 0x00FF0000)>>16);\n\tthis.writeUint8((v & 0x0000FF00)>>8);\n\tthis.writeUint8((v & 0x000000FF));\n};\n\nDataStream.prototype.adjustUint32 = function(position, value) {\n\tvar pos = this.position;\n\tthis.seek(position);\n\tthis.writeUint32(value);\n\tthis.seek(pos);\n};\n// file:src/DataStream-map.js\n/**\n  Maps an Int32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int32Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapInt32Array = function(length, e) {\n  this._realloc(length * 4);\n  var arr = new Int32Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 4;\n  return arr;\n};\n\n/**\n  Maps an Int16Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int16Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapInt16Array = function(length, e) {\n  this._realloc(length * 2);\n  var arr = new Int16Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 2;\n  return arr;\n};\n\n/**\n  Maps an Int8Array into the DataStream buffer.\n\n  Nice for quickly reading in data.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Int8Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapInt8Array = function(length) {\n  this._realloc(length * 1);\n  var arr = new Int8Array(this._buffer, this.byteOffset+this.position, length);\n  this.position += length * 1;\n  return arr;\n};\n\n/**\n  Maps a Uint32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint32Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapUint32Array = function(length, e) {\n  this._realloc(length * 4);\n  var arr = new Uint32Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 4;\n  return arr;\n};\n\n/**\n  Maps a Uint16Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Uint16Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapUint16Array = function(length, e) {\n  this._realloc(length * 2);\n  var arr = new Uint16Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 2;\n  return arr;\n};\n\n/**\n  Maps a Float64Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Float64Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapFloat64Array = function(length, e) {\n  this._realloc(length * 8);\n  var arr = new Float64Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 8;\n  return arr;\n};\n\n/**\n  Maps a Float32Array into the DataStream buffer, swizzling it to native\n  endianness in-place. The current offset from the start of the buffer needs to\n  be a multiple of element size, just like with typed array views.\n\n  Nice for quickly reading in data. Warning: potentially modifies the buffer\n  contents.\n\n  @param {number} length Number of elements to map.\n  @param {?boolean} e Endianness of the data to read.\n  @return {Object} Float32Array to the DataStream backing buffer.\n  */\nDataStream.prototype.mapFloat32Array = function(length, e) {\n  this._realloc(length * 4);\n  var arr = new Float32Array(this._buffer, this.byteOffset+this.position, length);\n  DataStream.arrayToNative(arr, e == null ? this.endianness : e);\n  this.position += length * 4;\n  return arr;\n};\n// file:src/buffer.js\n/**\n * MultiBufferStream is a class that acts as a SimpleStream for parsing \n * It holds several, possibly non-contiguous ArrayBuffer objects, each with a fileStart property \n * containing the offset for the buffer data in an original/virtual file \n *\n * It inherits also from DataStream for all read/write/alloc operations\n */\n\n/**\n * Constructor\n */\nvar MultiBufferStream = function(buffer) {\n\t/* List of ArrayBuffers, with a fileStart property, sorted in fileStart order and non overlapping */\n\tthis.buffers = [];\t\n\tthis.bufferIndex = -1;\n\tif (buffer) {\n\t\tthis.insertBuffer(buffer);\n\t\tthis.bufferIndex = 0;\n\t}\n};\nMultiBufferStream.prototype = new DataStream(new ArrayBuffer(), 0, DataStream.BIG_ENDIAN);\n\n/************************************************************************************\n  Methods for the managnement of the buffers (insertion, removal, concatenation, ...)\n ***********************************************************************************/\n\nMultiBufferStream.prototype.initialized = function() {\n\tvar firstBuffer;\n\tif (this.bufferIndex > -1) {\n\t\treturn true;\n\t} else if (this.buffers.length > 0) {\n\t\tfirstBuffer = this.buffers[0];\n\t\tif (firstBuffer.fileStart === 0) {\n\t\t\tthis.buffer = firstBuffer;\n\t\t\tthis.bufferIndex = 0;\n\t\t\tLog.debug(\"MultiBufferStream\", \"Stream ready for parsing\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tLog.warn(\"MultiBufferStream\", \"The first buffer should have a fileStart of 0\");\n\t\t\tthis.logBufferLevel();\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tLog.warn(\"MultiBufferStream\", \"No buffer to start parsing from\");\n\t\tthis.logBufferLevel();\n\t\treturn false;\n\t}\t\t\t\n};\n\n/**\n * helper functions to concatenate two ArrayBuffer objects\n * @param  {ArrayBuffer} buffer1 \n * @param  {ArrayBuffer} buffer2 \n * @return {ArrayBuffer} the concatenation of buffer1 and buffer2 in that order\n */\nArrayBuffer.concat = function(buffer1, buffer2) {\n  Log.debug(\"ArrayBuffer\", \"Trying to create a new buffer of size: \"+(buffer1.byteLength + buffer2.byteLength));\n  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n};\n\n/**\n * Reduces the size of a given buffer, but taking the part between offset and offset+newlength\n * @param  {ArrayBuffer} buffer    \n * @param  {Number}      offset    the start of new buffer\n * @param  {Number}      newLength the length of the new buffer\n * @return {ArrayBuffer}           the new buffer\n */\nMultiBufferStream.prototype.reduceBuffer = function(buffer, offset, newLength) {\n\tvar smallB;\n\tsmallB = new Uint8Array(newLength);\n\tsmallB.set(new Uint8Array(buffer, offset, newLength));\n\tsmallB.buffer.fileStart = buffer.fileStart+offset;\n\tsmallB.buffer.usedBytes = 0;\n\treturn smallB.buffer;\t\n};\n\n/**\n * Inserts the new buffer in the sorted list of buffers,\n *  making sure, it is not overlapping with existing ones (possibly reducing its size).\n *  if the new buffer overrides/replaces the 0-th buffer (for instance because it is bigger), \n *  updates the DataStream buffer for parsing \n*/\nMultiBufferStream.prototype.insertBuffer = function(ab) {\t\n\tvar to_add = true;\n\t/* TODO: improve insertion if many buffers */\n\tfor (var i = 0; i < this.buffers.length; i++) {\n\t\tvar b = this.buffers[i];\n\t\tif (ab.fileStart <= b.fileStart) {\n\t\t\t/* the insertion position is found */\n\t\t\tif (ab.fileStart === b.fileStart) {\n\t\t\t\t/* The new buffer overlaps with an existing buffer */\n\t\t\t\tif (ab.byteLength >  b.byteLength) {\n\t\t\t\t\t/* the new buffer is bigger than the existing one\n\t\t\t\t\t   remove the existing buffer and try again to insert \n\t\t\t\t\t   the new buffer to check overlap with the next ones */\n\t\t\t\t\tthis.buffers.splice(i, 1);\n\t\t\t\t\ti--; \n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t/* the new buffer is smaller than the existing one, just drop it */\n\t\t\t\t\tLog.warn(\"MultiBufferStream\", \"Buffer (fileStart: \"+ab.fileStart+\" - Length: \"+ab.byteLength+\") already appended, ignoring\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* The beginning of the new buffer is not overlapping with an existing buffer\n\t\t\t\t   let's check the end of it */\n\t\t\t\tif (ab.fileStart + ab.byteLength <= b.fileStart) ; else {\n\t\t\t\t\t/* There is some overlap, cut the new buffer short, and add it*/\n\t\t\t\t\tab = this.reduceBuffer(ab, 0, b.fileStart - ab.fileStart);\n\t\t\t\t}\n\t\t\t\tLog.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \"+ab.fileStart+\" - Length: \"+ab.byteLength+\")\");\n\t\t\t\tthis.buffers.splice(i, 0, ab);\n\t\t\t\t/* if this new buffer is inserted in the first place in the list of the buffer, \n\t\t\t\t   and the DataStream is initialized, make it the buffer used for parsing */\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tthis.buffer = ab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tto_add = false;\n\t\t\tbreak;\n\t\t} else if (ab.fileStart < b.fileStart + b.byteLength) {\n\t\t\t/* the new buffer overlaps its beginning with the end of the current buffer */\n\t\t\tvar offset = b.fileStart + b.byteLength - ab.fileStart;\n\t\t\tvar newLength = ab.byteLength - offset;\n\t\t\tif (newLength > 0) {\n\t\t\t\t/* the new buffer is bigger than the current overlap, drop the overlapping part and try again inserting the remaining buffer */\n\t\t\t\tab = this.reduceBuffer(ab, offset, newLength);\n\t\t\t} else {\n\t\t\t\t/* the content of the new buffer is entirely contained in the existing buffer, drop it entirely */\n\t\t\t\tto_add = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* if the buffer has not been added, we can add it at the end */\n\tif (to_add) {\n\t\tLog.debug(\"MultiBufferStream\", \"Appending new buffer (fileStart: \"+ab.fileStart+\" - Length: \"+ab.byteLength+\")\");\n\t\tthis.buffers.push(ab);\n\t\t/* if this new buffer is inserted in the first place in the list of the buffer, \n\t\t   and the DataStream is initialized, make it the buffer used for parsing */\n\t\tif (i === 0) {\n\t\t\tthis.buffer = ab;\n\t\t}\n\t}\n};\n\n/**\n * Displays the status of the buffers (number and used bytes)\n * @param  {Object} info callback method for display\n */\nMultiBufferStream.prototype.logBufferLevel = function(info) {\n\tvar i;\n\tvar buffer;\n\tvar used, total;\n\tvar ranges = [];\n\tvar range;\n\tvar bufferedString = \"\";\n\tused = 0;\n\ttotal = 0;\n\tfor (i = 0; i < this.buffers.length; i++) {\n\t\tbuffer = this.buffers[i];\n\t\tif (i === 0) {\n\t\t\trange = {};\n\t\t\tranges.push(range);\n\t\t\trange.start = buffer.fileStart;\n\t\t\trange.end = buffer.fileStart+buffer.byteLength;\n\t\t\tbufferedString += \"[\"+range.start+\"-\";\n\t\t} else if (range.end === buffer.fileStart) {\n\t\t\trange.end = buffer.fileStart+buffer.byteLength;\n\t\t} else {\n\t\t\trange = {};\n\t\t\trange.start = buffer.fileStart;\n\t\t\tbufferedString += (ranges[ranges.length-1].end-1)+\"], [\"+range.start+\"-\";\n\t\t\trange.end = buffer.fileStart+buffer.byteLength;\n\t\t\tranges.push(range);\n\t\t}\n\t\tused += buffer.usedBytes;\n\t\ttotal += buffer.byteLength;\n\t}\n\tif (ranges.length > 0) {\n\t\tbufferedString += (range.end-1)+\"]\";\n\t}\n\tvar log = (info ? Log.info : Log.debug);\n\tif (this.buffers.length === 0) {\n\t\tlog(\"MultiBufferStream\", \"No more buffer in memory\");\n\t} else {\n\t\tlog(\"MultiBufferStream\", \"\"+this.buffers.length+\" stored buffer(s) (\"+used+\"/\"+total+\" bytes), continuous ranges: \"+bufferedString);\n\t}\n};\n\nMultiBufferStream.prototype.cleanBuffers = function () {\n\tvar i;\n\tvar buffer;\n\tfor (i = 0; i < this.buffers.length; i++) {\n\t\tbuffer = this.buffers[i];\n\t\tif (buffer.usedBytes === buffer.byteLength) {\n\t\t\tLog.debug(\"MultiBufferStream\", \"Removing buffer #\"+i);\n\t\t\tthis.buffers.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n};\n\nMultiBufferStream.prototype.mergeNextBuffer = function() {\n\tvar next_buffer;\n\tif (this.bufferIndex+1 < this.buffers.length) {\n\t\tnext_buffer = this.buffers[this.bufferIndex+1];\n\t\tif (next_buffer.fileStart === this.buffer.fileStart + this.buffer.byteLength) {\n\t\t\tvar oldLength = this.buffer.byteLength;\n\t\t\tvar oldUsedBytes = this.buffer.usedBytes;\n\t\t\tvar oldFileStart = this.buffer.fileStart;\n\t\t\tthis.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, next_buffer);\n\t\t\tthis.buffer = this.buffers[this.bufferIndex];\n\t\t\tthis.buffers.splice(this.bufferIndex+1, 1);\n\t\t\tthis.buffer.usedBytes = oldUsedBytes; /* TODO: should it be += ? */\n\t\t\tthis.buffer.fileStart = oldFileStart;\n\t\t\tLog.debug(\"ISOFile\", \"Concatenating buffer for box parsing (length: \"+oldLength+\"->\"+this.buffer.byteLength+\")\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n};\n\n\n/*************************************************************************\n  Seek-related functions\n *************************************************************************/\n\n/**\n * Finds the buffer that holds the given file position\n * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false) \n *                                or from the first buffer (true)\n * @param  {Number}  filePosition position in the file to seek to\n * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position \n *                                should be marked as used for garbage collection\n * @return {Number}               the index of the buffer holding the seeked file position, -1 if not found.\n */\nMultiBufferStream.prototype.findPosition = function(fromStart, filePosition, markAsUsed) {\n\tvar i;\n\tvar abuffer = null;\n\tvar index = -1;\n\n\t/* find the buffer with the largest position smaller than the given position */\n\tif (fromStart === true) {\n\t   /* the reposition can be in the past, we need to check from the beginning of the list of buffers */\n\t\ti = 0;\n\t} else {\n\t\ti = this.bufferIndex;\n\t}\n\n\twhile (i < this.buffers.length) {\n\t\tabuffer = this.buffers[i];\n\t\tif (abuffer.fileStart <= filePosition) {\n\t\t\tindex = i;\n\t\t\tif (markAsUsed) {\n\t\t\t\tif (abuffer.fileStart + abuffer.byteLength <= filePosition) {\n\t\t\t\t\tabuffer.usedBytes = abuffer.byteLength;\t\n\t\t\t\t} else {\n\t\t\t\t\tabuffer.usedBytes = filePosition - abuffer.fileStart;\n\t\t\t\t}\t\t\n\t\t\t\tthis.logBufferLevel();\t\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (index !== -1) {\n\t\tabuffer = this.buffers[index];\n\t\tif (abuffer.fileStart + abuffer.byteLength >= filePosition) {\t\t\t\n\t\t\tLog.debug(\"MultiBufferStream\", \"Found position in existing buffer #\"+index);\n\t\t\treturn index;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n};\n\n/**\n * Finds the largest file position contained in a buffer or in the next buffers if they are contiguous (no gap)\n * starting from the given buffer index or from the current buffer if the index is not given\n *\n * @param  {Number} inputindex Index of the buffer to start from\n * @return {Number}            The largest file position found in the buffers\n */\nMultiBufferStream.prototype.findEndContiguousBuf = function(inputindex) {\n\tvar i;\n\tvar currentBuf;\n\tvar nextBuf;\n\tvar index = (inputindex !== undefined ? inputindex : this.bufferIndex);\n\tcurrentBuf = this.buffers[index];\n\t/* find the end of the contiguous range of data */\n\tif (this.buffers.length > index+1) {\n\t\tfor (i = index+1; i < this.buffers.length; i++) {\n\t\t\tnextBuf = this.buffers[i];\n\t\t\tif (nextBuf.fileStart === currentBuf.fileStart + currentBuf.byteLength) {\n\t\t\t\tcurrentBuf = nextBuf;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* return the position of last byte in the file that we have */\n\treturn currentBuf.fileStart + currentBuf.byteLength;\n};\n\n/**\n * Returns the largest file position contained in the buffers, larger than the given position\n * @param  {Number} pos the file position to start from\n * @return {Number}     the largest position in the current buffer or in the buffer and the next contiguous \n *                      buffer that holds the given position\n */\nMultiBufferStream.prototype.getEndFilePositionAfter = function(pos) {\n\tvar index = this.findPosition(true, pos, false);\n\tif (index !== -1) {\n\t\treturn this.findEndContiguousBuf(index);\n\t} else {\n\t\treturn pos;\n\t}\n};\n\n/*************************************************************************\n  Garbage collection related functions\n *************************************************************************/\n\n/**\n * Marks a given number of bytes as used in the current buffer for garbage collection\n * @param {Number} nbBytes \n */\nMultiBufferStream.prototype.addUsedBytes = function(nbBytes) {\n\tthis.buffer.usedBytes += nbBytes;\n\tthis.logBufferLevel();\n};\n\n/**\n * Marks the entire current buffer as used, ready for garbage collection\n */\nMultiBufferStream.prototype.setAllUsedBytes = function() {\n\tthis.buffer.usedBytes = this.buffer.byteLength;\n\tthis.logBufferLevel();\n};\n\n/*************************************************************************\n  Common API between MultiBufferStream and SimpleStream\n *************************************************************************/\n\n/**\n * Tries to seek to a given file position\n * if possible, repositions the parsing from there and returns true \n * if not possible, does not change anything and returns false \n * @param  {Number}  filePosition position in the file to seek to\n * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false) \n *                                or from the first buffer (true)\n * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position \n *                                should be marked as used for garbage collection\n * @return {Boolean}              true if the seek succeeded, false otherwise\n */\nMultiBufferStream.prototype.seek = function(filePosition, fromStart, markAsUsed) {\n\tvar index;\n\tindex = this.findPosition(fromStart, filePosition, markAsUsed);\n\tif (index !== -1) {\n\t\tthis.buffer = this.buffers[index];\n\t\tthis.bufferIndex = index;\n\t\tthis.position = filePosition - this.buffer.fileStart;\n\t\tLog.debug(\"MultiBufferStream\", \"Repositioning parser at buffer position: \"+this.position);\n\t\treturn true;\n\t} else {\n\t\tLog.debug(\"MultiBufferStream\", \"Position \"+filePosition+\" not found in buffered data\");\n\t\treturn false;\n\t}\n};\n\n/**\n * Returns the current position in the file\n * @return {Number} the position in the file\n */\nMultiBufferStream.prototype.getPosition = function() {\n\tif (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null) {\n\t\tthrow \"Error accessing position in the MultiBufferStream\";\n\t}\n\treturn this.buffers[this.bufferIndex].fileStart+this.position;\n};\n\n/**\n * Returns the length of the current buffer\n * @return {Number} the length of the current buffer\n */\nMultiBufferStream.prototype.getLength = function() {\n\treturn this.byteLength;\n};\n\nMultiBufferStream.prototype.getEndPosition = function() {\n\tif (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null) {\n\t\tthrow \"Error accessing position in the MultiBufferStream\";\n\t}\n\treturn this.buffers[this.bufferIndex].fileStart+this.byteLength;\n};\n\n{\n\texports.MultiBufferStream = MultiBufferStream;\n}// file:src/descriptor.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar MPEG4DescriptorParser = function () {\n\tvar ES_DescrTag \t\t\t= 0x03;\n\tvar DecoderConfigDescrTag \t= 0x04;\n\tvar DecSpecificInfoTag \t\t= 0x05;\n\tvar SLConfigDescrTag \t\t= 0x06;\n\n\tvar descTagToName = [];\n\tdescTagToName[ES_DescrTag] \t\t\t\t= \"ES_Descriptor\";\n\tdescTagToName[DecoderConfigDescrTag] \t= \"DecoderConfigDescriptor\";\n\tdescTagToName[DecSpecificInfoTag] \t\t= \"DecoderSpecificInfo\";\n\tdescTagToName[SLConfigDescrTag] \t\t= \"SLConfigDescriptor\";\n\n\tthis.getDescriptorName = function(tag) {\n\t\treturn descTagToName[tag];\n\t};\n\n\tvar that = this;\n\tvar classes = {};\n\n\tthis.parseOneDescriptor = function (stream) {\n\t\tvar size = 0;\n\t\tvar tag;\n\t\tvar desc;\n\t\tvar byteRead;\n\t\ttag = stream.readUint8();\n\t\tbyteRead = stream.readUint8();\n\t\twhile (byteRead & 0x80) {\n\t\t\tsize = (byteRead & 0x7F)<<7;\n\t\t\tbyteRead = stream.readUint8();\n\t\t}\n\t\tsize += byteRead & 0x7F;\n\t\tLog.debug(\"MPEG4DescriptorParser\", \"Found \"+(descTagToName[tag] || \"Descriptor \"+tag)+\", size \"+size+\" at position \"+stream.getPosition());\n\t\tif (descTagToName[tag]) {\n\t\t\tdesc = new classes[descTagToName[tag]](size);\n\t\t} else {\n\t\t\tdesc = new classes.Descriptor(size);\n\t\t}\n\t\tdesc.parse(stream);\n\t\treturn desc;\n\t};\n\n\tclasses.Descriptor = function(_tag, _size) {\n\t\tthis.tag = _tag;\n\t\tthis.size = _size;\n\t\tthis.descs = [];\n\t};\n\n\tclasses.Descriptor.prototype.parse = function (stream) {\n\t\tthis.data = stream.readUint8Array(this.size);\n\t};\n\n\tclasses.Descriptor.prototype.findDescriptor = function (tag) {\n\t\tfor (var i = 0; i < this.descs.length; i++) {\n\t\t\tif (this.descs[i].tag == tag) {\n\t\t\t\treturn this.descs[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tclasses.Descriptor.prototype.parseRemainingDescriptors = function (stream) {\n\t\tvar start = stream.position;\n\t\twhile (stream.position < start+this.size) {\n\t\t\tvar desc = that.parseOneDescriptor(stream);\n\t\t\tthis.descs.push(desc);\n\t\t}\n\t};\n\n\tclasses.ES_Descriptor = function (size) {\n\t\tclasses.Descriptor.call(this, ES_DescrTag, size);\n\t};\n\n\tclasses.ES_Descriptor.prototype = new classes.Descriptor();\n\n\tclasses.ES_Descriptor.prototype.parse = function(stream) {\n\t\tthis.ES_ID = stream.readUint16();\n\t\tthis.flags = stream.readUint8();\n\t\tthis.size -= 3;\n\t\tif (this.flags & 0x80) {\n\t\t\tthis.dependsOn_ES_ID = stream.readUint16();\n\t\t\tthis.size -= 2;\n\t\t} else {\n\t\t\tthis.dependsOn_ES_ID = 0;\n\t\t}\n\t\tif (this.flags & 0x40) {\n\t\t\tvar l = stream.readUint8();\n\t\t\tthis.URL = stream.readString(l);\n\t\t\tthis.size -= l+1;\n\t\t} else {\n\t\t\tthis.URL = \"\";\n\t\t}\n\t\tif (this.flags & 0x20) {\n\t\t\tthis.OCR_ES_ID = stream.readUint16();\n\t\t\tthis.size -= 2;\n\t\t} else {\n\t\t\tthis.OCR_ES_ID = 0;\n\t\t}\n\t\tthis.parseRemainingDescriptors(stream);\n\t};\n\n\tclasses.ES_Descriptor.prototype.getOTI = function(stream) {\n\t\tvar dcd = this.findDescriptor(DecoderConfigDescrTag);\n\t\tif (dcd) {\n\t\t\treturn dcd.oti;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t};\n\n\tclasses.ES_Descriptor.prototype.getAudioConfig = function(stream) {\n\t\tvar dcd = this.findDescriptor(DecoderConfigDescrTag);\n\t\tif (!dcd) return null;\n\t\tvar dsi = dcd.findDescriptor(DecSpecificInfoTag);\n\t\tif (dsi && dsi.data) {\n\t\t\tvar audioObjectType = (dsi.data[0]& 0xF8) >> 3;\n\t\t\tif (audioObjectType === 31 && dsi.data.length >= 2) {\n\t\t\t\taudioObjectType = 32 + ((dsi.data[0] & 0x7) << 3) + ((dsi.data[1] & 0xE0) >> 5);\n\t\t\t}\n\t\t\treturn audioObjectType;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tclasses.DecoderConfigDescriptor = function (size) {\n\t\tclasses.Descriptor.call(this, DecoderConfigDescrTag, size);\n\t};\n\tclasses.DecoderConfigDescriptor.prototype = new classes.Descriptor();\n\n\tclasses.DecoderConfigDescriptor.prototype.parse = function(stream) {\n\t\tthis.oti = stream.readUint8();\n\t\tthis.streamType = stream.readUint8();\n\t\tthis.bufferSize = stream.readUint24();\n\t\tthis.maxBitrate = stream.readUint32();\n\t\tthis.avgBitrate = stream.readUint32();\n\t\tthis.size -= 13;\n\t\tthis.parseRemainingDescriptors(stream);\n\t};\n\n\tclasses.DecoderSpecificInfo = function (size) {\n\t\tclasses.Descriptor.call(this, DecSpecificInfoTag, size);\n\t};\n\tclasses.DecoderSpecificInfo.prototype = new classes.Descriptor();\n\n\tclasses.SLConfigDescriptor = function (size) {\n\t\tclasses.Descriptor.call(this, SLConfigDescrTag, size);\n\t};\n\tclasses.SLConfigDescriptor.prototype = new classes.Descriptor();\n\n\treturn this;\n};\n\n{\n\texports.MPEG4DescriptorParser = MPEG4DescriptorParser;\n}// file:src/box.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar BoxParser = {\n\tERR_INVALID_DATA : -1,\n\tERR_NOT_ENOUGH_DATA : 0,\n\tOK : 1,\n\n\t// Boxes to be created with default parsing\n\tBASIC_BOXES: [ \"mdat\", \"idat\", \"free\", \"skip\", \"meco\", \"strk\" ],\n\tFULL_BOXES: [ \"hmhd\", \"nmhd\", \"iods\", \"xml \", \"bxml\", \"ipro\", \"mere\" ],\n\tCONTAINER_BOXES: [\n\t\t[ \"moov\", [ \"trak\", \"pssh\" ] ],\n\t\t[ \"trak\" ],\n\t\t[ \"edts\" ],\n\t\t[ \"mdia\" ],\n\t\t[ \"minf\" ],\n\t\t[ \"dinf\" ],\n\t\t[ \"stbl\", [ \"sgpd\", \"sbgp\" ] ],\n\t\t[ \"mvex\", [ \"trex\" ] ],\n\t\t[ \"moof\", [ \"traf\" ] ],\n\t\t[ \"traf\", [ \"trun\", \"sgpd\", \"sbgp\" ] ],\n\t\t[ \"vttc\" ],\n\t\t[ \"tref\" ],\n\t\t[ \"iref\" ],\n\t\t[ \"mfra\", [ \"tfra\" ] ],\n\t\t[ \"meco\" ],\n\t\t[ \"hnti\" ],\n\t\t[ \"hinf\" ],\n\t\t[ \"strk\" ],\n\t\t[ \"strd\" ],\n\t\t[ \"sinf\" ],\n\t\t[ \"rinf\" ],\n\t\t[ \"schi\" ],\n\t\t[ \"trgr\" ],\n\t\t[ \"udta\", [\"kind\"] ],\n\t\t[ \"iprp\", [\"ipma\"] ],\n\t\t[ \"ipco\"]\n\t],\n\t// Boxes effectively created\n\tboxCodes : [],\n\tfullBoxCodes : [],\n\tcontainerBoxCodes : [],\n\tsampleEntryCodes : {},\n\tsampleGroupEntryCodes: [],\n\ttrackGroupTypes: [],\n\tUUIDBoxes: {},\n\tUUIDs: [],\n\tinitialize: function() {\n\t\tBoxParser.FullBox.prototype = new BoxParser.Box();\n\t\tBoxParser.ContainerBox.prototype = new BoxParser.Box();\n\t\tBoxParser.SampleEntry.prototype = new BoxParser.Box();\n\t\tBoxParser.TrackGroupTypeBox.prototype = new BoxParser.FullBox();\n\n\t\t/* creating constructors for simple boxes */\n\t\tBoxParser.BASIC_BOXES.forEach(function(type) {\n\t\t\tBoxParser.createBoxCtor(type);\n\t\t});\n\t\tBoxParser.FULL_BOXES.forEach(function(type) {\n\t\t\tBoxParser.createFullBoxCtor(type);\n\t\t});\n\t\tBoxParser.CONTAINER_BOXES.forEach(function(types) {\n\t\t\tBoxParser.createContainerBoxCtor(types[0], null, types[1]);\n\t\t});\n\t},\n\tBox: function(_type, _size, _uuid) {\n\t\tthis.type = _type;\n\t\tthis.size = _size;\n\t\tthis.uuid = _uuid;\n\t},\n\tFullBox: function(type, size, uuid) {\n\t\tBoxParser.Box.call(this, type, size, uuid);\n\t\tthis.flags = 0;\n\t\tthis.version = 0;\n\t},\n\tContainerBox: function(type, size, uuid) {\n\t\tBoxParser.Box.call(this, type, size, uuid);\n\t\tthis.boxes = [];\n\t},\n\tSampleEntry: function(type, size, hdr_size, start) {\n\t\tBoxParser.ContainerBox.call(this, type, size);\n\t\tthis.hdr_size = hdr_size;\n\t\tthis.start = start;\n\t},\n\tSampleGroupEntry: function(type) {\n\t\tthis.grouping_type = type;\n\t},\n\tTrackGroupTypeBox: function(type, size) {\n\t\tBoxParser.FullBox.call(this, type, size);\n\t},\n\tcreateBoxCtor: function(type, parseMethod){\n\t\tBoxParser.boxCodes.push(type);\n\t\tBoxParser[type+\"Box\"] = function(size) {\n\t\t\tBoxParser.Box.call(this, type, size);\n\t\t};\n\t\tBoxParser[type+\"Box\"].prototype = new BoxParser.Box();\n\t\tif (parseMethod) BoxParser[type+\"Box\"].prototype.parse = parseMethod;\n\t},\n\tcreateFullBoxCtor: function(type, parseMethod) {\n\t\t//BoxParser.fullBoxCodes.push(type);\n\t\tBoxParser[type+\"Box\"] = function(size) {\n\t\t\tBoxParser.FullBox.call(this, type, size);\n\t\t};\n\t\tBoxParser[type+\"Box\"].prototype = new BoxParser.FullBox();\n\t\tBoxParser[type+\"Box\"].prototype.parse = function(stream) {\n\t\t\tthis.parseFullHeader(stream);\n\t\t\tif (parseMethod) {\n\t\t\t\tparseMethod.call(this, stream);\n\t\t\t}\n\t\t};\n\t},\n\taddSubBoxArrays: function(subBoxNames) {\n\t\tif (subBoxNames) {\n\t\t\tthis.subBoxNames = subBoxNames;\n\t\t\tvar nbSubBoxes = subBoxNames.length;\n\t\t\tfor (var k = 0; k<nbSubBoxes; k++) {\n\t\t\t\tthis[subBoxNames[k]+\"s\"] = [];\n\t\t\t}\n\t\t}\n\t},\n\tcreateContainerBoxCtor: function(type, parseMethod, subBoxNames) {\n\t\t//BoxParser.containerBoxCodes.push(type);\n\t\tBoxParser[type+\"Box\"] = function(size) {\n\t\t\tBoxParser.ContainerBox.call(this, type, size);\n\t\t\tBoxParser.addSubBoxArrays.call(this, subBoxNames);\n\t\t};\n\t\tBoxParser[type+\"Box\"].prototype = new BoxParser.ContainerBox();\n\t\tif (parseMethod) BoxParser[type+\"Box\"].prototype.parse = parseMethod;\n\t},\n\tcreateMediaSampleEntryCtor: function(mediaType, parseMethod, subBoxNames) {\n\t\tBoxParser.sampleEntryCodes[mediaType] = [];\n\t\tBoxParser[mediaType+\"SampleEntry\"] = function(type, size) {\n\t\t\tBoxParser.SampleEntry.call(this, type, size);\n\t\t\tBoxParser.addSubBoxArrays.call(this, subBoxNames);\n\t\t};\n\t\tBoxParser[mediaType+\"SampleEntry\"].prototype = new BoxParser.SampleEntry();\n\t\tif (parseMethod) BoxParser[mediaType+\"SampleEntry\"].prototype .parse = parseMethod;\n\t},\n\tcreateSampleEntryCtor: function(mediaType, type, parseMethod, subBoxNames) {\n\t\tBoxParser.sampleEntryCodes[mediaType].push(type);\n\t\tBoxParser[type+\"SampleEntry\"] = function(size) {\n\t\t\tBoxParser[mediaType+\"SampleEntry\"].call(this, type, size);\n\t\t\tBoxParser.addSubBoxArrays.call(this, subBoxNames);\n\t\t};\n\t\tBoxParser[type+\"SampleEntry\"].prototype = new BoxParser[mediaType+\"SampleEntry\"]();\n\t\tif (parseMethod) BoxParser[type+\"SampleEntry\"].prototype.parse = parseMethod;\n\t},\n\tcreateEncryptedSampleEntryCtor: function(mediaType, type, parseMethod) {\n\t\tBoxParser.createSampleEntryCtor.call(this, mediaType, type, parseMethod, [\"sinf\"]);\n\t},\n\tcreateSampleGroupCtor: function(type, parseMethod) {\n\t\t//BoxParser.sampleGroupEntryCodes.push(type);\n\t\tBoxParser[type+\"SampleGroupEntry\"] = function(size) {\n\t\t\tBoxParser.SampleGroupEntry.call(this, type, size);\n\t\t};\n\t\tBoxParser[type+\"SampleGroupEntry\"].prototype = new BoxParser.SampleGroupEntry();\n\t\tif (parseMethod) BoxParser[type+\"SampleGroupEntry\"].prototype.parse = parseMethod;\n\t},\n\tcreateTrackGroupCtor: function(type, parseMethod) {\n\t\t//BoxParser.trackGroupTypes.push(type);\n\t\tBoxParser[type+\"TrackGroupTypeBox\"] = function(size) {\n\t\t\tBoxParser.TrackGroupTypeBox.call(this, type, size);\n\t\t};\n\t\tBoxParser[type+\"TrackGroupTypeBox\"].prototype = new BoxParser.TrackGroupTypeBox();\n\t\tif (parseMethod) BoxParser[type+\"TrackGroupTypeBox\"].prototype.parse = parseMethod;\n\t},\n\tcreateUUIDBox: function(uuid, isFullBox, isContainerBox, parseMethod) {\n\t\tBoxParser.UUIDs.push(uuid);\n\t\tBoxParser.UUIDBoxes[uuid] = function(size) {\n\t\t\tif (isFullBox) {\n\t\t\t\tBoxParser.FullBox.call(this, \"uuid\", size, uuid);\n\t\t\t} else {\n\t\t\t\tif (isContainerBox) {\n\t\t\t\t\tBoxParser.ContainerBox.call(this, \"uuid\", size, uuid);\n\t\t\t\t} else {\n\t\t\t\t\tBoxParser.Box.call(this, \"uuid\", size, uuid);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tBoxParser.UUIDBoxes[uuid].prototype = (isFullBox ? new BoxParser.FullBox() : (isContainerBox ? new BoxParser.ContainerBox() : new BoxParser.Box()));\n\t\tif (parseMethod) {\n\t\t\tif (isFullBox) {\n\t\t\t\tBoxParser.UUIDBoxes[uuid].prototype.parse = function(stream) {\n\t\t\t\t\tthis.parseFullHeader(stream);\n\t\t\t\t\tif (parseMethod) {\n\t\t\t\t\t\tparseMethod.call(this, stream);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tBoxParser.UUIDBoxes[uuid].prototype.parse = parseMethod;\n\t\t\t}\n\t\t}\n\t}\n};\n\nBoxParser.initialize();\n\nBoxParser.TKHD_FLAG_ENABLED    = 0x000001;\nBoxParser.TKHD_FLAG_IN_MOVIE   = 0x000002;\nBoxParser.TKHD_FLAG_IN_PREVIEW = 0x000004;\n\nBoxParser.TFHD_FLAG_BASE_DATA_OFFSET\t= 0x01;\nBoxParser.TFHD_FLAG_SAMPLE_DESC\t\t\t= 0x02;\nBoxParser.TFHD_FLAG_SAMPLE_DUR\t\t\t= 0x08;\nBoxParser.TFHD_FLAG_SAMPLE_SIZE\t\t\t= 0x10;\nBoxParser.TFHD_FLAG_SAMPLE_FLAGS\t\t= 0x20;\nBoxParser.TFHD_FLAG_DUR_EMPTY\t\t\t= 0x10000;\nBoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF= 0x20000;\n\nBoxParser.TRUN_FLAGS_DATA_OFFSET= 0x01;\nBoxParser.TRUN_FLAGS_FIRST_FLAG\t= 0x04;\nBoxParser.TRUN_FLAGS_DURATION\t= 0x100;\nBoxParser.TRUN_FLAGS_SIZE\t\t= 0x200;\nBoxParser.TRUN_FLAGS_FLAGS\t\t= 0x400;\nBoxParser.TRUN_FLAGS_CTS_OFFSET\t= 0x800;\n\nBoxParser.Box.prototype.add = function(name) {\n\treturn this.addBox(new BoxParser[name+\"Box\"]());\n};\n\nBoxParser.Box.prototype.addBox = function(box) {\n\tthis.boxes.push(box);\n\tif (this[box.type+\"s\"]) {\n\t\tthis[box.type+\"s\"].push(box);\n\t} else {\n\t\tthis[box.type] = box;\n\t}\n\treturn box;\n};\n\nBoxParser.Box.prototype.set = function(prop, value) {\n\tthis[prop] = value;\n\treturn this;\n};\n\nBoxParser.Box.prototype.addEntry = function(value, _prop) {\n\tvar prop = _prop || \"entries\";\n\tif (!this[prop]) {\n\t\tthis[prop] = [];\n\t}\n\tthis[prop].push(value);\n\treturn this;\n};\n\n{\n\texports.BoxParser = BoxParser;\n}\n// file:src/box-parse.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.parseUUID = function(stream) {\n\treturn BoxParser.parseHex16(stream);\n};\n\nBoxParser.parseHex16 = function(stream) {\n\tvar hex16 = \"\";\n\tfor (var i = 0; i <16; i++) {\n\t\tvar hex = stream.readUint8().toString(16);\n\t\thex16 += (hex.length === 1 ? \"0\"+hex : hex);\n\t}\n\treturn hex16;\n};\n\nBoxParser.parseOneBox = function(stream, headerOnly, parentSize) {\n\tvar box;\n\tvar start = stream.getPosition();\n\tvar hdr_size = 0;\n\tvar diff;\n\tvar uuid;\n\tif (stream.getEndPosition() - start < 8) {\n\t\tLog.debug(\"BoxParser\", \"Not enough data in stream to parse the type and size of the box\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t}\n\tif (parentSize && parentSize < 8) {\n\t\tLog.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a new box\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t}\n\tvar size = stream.readUint32();\n\tvar type = stream.readString(4);\n\tvar box_type = type;\n\tLog.debug(\"BoxParser\", \"Found box of type '\"+type+\"' and size \"+size+\" at position \"+start);\n\thdr_size = 8;\n\tif (type == \"uuid\") {\n\t\tif ((stream.getEndPosition() - stream.getPosition() < 16) || (parentSize -hdr_size < 16)) {\n\t\t\tstream.seek(start);\n\t\t\tLog.debug(\"BoxParser\", \"Not enough bytes left in the parent box to parse a UUID box\");\n\t\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t\t}\n\t\tuuid = BoxParser.parseUUID(stream);\n\t\thdr_size += 16;\n\t\tbox_type = uuid;\n\t}\n\tif (size == 1) {\n\t\tif ((stream.getEndPosition() - stream.getPosition() < 8) || (parentSize && (parentSize - hdr_size) < 8)) {\n\t\t\tstream.seek(start);\n\t\t\tLog.warn(\"BoxParser\", \"Not enough data in stream to parse the extended size of the \\\"\"+type+\"\\\" box\");\n\t\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA };\n\t\t}\n\t\tsize = stream.readUint64();\n\t\thdr_size += 8;\n\t} else if (size === 0) {\n\t\t/* box extends till the end of file or invalid file */\n\t\tif (parentSize) {\n\t\t\tsize = parentSize;\n\t\t} else {\n\t\t\t/* box extends till the end of file */\n\t\t\tif (type !== \"mdat\") {\n\t\t\t\tLog.error(\"BoxParser\", \"Unlimited box size not supported for type: '\"+type+\"'\");\n\t\t\t\tbox = new BoxParser.Box(type, size);\n\t\t\t\treturn { code: BoxParser.OK, box: box, size: box.size };\n\t\t\t}\n\t\t}\n\t}\n\tif (size < hdr_size) {\n\t\tLog.error(\"BoxParser\", \"Box of type \"+type+\" has an invalid size \"+size+\" (too small to be a box)\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: type, size: size, hdr_size: hdr_size, start: start };\n\t}\n\tif (parentSize && size > parentSize) {\n\t\tLog.error(\"BoxParser\", \"Box of type '\"+type+\"' has a size \"+size+\" greater than its container size \"+parentSize);\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: type, size: size, hdr_size: hdr_size, start: start };\n\t}\n\tif (start + size > stream.getEndPosition()) {\n\t\tstream.seek(start);\n\t\tLog.info(\"BoxParser\", \"Not enough data in stream to parse the entire '\"+type+\"' box\");\n\t\treturn { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: type, size: size, hdr_size: hdr_size, start: start };\n\t}\n\tif (headerOnly) {\n\t\treturn { code: BoxParser.OK, type: type, size: size, hdr_size: hdr_size, start: start };\n\t} else {\n\t\tif (BoxParser[type+\"Box\"]) {\n\t\t\tbox = new BoxParser[type+\"Box\"](size);\n\t\t} else {\n\t\t\tif (type !== \"uuid\") {\n\t\t\t\tLog.warn(\"BoxParser\", \"Unknown box type: '\"+type+\"'\");\n\t\t\t\tbox = new BoxParser.Box(type, size);\n\t\t\t\tbox.has_unparsed_data = true;\n\t\t\t} else {\n\t\t\t\tif (BoxParser.UUIDBoxes[uuid]) {\n\t\t\t\t\tbox = new BoxParser.UUIDBoxes[uuid](size);\n\t\t\t\t} else {\n\t\t\t\t\tLog.warn(\"BoxParser\", \"Unknown uuid type: '\"+uuid+\"'\");\n\t\t\t\t\tbox = new BoxParser.Box(type, size);\n\t\t\t\t\tbox.uuid = uuid;\n\t\t\t\t\tbox.has_unparsed_data = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbox.hdr_size = hdr_size;\n\t/* recording the position of the box in the input stream */\n\tbox.start = start;\n\tif (box.write === BoxParser.Box.prototype.write && box.type !== \"mdat\") {\n\t\tLog.info(\"BoxParser\", \"'\"+box_type+\"' box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\tbox.parseDataAndRewind(stream);\n\t}\n\tbox.parse(stream);\n\tdiff = stream.getPosition() - (box.start+box.size);\n\tif (diff < 0) {\n\t\tLog.warn(\"BoxParser\", \"Parsing of box '\"+box_type+\"' did not read the entire indicated box data size (missing \"+(-diff)+\" bytes), seeking forward\");\n\t\tstream.seek(box.start+box.size);\n\t} else if (diff > 0) {\n\t\tLog.error(\"BoxParser\", \"Parsing of box '\"+box_type+\"' read \"+diff+\" more bytes than the indicated box data size, seeking backwards\");\n\t\tstream.seek(box.start+box.size);\n\t}\n\treturn { code: BoxParser.OK, box: box, size: box.size };\n};\n\nBoxParser.Box.prototype.parse = function(stream) {\n\tif (this.type != \"mdat\") {\n\t\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n\t} else {\n\t\tif (this.size === 0) {\n\t\t\tstream.seek(stream.getEndPosition());\n\t\t} else {\n\t\t\tstream.seek(this.start+this.size);\n\t\t}\n\t}\n};\n\n/* Used to parse a box without consuming its data, to allow detailled parsing\n   Useful for boxes for which a write method is not yet implemented */\nBoxParser.Box.prototype.parseDataAndRewind = function(stream) {\n\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n\t// rewinding\n\tstream.position -= this.size-this.hdr_size;\n};\n\nBoxParser.FullBox.prototype.parseDataAndRewind = function(stream) {\n\tthis.parseFullHeader(stream);\n\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n\t// restore the header size as if the full header had not been parsed\n\tthis.hdr_size -= 4;\n\t// rewinding\n\tstream.position -= this.size-this.hdr_size;\n};\n\nBoxParser.FullBox.prototype.parseFullHeader = function (stream) {\n\tthis.version = stream.readUint8();\n\tthis.flags = stream.readUint24();\n\tthis.hdr_size += 4;\n};\n\nBoxParser.FullBox.prototype.parse = function (stream) {\n\tthis.parseFullHeader(stream);\n\tthis.data = stream.readUint8Array(this.size-this.hdr_size);\n};\n\nBoxParser.ContainerBox.prototype.parse = function(stream) {\n\tvar ret;\n\tvar box;\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\t/* store the box in the 'boxes' array to preserve box order (for offset) but also store box in a property for more direct access */\n\t\t\tthis.boxes.push(box);\n\t\t\tif (this.subBoxNames && this.subBoxNames.indexOf(box.type) != -1) {\n\t\t\t\tthis[this.subBoxNames[this.subBoxNames.indexOf(box.type)]+\"s\"].push(box);\n\t\t\t} else {\n\t\t\t\tvar box_type = box.type !== \"uuid\" ? box.type : box.uuid;\n\t\t\t\tif (this[box_type]) {\n\t\t\t\t\tLog.warn(\"Box of type \"+box_type+\" already stored in field of this type\");\n\t\t\t\t} else {\n\t\t\t\t\tthis[box_type] = box;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nBoxParser.Box.prototype.parseLanguage = function(stream) {\n\tthis.language = stream.readUint16();\n\tvar chars = [];\n\tchars[0] = (this.language>>10)&0x1F;\n\tchars[1] = (this.language>>5)&0x1F;\n\tchars[2] = (this.language)&0x1F;\n\tthis.languageString = String.fromCharCode(chars[0]+0x60, chars[1]+0x60, chars[2]+0x60);\n};\n\n// file:src/parsing/sampleentries/sampleentry.js\nBoxParser.SAMPLE_ENTRY_TYPE_VISUAL \t\t= \"Visual\";\nBoxParser.SAMPLE_ENTRY_TYPE_AUDIO \t\t= \"Audio\";\nBoxParser.SAMPLE_ENTRY_TYPE_HINT \t\t= \"Hint\";\nBoxParser.SAMPLE_ENTRY_TYPE_METADATA \t= \"Metadata\";\nBoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE \t= \"Subtitle\";\nBoxParser.SAMPLE_ENTRY_TYPE_SYSTEM \t\t= \"System\";\nBoxParser.SAMPLE_ENTRY_TYPE_TEXT \t\t= \"Text\";\n\nBoxParser.SampleEntry.prototype.parseHeader = function(stream) {\n\tstream.readUint8Array(6);\n\tthis.data_reference_index = stream.readUint16();\n\tthis.hdr_size += 8;\n};\n\nBoxParser.SampleEntry.prototype.parse = function(stream) {\n\tthis.parseHeader(stream);\n\tthis.data = stream.readUint8Array(this.size - this.hdr_size);\n};\n\nBoxParser.SampleEntry.prototype.parseDataAndRewind = function(stream) {\n\tthis.parseHeader(stream);\n\tthis.data = stream.readUint8Array(this.size - this.hdr_size);\n\t// restore the header size as if the sample entry header had not been parsed\n\tthis.hdr_size -= 8;\n\t// rewinding\n\tstream.position -= this.size-this.hdr_size;\n};\n\nBoxParser.SampleEntry.prototype.parseFooter = function(stream) {\n\tBoxParser.ContainerBox.prototype.parse.call(this, stream);\n};\n\n// Base SampleEntry types with default parsing\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_HINT);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM);\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT);\n\n//Base SampleEntry types for Audio and Video with specific parsing\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, function(stream) {\n\tvar compressorname_length;\n\tthis.parseHeader(stream);\n\tstream.readUint16();\n\tstream.readUint16();\n\tstream.readUint32Array(3);\n\tthis.width = stream.readUint16();\n\tthis.height = stream.readUint16();\n\tthis.horizresolution = stream.readUint32();\n\tthis.vertresolution = stream.readUint32();\n\tstream.readUint32();\n\tthis.frame_count = stream.readUint16();\n\tcompressorname_length = Math.min(31, stream.readUint8());\n\tthis.compressorname = stream.readString(compressorname_length);\n\tif (compressorname_length < 31) {\n\t\tstream.readString(31 - compressorname_length);\n\t}\n\tthis.depth = stream.readUint16();\n\tstream.readUint16();\n\tthis.parseFooter(stream);\n});\n\nBoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, function(stream) {\n\tthis.parseHeader(stream);\n\tstream.readUint32Array(2);\n\tthis.channel_count = stream.readUint16();\n\tthis.samplesize = stream.readUint16();\n\tstream.readUint16();\n\tstream.readUint16();\n\tthis.samplerate = (stream.readUint32()/(1<<16));\n\tthis.parseFooter(stream);\n});\n\n// Sample entries inheriting from Audio and Video\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc2\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"avc4\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"av01\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hvc1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \"hev1\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"mp4a\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"ac-3\");\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"ec-3\");\n\n// Encrypted sample entries\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, \t\"encv\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, \t\"enca\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \t\"encu\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM, \t\"encs\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT, \t\t\"enct\");\nBoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \t\"encm\");\n\n\n// file:src/parsing/a1lx.js\nBoxParser.createBoxCtor(\"a1lx\", function(stream) {\n\tvar large_size = stream.readUint8() & 1;\n\tvar FieldLength = ((large_size & 1) + 1) * 16;\n\tthis.layer_size = [];\n\tfor (var i = 0; i < 3; i++) {\n\t\tif (FieldLength == 16) {\n\t\t\tthis.layer_size[i] = stream.readUint16();\n\t\t} else {\n\t\t\tthis.layer_size[i] = stream.readUint32();\n\t\t}\n\t}\n});// file:src/parsing/a1op.js\nBoxParser.createBoxCtor(\"a1op\", function(stream) {\n\tthis.op_index = stream.readUint8();\n});// file:src/parsing/auxC.js\nBoxParser.createFullBoxCtor(\"auxC\", function(stream) {\n\tthis.aux_type = stream.readCString();\n\tvar aux_subtype_length = this.size - this.hdr_size - (this.aux_type.length + 1);\n\tthis.aux_subtype = stream.readUint8Array(aux_subtype_length);\n});// file:src/parsing/av1C.js\nBoxParser.createBoxCtor(\"av1C\", function(stream) {\n\tvar tmp = stream.readUint8();\n\tif ((tmp >> 7) & 0x1 !== 1) {\n\t\tLog.error(\"av1C marker problem\");\n\t\treturn;\n\t}\n\tthis.version = tmp & 0x7F;\n\tif (this.version !== 1) {\n\t\tLog.error(\"av1C version \"+this.version+\" not supported\");\n\t\treturn;\n\t}\n\ttmp = stream.readUint8();\n\tthis.seq_profile = (tmp >> 5) & 0x7;\n\tthis.seq_level_idx_0 = tmp & 0x1F;\n\ttmp = stream.readUint8();\n\tthis.seq_tier_0 = (tmp >> 7) & 0x1;\n\tthis.high_bitdepth = (tmp >> 6) & 0x1;\n\tthis.twelve_bit = (tmp >> 5) & 0x1;\n\tthis.monochrome = (tmp >> 4) & 0x1;\n\tthis.chroma_subsampling_x = (tmp >> 3) & 0x1;\n\tthis.chroma_subsampling_y = (tmp >> 2) & 0x1;\n\tthis.chroma_sample_position = (tmp & 0x3);\n\ttmp = stream.readUint8();\n\tthis.reserved_1 = (tmp >> 5) & 0x7;\n\tif (this.reserved_1 !== 0) {\n\t\tLog.error(\"av1C reserved_1 parsing problem\");\n\t\treturn;\n\t}\n\tthis.initial_presentation_delay_present = (tmp >> 4) & 0x1;\n\tif (this.initial_presentation_delay_present === 1) {\n\t\tthis.initial_presentation_delay_minus_one = (tmp & 0xF);\n\t} else {\n\t\tthis.reserved_2 = (tmp & 0xF);\n\t\tif (this.reserved_2 !== 0) {\n\t\t\tLog.error(\"av1C reserved_2 parsing problem\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvar configOBUs_length = this.size - this.hdr_size - 4;\n\tthis.configOBUs = stream.readUint8Array(configOBUs_length);\n});\n\n// file:src/parsing/avcC.js\nBoxParser.createBoxCtor(\"avcC\", function(stream) {\n\tvar i;\n\tvar toparse;\n\tthis.configurationVersion = stream.readUint8();\n\tthis.AVCProfileIndication = stream.readUint8();\n\tthis.profile_compatibility = stream.readUint8();\n\tthis.AVCLevelIndication = stream.readUint8();\n\tthis.lengthSizeMinusOne = (stream.readUint8() & 0x3);\n\tthis.nb_SPS_nalus = (stream.readUint8() & 0x1F);\n\ttoparse = this.size - this.hdr_size - 6;\n\tthis.SPS = [];\n\tfor (i = 0; i < this.nb_SPS_nalus; i++) {\n\t\tthis.SPS[i] = {};\n\t\tthis.SPS[i].length = stream.readUint16();\n\t\tthis.SPS[i].nalu = stream.readUint8Array(this.SPS[i].length);\n\t\ttoparse -= 2+this.SPS[i].length;\n\t}\n\tthis.nb_PPS_nalus = stream.readUint8();\n\ttoparse--;\n\tthis.PPS = [];\n\tfor (i = 0; i < this.nb_PPS_nalus; i++) {\n\t\tthis.PPS[i] = {};\n\t\tthis.PPS[i].length = stream.readUint16();\n\t\tthis.PPS[i].nalu = stream.readUint8Array(this.PPS[i].length);\n\t\ttoparse -= 2+this.PPS[i].length;\n\t}\n\tif (toparse>0) {\n\t\tthis.ext = stream.readUint8Array(toparse);\n\t}\n});\n\n// file:src/parsing/btrt.js\nBoxParser.createBoxCtor(\"btrt\", function(stream) {\n\tthis.bufferSizeDB = stream.readUint32();\n\tthis.maxBitrate = stream.readUint32();\n\tthis.avgBitrate = stream.readUint32();\n});\n\n// file:src/parsing/clap.js\nBoxParser.createBoxCtor(\"clap\", function(stream) {\n\tthis.cleanApertureWidthN = stream.readUint32();\n\tthis.cleanApertureWidthD = stream.readUint32();\n\tthis.cleanApertureHeightN = stream.readUint32();\n\tthis.cleanApertureHeightD = stream.readUint32();\n\tthis.horizOffN = stream.readUint32();\n\tthis.horizOffD = stream.readUint32();\n\tthis.vertOffN = stream.readUint32();\n\tthis.vertOffD = stream.readUint32();\n});// file:src/parsing/clli.js\nBoxParser.createBoxCtor(\"clli\", function(stream) {\n\tthis.max_content_light_level = stream.readUint16();\n    this.max_pic_average_light_level = stream.readUint16();\n});\n\n// file:src/parsing/co64.js\nBoxParser.createFullBoxCtor(\"co64\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.chunk_offsets = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.chunk_offsets.push(stream.readUint64());\n\t\t}\n\t}\n});\n\n// file:src/parsing/CoLL.js\nBoxParser.createFullBoxCtor(\"CoLL\", function(stream) {\n\tthis.maxCLL = stream.readUint16();\n    this.maxFALL = stream.readUint16();\n});\n\n// file:src/parsing/colr.js\nBoxParser.createBoxCtor(\"colr\", function(stream) {\n\tthis.colour_type = stream.readString(4);\n\tif (this.colour_type === 'nclx') {\n\t\tthis.colour_primaries = stream.readUint16();\n\t\tthis.transfer_characteristics = stream.readUint16();\n\t\tthis.matrix_coefficients = stream.readUint16();\n\t\tvar tmp = stream.readUint8();\n\t\tthis.full_range_flag = tmp >> 7;\n\t} else if (this.colour_type === 'rICC') {\n\t\tthis.ICC_profile = stream.readUint8Array(this.size - 4);\n\t} else if (this.colour_type === 'prof') {\n\t\tthis.ICC_profile = stream.readUint8Array(this.size - 4);\n\t}\n});// file:src/parsing/cprt.js\nBoxParser.createFullBoxCtor(\"cprt\", function (stream) {\n\tthis.parseLanguage(stream);\n\tthis.notice = stream.readCString();\n});\n\n// file:src/parsing/cslg.js\nBoxParser.createFullBoxCtor(\"cslg\", function(stream) {\n\tif (this.version === 0) {\n\t\tthis.compositionToDTSShift = stream.readInt32(); /* signed */\n\t\tthis.leastDecodeToDisplayDelta = stream.readInt32(); /* signed */\n\t\tthis.greatestDecodeToDisplayDelta = stream.readInt32(); /* signed */\n\t\tthis.compositionStartTime = stream.readInt32(); /* signed */\n\t\tthis.compositionEndTime = stream.readInt32(); /* signed */\n\t}\n});\n\n// file:src/parsing/ctts.js\nBoxParser.createFullBoxCtor(\"ctts\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.sample_counts = [];\n\tthis.sample_offsets = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_counts.push(stream.readUint32());\n\t\t\t/* some files are buggy and declare version=0 while using signed offsets.\n\t\t\t   The likelyhood of using the most significant bit in a 32-bits time offset is very low,\n\t\t\t   so using signed value here as well */\n\t\t\t   var value = stream.readInt32();\n\t\t\t   if (value < 0) {\n\t\t\t   \t\tLog.warn(\"BoxParser\", \"ctts box uses negative values without using version 1\");\n\t\t\t   }\n\t\t\tthis.sample_offsets.push(value);\n\t\t}\n\t} else if (this.version == 1) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_counts.push(stream.readUint32());\n\t\t\tthis.sample_offsets.push(stream.readInt32()); /* signed */\n\t\t}\n\t}\n});\n\n// file:src/parsing/dac3.js\nBoxParser.createBoxCtor(\"dac3\", function(stream) {\n\tvar tmp_byte1 = stream.readUint8();\n\tvar tmp_byte2 = stream.readUint8();\n\tvar tmp_byte3 = stream.readUint8();\n\tthis.fscod = tmp_byte1 >> 6;\n\tthis.bsid  = ((tmp_byte1 >> 1) & 0x1F);\n\tthis.bsmod = ((tmp_byte1 & 0x1) <<  2) | ((tmp_byte2 >> 6) & 0x3);\n\tthis.acmod = ((tmp_byte2 >> 3) & 0x7);\n\tthis.lfeon = ((tmp_byte2 >> 2) & 0x1);\n\tthis.bit_rate_code = (tmp_byte2 & 0x3) | ((tmp_byte3 >> 5) & 0x7);\n});\n\n// file:src/parsing/dec3.js\nBoxParser.createBoxCtor(\"dec3\", function(stream) {\n\tvar tmp_16 = stream.readUint16();\n\tthis.data_rate = tmp_16 >> 3;\n\tthis.num_ind_sub = tmp_16 & 0x7;\n\tthis.ind_subs = [];\n\tfor (var i = 0; i < this.num_ind_sub+1; i++) {\n\t\tvar ind_sub = {};\n\t\tthis.ind_subs.push(ind_sub);\n\t\tvar tmp_byte1 = stream.readUint8();\n\t\tvar tmp_byte2 = stream.readUint8();\n\t\tvar tmp_byte3 = stream.readUint8();\n\t\tind_sub.fscod = tmp_byte1 >> 6;\n\t\tind_sub.bsid  = ((tmp_byte1 >> 1) & 0x1F);\n\t\tind_sub.bsmod = ((tmp_byte1 & 0x1) << 4) | ((tmp_byte2 >> 4) & 0xF);\n\t\tind_sub.acmod = ((tmp_byte2 >> 1) & 0x7);\n\t\tind_sub.lfeon = (tmp_byte2 & 0x1);\n\t\tind_sub.num_dep_sub = ((tmp_byte3 >> 1) & 0xF);\n\t\tif (ind_sub.num_dep_sub > 0) {\n\t\t\tind_sub.chan_loc = ((tmp_byte3 & 0x1) << 8) | stream.readUint8();\n\t\t}\n\t}\n});\n\n// file:src/parsing/dfLa.js\nBoxParser.createFullBoxCtor(\"dfLa\", function(stream) {\n    var BLOCKTYPE_MASK = 0x7F;\n    var LASTMETADATABLOCKFLAG_MASK = 0x80;\n\n    var boxesFound = [];\n    var knownBlockTypes = [\n        \"STREAMINFO\",\n        \"PADDING\",\n        \"APPLICATION\",\n        \"SEEKTABLE\",\n        \"VORBIS_COMMENT\",\n        \"CUESHEET\",\n        \"PICTURE\",\n        \"RESERVED\"\n    ];\n\n    // dfLa is a FullBox\n    this.parseFullHeader(stream);\n\n    // for (i=0; ; i++) { // to end of box\n    do {\n        var flagAndType = stream.readUint8();\n\n        var type = Math.min(\n            (flagAndType & BLOCKTYPE_MASK),\n            (knownBlockTypes.length - 1)\n        );\n\n        // if this is a STREAMINFO block, read the true samplerate since this\n        // can be different to the AudioSampleEntry samplerate.\n        if (!(type)) {\n            // read past all the other stuff\n            stream.readUint8Array(13);\n\n            // extract samplerate\n            this.samplerate = (stream.readUint32() >> 12);\n\n            // read to end of STREAMINFO\n            stream.readUint8Array(20);\n        } else {\n            // not interested in other block types so just discard length bytes\n            stream.readUint8Array(stream.readUint24());\n        }\n\n        boxesFound.push(knownBlockTypes[type]);\n\n        if (!!(flagAndType & LASTMETADATABLOCKFLAG_MASK)) {\n            break;\n        }\n    } while (true);\n\n    this.numMetadataBlocks =\n        boxesFound.length + \" (\" + boxesFound.join(\", \") + \")\";\n});\n// file:src/parsing/dimm.js\nBoxParser.createBoxCtor(\"dimm\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/dmax.js\nBoxParser.createBoxCtor(\"dmax\", function(stream) {\n\tthis.time = stream.readUint32();\n});\n\n// file:src/parsing/dmed.js\nBoxParser.createBoxCtor(\"dmed\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/dref.js\nBoxParser.createFullBoxCtor(\"dref\", function(stream) {\n\tvar ret;\n\tvar box;\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\tthis.entries.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/drep.js\nBoxParser.createBoxCtor(\"drep\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/elng.js\nBoxParser.createFullBoxCtor(\"elng\", function(stream) {\n\tthis.extended_language = stream.readString(this.size-this.hdr_size);\n});\n\n// file:src/parsing/elst.js\nBoxParser.createFullBoxCtor(\"elst\", function(stream) {\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tvar entry = {};\n\t\tthis.entries.push(entry);\n\t\tif (this.version === 1) {\n\t\t\tentry.segment_duration = stream.readUint64();\n\t\t\tentry.media_time = stream.readInt64();\n\t\t} else {\n\t\t\tentry.segment_duration = stream.readUint32();\n\t\t\tentry.media_time = stream.readInt32();\n\t\t}\n\t\tentry.media_rate_integer = stream.readInt16();\n\t\tentry.media_rate_fraction = stream.readInt16();\n\t}\n});\n\n// file:src/parsing/emsg.js\nBoxParser.createFullBoxCtor(\"emsg\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.timescale \t\t\t\t\t= stream.readUint32();\n\t\tthis.presentation_time \t\t\t= stream.readUint64();\n\t\tthis.event_duration\t\t\t \t= stream.readUint32();\n\t\tthis.id \t\t\t\t\t\t= stream.readUint32();\n\t\tthis.scheme_id_uri \t\t\t\t= stream.readCString();\n\t\tthis.value \t\t\t\t\t\t= stream.readCString();\n\t} else {\n\t\tthis.scheme_id_uri \t\t\t\t= stream.readCString();\n\t\tthis.value \t\t\t\t\t\t= stream.readCString();\n\t\tthis.timescale \t\t\t\t\t= stream.readUint32();\n\t\tthis.presentation_time_delta \t= stream.readUint32();\n\t\tthis.event_duration\t\t\t \t= stream.readUint32();\n\t\tthis.id \t\t\t\t\t\t= stream.readUint32();\n\t}\n\tvar message_size = this.size - this.hdr_size - (4*4 + (this.scheme_id_uri.length+1) + (this.value.length+1));\n\tif (this.version == 1) {\n\t\tmessage_size -= 4;\n\t}\n\tthis.message_data = stream.readUint8Array(message_size);\n});\n\n// file:src/parsing/esds.js\nBoxParser.createFullBoxCtor(\"esds\", function(stream) {\n\tvar esd_data = stream.readUint8Array(this.size-this.hdr_size);\n\tif (typeof MPEG4DescriptorParser !== \"undefined\") {\n\t\tvar esd_parser = new MPEG4DescriptorParser();\n\t\tthis.esd = esd_parser.parseOneDescriptor(new DataStream(esd_data.buffer, 0, DataStream.BIG_ENDIAN));\n\t}\n});\n\n// file:src/parsing/fiel.js\nBoxParser.createBoxCtor(\"fiel\", function(stream) {\n\tthis.fieldCount = stream.readUint8();\n\tthis.fieldOrdering = stream.readUint8();\n});\n\n// file:src/parsing/frma.js\nBoxParser.createBoxCtor(\"frma\", function(stream) {\n\tthis.data_format = stream.readString(4);\n});\n\n// file:src/parsing/ftyp.js\nBoxParser.createBoxCtor(\"ftyp\", function(stream) {\n\tvar toparse = this.size - this.hdr_size;\n\tthis.major_brand = stream.readString(4);\n\tthis.minor_version = stream.readUint32();\n\ttoparse -= 8;\n\tthis.compatible_brands = [];\n\tvar i = 0;\n\twhile (toparse>=4) {\n\t\tthis.compatible_brands[i] = stream.readString(4);\n\t\ttoparse -= 4;\n\t\ti++;\n\t}\n});\n\n// file:src/parsing/hdlr.js\nBoxParser.createFullBoxCtor(\"hdlr\", function(stream) {\n\tif (this.version === 0) {\n\t\tstream.readUint32();\n\t\tthis.handler = stream.readString(4);\n\t\tstream.readUint32Array(3);\n\t\tthis.name = stream.readString(this.size-this.hdr_size-20);\n\t\tif (this.name[this.name.length-1]==='\\0') {\n\t\t\tthis.name = this.name.slice(0,-1);\n\t\t}\n\t}\n});\n\n// file:src/parsing/hvcC.js\nBoxParser.createBoxCtor(\"hvcC\", function(stream) {\n\tvar i, j;\n\tvar length;\n\tvar tmp_byte;\n\tthis.configurationVersion = stream.readUint8();\n\ttmp_byte = stream.readUint8();\n\tthis.general_profile_space = tmp_byte >> 6;\n\tthis.general_tier_flag = (tmp_byte & 0x20) >> 5;\n\tthis.general_profile_idc = (tmp_byte & 0x1F);\n\tthis.general_profile_compatibility = stream.readUint32();\n\tthis.general_constraint_indicator = stream.readUint8Array(6);\n\tthis.general_level_idc = stream.readUint8();\n\tthis.min_spatial_segmentation_idc = stream.readUint16() & 0xFFF;\n\tthis.parallelismType = (stream.readUint8() & 0x3);\n\tthis.chroma_format_idc = (stream.readUint8() & 0x3);\n\tthis.bit_depth_luma_minus8 = (stream.readUint8() & 0x7);\n\tthis.bit_depth_chroma_minus8 = (stream.readUint8() & 0x7);\n\tthis.avgFrameRate = stream.readUint16();\n\ttmp_byte = stream.readUint8();\n\tthis.constantFrameRate = (tmp_byte >> 6);\n\tthis.numTemporalLayers = (tmp_byte & 0XD) >> 3;\n\tthis.temporalIdNested = (tmp_byte & 0X4) >> 2;\n\tthis.lengthSizeMinusOne = (tmp_byte & 0X3);\n\n\tthis.nalu_arrays = [];\n\tvar numOfArrays = stream.readUint8();\n\tfor (i = 0; i < numOfArrays; i++) {\n\t\tvar nalu_array = [];\n\t\tthis.nalu_arrays.push(nalu_array);\n\t\ttmp_byte = stream.readUint8();\n\t\tnalu_array.completeness = (tmp_byte & 0x80) >> 7;\n\t\tnalu_array.nalu_type = tmp_byte & 0x3F;\n\t\tvar numNalus = stream.readUint16();\n\t\tfor (j = 0; j < numNalus; j++) {\n\t\t\tvar nalu = {};\n\t\t\tnalu_array.push(nalu);\n\t\t\tlength = stream.readUint16();\n\t\t\tnalu.data   = stream.readUint8Array(length);\n\t\t}\n\t}\n});\n\n// file:src/parsing/iinf.js\nBoxParser.createFullBoxCtor(\"iinf\", function(stream) {\n\tvar ret;\n\tif (this.version === 0) {\n\t\tthis.entry_count = stream.readUint16();\n\t} else {\n\t\tthis.entry_count = stream.readUint32();\n\t}\n\tthis.item_infos = [];\n\tfor (var i = 0; i < this.entry_count; i++) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tif (ret.box.type !== \"infe\") {\n\t\t\t\tLog.error(\"BoxParser\", \"Expected 'infe' box, got \"+ret.box.type);\n\t\t\t}\n\t\t\tthis.item_infos[i] = ret.box;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/iloc.js\nBoxParser.createFullBoxCtor(\"iloc\", function(stream) {\n\tvar byte;\n\tbyte = stream.readUint8();\n\tthis.offset_size = (byte >> 4) & 0xF;\n\tthis.length_size = byte & 0xF;\n\tbyte = stream.readUint8();\n\tthis.base_offset_size = (byte >> 4) & 0xF;\n\tif (this.version === 1 || this.version === 2) {\n\t\tthis.index_size = byte & 0xF;\n\t} else {\n\t\tthis.index_size = 0;\n\t\t// reserved = byte & 0xF;\n\t}\n\tthis.items = [];\n\tvar item_count = 0;\n\tif (this.version < 2) {\n\t\titem_count = stream.readUint16();\n\t} else if (this.version === 2) {\n\t\titem_count = stream.readUint32();\n\t} else {\n\t\tthrow \"version of iloc box not supported\";\n\t}\n\tfor (var i = 0; i < item_count; i++) {\n\t\tvar item = {};\n\t\tthis.items.push(item);\n\t\tif (this.version < 2) {\n\t\t\titem.item_ID = stream.readUint16();\n\t\t} else if (this.version === 2) {\n\t\t\titem.item_ID = stream.readUint16();\n\t\t} else {\n\t\t\tthrow \"version of iloc box not supported\";\n\t\t}\n\t\tif (this.version === 1 || this.version === 2) {\n\t\t\titem.construction_method = (stream.readUint16() & 0xF);\n\t\t} else {\n\t\t\titem.construction_method = 0;\n\t\t}\n\t\titem.data_reference_index = stream.readUint16();\n\t\tswitch(this.base_offset_size) {\n\t\t\tcase 0:\n\t\t\t\titem.base_offset = 0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\titem.base_offset = stream.readUint32();\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\titem.base_offset = stream.readUint64();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"Error reading base offset size\";\n\t\t}\n\t\tvar extent_count = stream.readUint16();\n\t\titem.extents = [];\n\t\tfor (var j=0; j < extent_count; j++) {\n\t\t\tvar extent = {};\n\t\t\titem.extents.push(extent);\n\t\t\tif (this.version === 1 || this.version === 2) {\n\t\t\t\tswitch(this.index_size) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\textent.extent_index = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\textent.extent_index = stream.readUint32();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\textent.extent_index = stream.readUint64();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Error reading extent index\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch(this.offset_size) {\n\t\t\t\tcase 0:\n\t\t\t\t\textent.extent_offset = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\textent.extent_offset = stream.readUint32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\textent.extent_offset = stream.readUint64();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Error reading extent index\";\n\t\t\t}\n\t\t\tswitch(this.length_size) {\n\t\t\t\tcase 0:\n\t\t\t\t\textent.extent_length = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\textent.extent_length = stream.readUint32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\textent.extent_length = stream.readUint64();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Error reading extent index\";\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/imir.js\nBoxParser.createBoxCtor(\"imir\", function(stream) {\n\tvar tmp = stream.readUint8();\n\tthis.reserved = tmp >> 7;\n\tthis.axis = tmp & 1;\n});// file:src/parsing/infe.js\nBoxParser.createFullBoxCtor(\"infe\", function(stream) {\n\tif (this.version === 0 || this.version === 1) {\n\t\tthis.item_ID = stream.readUint16();\n\t\tthis.item_protection_index = stream.readUint16();\n\t\tthis.item_name = stream.readCString();\n\t\tthis.content_type = stream.readCString();\n\t\tthis.content_encoding = stream.readCString();\n\t}\n\tif (this.version === 1) {\n\t\tthis.extension_type = stream.readString(4);\n\t\tLog.warn(\"BoxParser\", \"Cannot parse extension type\");\n\t\tstream.seek(this.start+this.size);\n\t\treturn;\n\t}\n\tif (this.version >= 2) {\n\t\tif (this.version === 2) {\n\t\t\tthis.item_ID = stream.readUint16();\n\t\t} else if (this.version === 3) {\n\t\t\tthis.item_ID = stream.readUint32();\n\t\t}\n\t\tthis.item_protection_index = stream.readUint16();\n\t\tthis.item_type = stream.readString(4);\n\t\tthis.item_name = stream.readCString();\n\t\tif (this.item_type === \"mime\") {\n\t\t\tthis.content_type = stream.readCString();\n\t\t\tthis.content_encoding = stream.readCString();\n\t\t} else if (this.item_type === \"uri \") {\n\t\t\tthis.item_uri_type = stream.readCString();\n\t\t}\n\t}\n});\n// file:src/parsing/ipma.js\nBoxParser.createFullBoxCtor(\"ipma\", function(stream) {\n\tvar i, j;\n\tentry_count = stream.readUint32();\n\tthis.associations = [];\n\tfor(i=0; i<entry_count; i++) {\n\t\tvar item_assoc = {};\n\t\tthis.associations.push(item_assoc);\n\t\tif (this.version < 1) {\n\t\t\titem_assoc.id = stream.readUint16();\n\t\t} else {\n\t\t\titem_assoc.id = stream.readUint32();\n\t\t}\n\t\tvar association_count = stream.readUint8();\n\t\titem_assoc.props = [];\n\t\tfor (j = 0; j < association_count; j++) {\n\t\t\tvar tmp = stream.readUint8();\n\t\t\tvar p = {};\n\t\t\titem_assoc.props.push(p);\n\t\t\tp.essential = ((tmp & 0x80) >> 7) === 1;\n\t\t\tif (this.flags & 0x1) {\n\t\t\t\tp.property_index = (tmp & 0x7F) << 8 | stream.readUint8();\n\t\t\t} else {\n\t\t\t\tp.property_index = (tmp & 0x7F);\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/iref.js\nBoxParser.createFullBoxCtor(\"iref\", function(stream) {\n\tvar ret;\n\tvar box;\n\tthis.references = [];\n\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tif (this.version === 0) {\n\t\t\t\tbox = new BoxParser.SingleItemTypeReferenceBox(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\t} else {\n\t\t\t\tbox = new BoxParser.SingleItemTypeReferenceBoxLarge(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\t}\n\t\t\tif (box.write === BoxParser.Box.prototype.write && box.type !== \"mdat\") {\n\t\t\t\tLog.warn(\"BoxParser\", box.type+\" box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t\tbox.parseDataAndRewind(stream);\n\t\t\t}\n\t\t\tbox.parse(stream);\n\t\t\tthis.references.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n// file:src/parsing/irot.js\nBoxParser.createBoxCtor(\"irot\", function(stream) {\n\tthis.angle = stream.readUint8() & 0x3;\n});\n\n// file:src/parsing/ispe.js\nBoxParser.createFullBoxCtor(\"ispe\", function(stream) {\n\tthis.image_width = stream.readUint32();\n\tthis.image_height = stream.readUint32();\n});// file:src/parsing/kind.js\nBoxParser.createFullBoxCtor(\"kind\", function(stream) {\n\tthis.schemeURI = stream.readCString();\n\tthis.value = stream.readCString();\n});\n// file:src/parsing/leva.js\nBoxParser.createFullBoxCtor(\"leva\", function(stream) {\n\tvar count = stream.readUint8();\n\tthis.levels = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tvar level = {};\n\t\tthis.levels[i] = level;\n\t\tlevel.track_ID = stream.readUint32();\n\t\tvar tmp_byte = stream.readUint8();\n\t\tlevel.padding_flag = tmp_byte >> 7;\n\t\tlevel.assignment_type = tmp_byte & 0x7F;\n\t\tswitch (level.assignment_type) {\n\t\t\tcase 0:\n\t\t\t\tlevel.grouping_type = stream.readString(4);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlevel.grouping_type = stream.readString(4);\n\t\t\t\tlevel.grouping_type_parameter = stream.readUint32();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tlevel.sub_track_id = stream.readUint32();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLog.warn(\"BoxParser\", \"Unknown leva assignement type\");\n\t\t}\n\t}\n});\n\n// file:src/parsing/lsel.js\nBoxParser.createBoxCtor(\"lsel\", function(stream) {\n\tthis.layer_id = stream.readUint16();\n});// file:src/parsing/maxr.js\nBoxParser.createBoxCtor(\"maxr\", function(stream) {\n\tthis.period = stream.readUint32();\n\tthis.bytes = stream.readUint32();\n});\n\n// file:src/parsing/mdcv.js\nBoxParser.createBoxCtor(\"mdcv\", function(stream) {\n    this.display_primaries = [];\n    this.display_primaries[0] = {};\n    this.display_primaries[0].x = stream.readUint16();\n    this.display_primaries[0].y = stream.readUint16();\n    this.display_primaries[1] = {};\n    this.display_primaries[1].x = stream.readUint16();\n    this.display_primaries[1].y = stream.readUint16();\n    this.display_primaries[2] = {};\n    this.display_primaries[2].x = stream.readUint16();\n    this.display_primaries[2].y = stream.readUint16();\n    this.white_point = {};\n    this.white_point.x = stream.readUint16();\n    this.white_point.y = stream.readUint16();\n    this.max_display_mastering_luminance = stream.readUint32();\n    this.min_display_mastering_luminance = stream.readUint32();\n});\n\n// file:src/parsing/mdhd.js\nBoxParser.createFullBoxCtor(\"mdhd\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.creation_time = stream.readUint64();\n\t\tthis.modification_time = stream.readUint64();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint64();\n\t} else {\n\t\tthis.creation_time = stream.readUint32();\n\t\tthis.modification_time = stream.readUint32();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint32();\n\t}\n\tthis.parseLanguage(stream);\n\tstream.readUint16();\n});\n\n// file:src/parsing/mehd.js\nBoxParser.createFullBoxCtor(\"mehd\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tLog.warn(\"BoxParser\", \"mehd box incorrectly uses flags set to 1, converting version to 1\");\n\t\tthis.version = 1;\n\t}\n\tif (this.version == 1) {\n\t\tthis.fragment_duration = stream.readUint64();\n\t} else {\n\t\tthis.fragment_duration = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/meta.js\nBoxParser.createFullBoxCtor(\"meta\", function(stream) {\n\tthis.boxes = [];\n\tBoxParser.ContainerBox.prototype.parse.call(this, stream);\n});\n// file:src/parsing/mfhd.js\nBoxParser.createFullBoxCtor(\"mfhd\", function(stream) {\n\tthis.sequence_number = stream.readUint32();\n});\n\n// file:src/parsing/mfro.js\nBoxParser.createFullBoxCtor(\"mfro\", function(stream) {\n\tthis._size = stream.readUint32();\n});\n\n// file:src/parsing/mvhd.js\nBoxParser.createFullBoxCtor(\"mvhd\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.creation_time = stream.readUint64();\n\t\tthis.modification_time = stream.readUint64();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint64();\n\t} else {\n\t\tthis.creation_time = stream.readUint32();\n\t\tthis.modification_time = stream.readUint32();\n\t\tthis.timescale = stream.readUint32();\n\t\tthis.duration = stream.readUint32();\n\t}\n\tthis.rate = stream.readUint32();\n\tthis.volume = stream.readUint16()>>8;\n\tstream.readUint16();\n\tstream.readUint32Array(2);\n\tthis.matrix = stream.readUint32Array(9);\n\tstream.readUint32Array(6);\n\tthis.next_track_id = stream.readUint32();\n});\n// file:src/parsing/npck.js\nBoxParser.createBoxCtor(\"npck\", function(stream) {\n\tthis.packetssent = stream.readUint32();\n});\n\n// file:src/parsing/nump.js\nBoxParser.createBoxCtor(\"nump\", function(stream) {\n\tthis.packetssent = stream.readUint64();\n});\n\n// file:src/parsing/padb.js\nBoxParser.createFullBoxCtor(\"padb\", function(stream) {\n\tvar sample_count = stream.readUint32();\n\tthis.padbits = [];\n\tfor (var i = 0; i < Math.floor((sample_count+1)/2); i++) {\n\t\tthis.padbits = stream.readUint8();\n\t}\n});\n\n// file:src/parsing/pasp.js\nBoxParser.createBoxCtor(\"pasp\", function(stream) {\n\tthis.hSpacing = stream.readUint32();\n\tthis.vSpacing = stream.readUint32();\n});// file:src/parsing/payl.js\nBoxParser.createBoxCtor(\"payl\", function(stream) {\n\tthis.text = stream.readString(this.size - this.hdr_size);\n});\n\n// file:src/parsing/payt.js\nBoxParser.createBoxCtor(\"payt\", function(stream) {\n\tthis.payloadID = stream.readUint32();\n\tvar count = stream.readUint8();\n\tthis.rtpmap_string = stream.readString(count);\n});\n\n// file:src/parsing/pdin.js\nBoxParser.createFullBoxCtor(\"pdin\", function(stream) {\n\tvar count = (this.size - this.hdr_size)/8;\n\tthis.rate = [];\n\tthis.initial_delay = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.rate[i] = stream.readUint32();\n\t\tthis.initial_delay[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/pitm.js\nBoxParser.createFullBoxCtor(\"pitm\", function(stream) {\n\tif (this.version === 0) {\n\t\tthis.item_id = stream.readUint16();\n\t} else {\n\t\tthis.item_id = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/pixi.js\nBoxParser.createFullBoxCtor(\"pixi\", function(stream) {\n\tvar i;\n\tthis.num_channels = stream.readUint8();\n\tthis.bits_per_channels = [];\n\tfor (i = 0; i < this.num_channels; i++) {\n\t\tthis.bits_per_channels[i] = stream.readUint8();\n\t}\n});\n\n// file:src/parsing/pmax.js\nBoxParser.createBoxCtor(\"pmax\", function(stream) {\n\tthis.bytes = stream.readUint32();\n});\n\n// file:src/parsing/prft.js\nBoxParser.createFullBoxCtor(\"prft\", function(stream) {\n\tthis.ref_track_id = stream.readUint32();\n\tthis.ntp_timestamp = stream.readUint64();\n\tif (this.version === 0) {\n\t\tthis.media_time = stream.readUint32();\n\t} else {\n\t\tthis.media_time = stream.readUint64();\n\t}\n});\n\n// file:src/parsing/pssh.js\nBoxParser.createFullBoxCtor(\"pssh\", function(stream) {\n\tthis.system_id = BoxParser.parseHex16(stream);\n\tif (this.version > 0) {\n\t\tvar count = stream.readUint32();\n\t\tthis.kid = [];\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tthis.kid[i] = BoxParser.parseHex16(stream);\n\t\t}\n\t}\n\tvar datasize = stream.readUint32();\n\tif (datasize > 0) {\n\t\tthis.data = stream.readUint8Array(datasize);\n\t}\n});\n\n// file:src/parsing/qt/clef.js\nBoxParser.createFullBoxCtor(\"clef\", function(stream) {\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});// file:src/parsing/qt/enof.js\nBoxParser.createFullBoxCtor(\"enof\", function(stream) {\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});// file:src/parsing/qt/prof.js\nBoxParser.createFullBoxCtor(\"prof\", function(stream) {\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});// file:src/parsing/qt/tapt.js\nBoxParser.createContainerBoxCtor(\"tapt\", null, [ \"clef\", \"prof\", \"enof\"]);// file:src/parsing/rtp.js\nBoxParser.createBoxCtor(\"rtp \", function(stream) {\n\tthis.descriptionformat = stream.readString(4);\n\tthis.sdptext = stream.readString(this.size - this.hdr_size - 4);\n});\n\n// file:src/parsing/saio.js\nBoxParser.createFullBoxCtor(\"saio\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.aux_info_type = stream.readUint32();\n\t\tthis.aux_info_type_parameter = stream.readUint32();\n\t}\n\tvar count = stream.readUint32();\n\tthis.offset = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tif (this.version === 0) {\n\t\t\tthis.offset[i] = stream.readUint32();\n\t\t} else {\n\t\t\tthis.offset[i] = stream.readUint64();\n\t\t}\n\t}\n});\n// file:src/parsing/saiz.js\nBoxParser.createFullBoxCtor(\"saiz\", function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.aux_info_type = stream.readUint32();\n\t\tthis.aux_info_type_parameter = stream.readUint32();\n\t}\n\tthis.default_sample_info_size = stream.readUint8();\n\tvar count = stream.readUint32();\n\tthis.sample_info_size = [];\n\tif (this.default_sample_info_size === 0) {\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tthis.sample_info_size[i] = stream.readUint8();\n\t\t}\n\t}\n});\n\n// file:src/parsing/sampleentries/mett.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"mett\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.mime_format = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/metx.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"metx\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.namespace = stream.readCString();\n\tthis.schema_location = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/sbtt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"sbtt\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.mime_format = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/stpp.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stpp\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.namespace = stream.readCString();\n\tthis.schema_location = stream.readCString();\n\tthis.auxiliary_mime_types = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/stxt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"stxt\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.content_encoding = stream.readCString();\n\tthis.mime_format = stream.readCString();\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/sampleentries/tx3g.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, \"tx3g\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.displayFlags = stream.readUint32();\n\tthis.horizontal_justification = stream.readInt8();\n\tthis.vertical_justification = stream.readInt8();\n\tthis.bg_color_rgba = stream.readUint8Array(4);\n\tthis.box_record = stream.readInt16Array(4);\n\tthis.style_record = stream.readUint8Array(12);\n\tthis.parseFooter(stream);\n});\n// file:src/parsing/sampleentries/wvtt.js\nBoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, \"wvtt\", function(stream) {\n\tthis.parseHeader(stream);\n\tthis.parseFooter(stream);\n});\n\n// file:src/parsing/samplegroups/alst.js\nBoxParser.createSampleGroupCtor(\"alst\", function(stream) {\n\tvar i;\n\tvar roll_count = stream.readUint16();\n\tthis.first_output_sample = stream.readUint16();\n\tthis.sample_offset = [];\n\tfor (i = 0; i < roll_count; i++) {\n\t\tthis.sample_offset[i] = stream.readUint32();\n\t}\n\tvar remaining = this.description_length - 4 - 4*roll_count;\n\tthis.num_output_samples = [];\n\tthis.num_total_samples = [];\n\tfor (i = 0; i < remaining/4; i++) {\n\t\tthis.num_output_samples[i] = stream.readUint16();\n\t\tthis.num_total_samples[i] = stream.readUint16();\n\t}\n});\n\n// file:src/parsing/samplegroups/avll.js\nBoxParser.createSampleGroupCtor(\"avll\", function(stream) {\n\tthis.layerNumber = stream.readUint8();\n\tthis.accurateStatisticsFlag = stream.readUint8();\n\tthis.avgBitRate = stream.readUint16();\n\tthis.avgFrameRate = stream.readUint16();\n});\n\n// file:src/parsing/samplegroups/avss.js\nBoxParser.createSampleGroupCtor(\"avss\", function(stream) {\n\tthis.subSequenceIdentifier = stream.readUint16();\n\tthis.layerNumber = stream.readUint8();\n\tvar tmp_byte = stream.readUint8();\n\tthis.durationFlag = tmp_byte >> 7;\n\tthis.avgRateFlag = (tmp_byte >> 6) & 0x1;\n\tif (this.durationFlag) {\n\t\tthis.duration = stream.readUint32();\n\t}\n\tif (this.avgRateFlag) {\n\t\tthis.accurateStatisticsFlag = stream.readUint8();\n\t\tthis.avgBitRate = stream.readUint16();\n\t\tthis.avgFrameRate = stream.readUint16();\n\t}\n\tthis.dependency = [];\n\tvar numReferences = stream.readUint8();\n\tfor (var i = 0; i < numReferences; i++) {\n\t\tvar dependencyInfo = {};\n\t\tthis.dependency.push(dependencyInfo);\n\t\tdependencyInfo.subSeqDirectionFlag = stream.readUint8();\n\t\tdependencyInfo.layerNumber = stream.readUint8();\n\t\tdependencyInfo.subSequenceIdentifier = stream.readUint16();\n\t}\n});\n\n// file:src/parsing/samplegroups/dtrt.js\nBoxParser.createSampleGroupCtor(\"dtrt\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/mvif.js\nBoxParser.createSampleGroupCtor(\"mvif\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/prol.js\nBoxParser.createSampleGroupCtor(\"prol\", function(stream) {\n\tthis.roll_distance = stream.readInt16();\n});\n\n// file:src/parsing/samplegroups/rap.js\nBoxParser.createSampleGroupCtor(\"rap \", function(stream) {\n\tvar tmp_byte = stream.readUint8();\n\tthis.num_leading_samples_known = tmp_byte >> 7;\n\tthis.num_leading_samples = tmp_byte & 0x7F;\n});\n\n// file:src/parsing/samplegroups/rash.js\nBoxParser.createSampleGroupCtor(\"rash\", function(stream) {\n\tthis.operation_point_count = stream.readUint16();\n\tif (this.description_length !== 2+(this.operation_point_count === 1?2:this.operation_point_count*6)+9) {\n\t\tLog.warn(\"BoxParser\", \"Mismatch in \"+this.grouping_type+\" sample group length\");\n\t\tthis.data =  stream.readUint8Array(this.description_length-2);\n\t} else {\n\t\tif (this.operation_point_count === 1) {\n\t\t\tthis.target_rate_share = stream.readUint16();\n\t\t} else {\n\t\t\tthis.target_rate_share = [];\n\t\t\tthis.available_bitrate = [];\n\t\t\tfor (var i = 0; i < this.operation_point_count; i++) {\n\t\t\t\tthis.available_bitrate[i] = stream.readUint32();\n\t\t\t\tthis.target_rate_share[i] = stream.readUint16();\n\t\t\t}\n\t\t}\n\t\tthis.maximum_bitrate = stream.readUint32();\n\t\tthis.minimum_bitrate = stream.readUint32();\n\t\tthis.discard_priority = stream.readUint8();\n\t}\n});\n\n// file:src/parsing/samplegroups/roll.js\nBoxParser.createSampleGroupCtor(\"roll\", function(stream) {\n\tthis.roll_distance = stream.readInt16();\n});\n\n// file:src/parsing/samplegroups/samplegroup.js\nBoxParser.SampleGroupEntry.prototype.parse = function(stream) {\n\tLog.warn(\"BoxParser\", \"Unknown Sample Group type: \"+this.grouping_type);\n\tthis.data =  stream.readUint8Array(this.description_length);\n};\n\n// file:src/parsing/samplegroups/scif.js\nBoxParser.createSampleGroupCtor(\"scif\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/scnm.js\nBoxParser.createSampleGroupCtor(\"scnm\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/seig.js\nBoxParser.createSampleGroupCtor(\"seig\", function(stream) {\n\tthis.reserved = stream.readUint8();\n\tvar tmp = stream.readUint8();\n\tthis.crypt_byte_block = tmp >> 4;\n\tthis.skip_byte_block = tmp & 0xF;\n\tthis.isProtected = stream.readUint8();\n\tthis.Per_Sample_IV_Size = stream.readUint8();\n\tthis.KID = BoxParser.parseHex16(stream);\n\tthis.constant_IV_size = 0;\n\tthis.constant_IV = 0;\n\tif (this.isProtected === 1 && this.Per_Sample_IV_Size === 0) {\n\t\tthis.constant_IV_size = stream.readUint8();\n\t\tthis.constant_IV = stream.readUint8Array(this.constant_IV_size);\n\t}\n});\n\n// file:src/parsing/samplegroups/stsa.js\nBoxParser.createSampleGroupCtor(\"stsa\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/sync.js\nBoxParser.createSampleGroupCtor(\"sync\", function(stream) {\n\tvar tmp_byte = stream.readUint8();\n\tthis.NAL_unit_type = tmp_byte & 0x3F;\n});\n\n// file:src/parsing/samplegroups/tele.js\nBoxParser.createSampleGroupCtor(\"tele\", function(stream) {\n\tvar tmp_byte = stream.readUint8();\n\tthis.level_independently_decodable = tmp_byte >> 7;\n});\n\n// file:src/parsing/samplegroups/tsas.js\nBoxParser.createSampleGroupCtor(\"tsas\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/tscl.js\nBoxParser.createSampleGroupCtor(\"tscl\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/samplegroups/vipr.js\nBoxParser.createSampleGroupCtor(\"vipr\", function(stream) {\n\tLog.warn(\"BoxParser\", \"Sample Group type: \"+this.grouping_type+\" not fully parsed\");\n});\n\n// file:src/parsing/sbgp.js\nBoxParser.createFullBoxCtor(\"sbgp\", function(stream) {\n\tthis.grouping_type = stream.readString(4);\n\tif (this.version === 1) {\n\t\tthis.grouping_type_parameter = stream.readUint32();\n\t} else {\n\t\tthis.grouping_type_parameter = 0;\n\t}\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tvar entry = {};\n\t\tthis.entries.push(entry);\n\t\tentry.sample_count = stream.readInt32();\n\t\tentry.group_description_index = stream.readInt32();\n\t}\n});\n\n// file:src/parsing/schm.js\nBoxParser.createFullBoxCtor(\"schm\", function(stream) {\n\tthis.scheme_type = stream.readString(4);\n\tthis.scheme_version = stream.readUint32();\n\tif (this.flags & 0x000001) {\n\t\tthis.scheme_uri = stream.readString(this.size - this.hdr_size - 8);\n\t}\n});\n\n// file:src/parsing/sdp.js\nBoxParser.createBoxCtor(\"sdp \", function(stream) {\n\tthis.sdptext = stream.readString(this.size - this.hdr_size);\n});\n\n// file:src/parsing/sdtp.js\nBoxParser.createFullBoxCtor(\"sdtp\", function(stream) {\n\tvar tmp_byte;\n\tvar count = (this.size - this.hdr_size);\n\tthis.is_leading = [];\n\tthis.sample_depends_on = [];\n\tthis.sample_is_depended_on = [];\n\tthis.sample_has_redundancy = [];\n\tfor (var i = 0; i < count; i++) {\n\t\ttmp_byte = stream.readUint8();\n\t\tthis.is_leading[i] = tmp_byte >> 6;\n\t\tthis.sample_depends_on[i] = (tmp_byte >> 4) & 0x3;\n\t\tthis.sample_is_depended_on[i] = (tmp_byte >> 2) & 0x3;\n\t\tthis.sample_has_redundancy[i] = tmp_byte & 0x3;\n\t}\n});\n\n// file:src/parsing/senc.js\n// Cannot be fully parsed because Per_Sample_IV_Size needs to be known\r\nBoxParser.createFullBoxCtor(\"senc\" /*, function(stream) {\r\n\tthis.parseFullHeader(stream);\r\n\tvar sample_count = stream.readUint32();\r\n\tthis.samples = [];\r\n\tfor (var i = 0; i < sample_count; i++) {\r\n\t\tvar sample = {};\r\n\t\t// tenc.default_Per_Sample_IV_Size or seig.Per_Sample_IV_Size\r\n\t\tsample.InitializationVector = this.readUint8Array(Per_Sample_IV_Size*8);\r\n\t\tif (this.flags & 0x2) {\r\n\t\t\tsample.subsamples = [];\r\n\t\t\tsubsample_count = stream.readUint16();\r\n\t\t\tfor (var j = 0; j < subsample_count; j++) {\r\n\t\t\t\tvar subsample = {};\r\n\t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\r\n\t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\r\n\t\t\t\tsample.subsamples.push(subsample);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO\r\n\t\tthis.samples.push(sample);\r\n\t}\r\n}*/);\r\n// file:src/parsing/sgpd.js\nBoxParser.createFullBoxCtor(\"sgpd\", function(stream) {\n\tthis.grouping_type = stream.readString(4);\n\tLog.debug(\"BoxParser\", \"Found Sample Groups of type \"+this.grouping_type);\n\tif (this.version === 1) {\n\t\tthis.default_length = stream.readUint32();\n\t} else {\n\t\tthis.default_length = 0;\n\t}\n\tif (this.version >= 2) {\n\t\tthis.default_group_description_index = stream.readUint32();\n\t}\n\tthis.entries = [];\n\tvar entry_count = stream.readUint32();\n\tfor (var i = 0; i < entry_count; i++) {\n\t\tvar entry;\n\t\tif (BoxParser[this.grouping_type+\"SampleGroupEntry\"]) {\n\t\t\tentry = new BoxParser[this.grouping_type+\"SampleGroupEntry\"](this.grouping_type);\n\t\t}  else {\n\t\t\tentry = new BoxParser.SampleGroupEntry(this.grouping_type);\n\t\t}\n\t\tthis.entries.push(entry);\n\t\tif (this.version === 1) {\n\t\t\tif (this.default_length === 0) {\n\t\t\t\tentry.description_length = stream.readUint32();\n\t\t\t} else {\n\t\t\t\tentry.description_length = this.default_length;\n\t\t\t}\n\t\t} else {\n\t\t\tentry.description_length = this.default_length;\n\t\t}\n\t\tif (entry.write === BoxParser.SampleGroupEntry.prototype.write) {\n\t\t\tLog.info(\"BoxParser\", \"SampleGroup for type \"+this.grouping_type+\" writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t// storing data\n\t\t\tentry.data = stream.readUint8Array(entry.description_length);\n\t\t\t// rewinding\n\t\t\tstream.position -= entry.description_length;\n\t\t}\n\t\tentry.parse(stream);\n\t}\n});\n\n// file:src/parsing/sidx.js\nBoxParser.createFullBoxCtor(\"sidx\", function(stream) {\n\tthis.reference_ID = stream.readUint32();\n\tthis.timescale = stream.readUint32();\n\tif (this.version === 0) {\n\t\tthis.earliest_presentation_time = stream.readUint32();\n\t\tthis.first_offset = stream.readUint32();\n\t} else {\n\t\tthis.earliest_presentation_time = stream.readUint64();\n\t\tthis.first_offset = stream.readUint64();\n\t}\n\tstream.readUint16();\n\tthis.references = [];\n\tvar count = stream.readUint16();\n\tfor (var i = 0; i < count; i++) {\n\t\tvar ref = {};\n\t\tthis.references.push(ref);\n\t\tvar tmp_32 = stream.readUint32();\n\t\tref.reference_type = (tmp_32 >> 31) & 0x1;\n\t\tref.referenced_size = tmp_32 & 0x7FFFFFFF;\n\t\tref.subsegment_duration = stream.readUint32();\n\t\ttmp_32 = stream.readUint32();\n\t\tref.starts_with_SAP = (tmp_32 >> 31) & 0x1;\n\t\tref.SAP_type = (tmp_32 >> 28) & 0x7;\n\t\tref.SAP_delta_time = tmp_32 & 0xFFFFFFF;\n\t}\n});\n\n// file:src/parsing/singleitemtypereference.js\nBoxParser.SingleItemTypeReferenceBox = function(type, size, hdr_size, start) {\n\tBoxParser.Box.call(this, type, size);\n\tthis.hdr_size = hdr_size;\n\tthis.start = start;\n};\nBoxParser.SingleItemTypeReferenceBox.prototype = new BoxParser.Box();\nBoxParser.SingleItemTypeReferenceBox.prototype.parse = function(stream) {\n\tthis.from_item_ID = stream.readUint16();\n\tvar count =  stream.readUint16();\n\tthis.references = [];\n\tfor(var i = 0; i < count; i++) {\n\t\tthis.references[i] = stream.readUint16();\n\t}\n};\n\n// file:src/parsing/singleitemtypereferencelarge.js\nBoxParser.SingleItemTypeReferenceBoxLarge = function(type, size, hdr_size, start) {\n\tBoxParser.Box.call(this, type, size);\n\tthis.hdr_size = hdr_size;\n\tthis.start = start;\n};\nBoxParser.SingleItemTypeReferenceBoxLarge.prototype = new BoxParser.Box();\nBoxParser.SingleItemTypeReferenceBoxLarge.prototype.parse = function(stream) {\n\tthis.from_item_ID = stream.readUint32();\n\tvar count =  stream.readUint16();\n\tthis.references = [];\n\tfor(var i = 0; i < count; i++) {\n\t\tthis.references[i] = stream.readUint32();\n\t}\n};\n\n// file:src/parsing/SmDm.js\nBoxParser.createFullBoxCtor(\"SmDm\", function(stream) {\n\tthis.primaryRChromaticity_x = stream.readUint16();\n    this.primaryRChromaticity_y = stream.readUint16();\n    this.primaryGChromaticity_x = stream.readUint16();\n    this.primaryGChromaticity_y = stream.readUint16();\n    this.primaryBChromaticity_x = stream.readUint16();\n    this.primaryBChromaticity_y = stream.readUint16();\n    this.whitePointChromaticity_x = stream.readUint16();\n    this.whitePointChromaticity_y = stream.readUint16();\n    this.luminanceMax = stream.readUint32();\n    this.luminanceMin = stream.readUint32();\n});\n\n// file:src/parsing/smhd.js\nBoxParser.createFullBoxCtor(\"smhd\", function(stream) {\n\tthis.balance = stream.readUint16();\n\tstream.readUint16();\n});\n\n// file:src/parsing/ssix.js\nBoxParser.createFullBoxCtor(\"ssix\", function(stream) {\n\tthis.subsegments = [];\n\tvar subsegment_count = stream.readUint32();\n\tfor (var i = 0; i < subsegment_count; i++) {\n\t\tvar subsegment = {};\n\t\tthis.subsegments.push(subsegment);\n\t\tsubsegment.ranges = [];\n\t\tvar range_count = stream.readUint32();\n\t\tfor (var j = 0; j < range_count; j++) {\n\t\t\tvar range = {};\n\t\t\tsubsegment.ranges.push(range);\n\t\t\trange.level = stream.readUint8();\n\t\t\trange.range_size = stream.readUint24();\n\t\t}\n\t}\n});\n\n// file:src/parsing/stco.js\nBoxParser.createFullBoxCtor(\"stco\", function(stream) {\n\tvar entry_count;\n\tentry_count = stream.readUint32();\n\tthis.chunk_offsets = [];\n\tif (this.version === 0) {\n\t\tfor (var i = 0; i < entry_count; i++) {\n\t\t\tthis.chunk_offsets.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stdp.js\nBoxParser.createFullBoxCtor(\"stdp\", function(stream) {\n\tvar count = (this.size - this.hdr_size)/2;\n\tthis.priority = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.priority[i] = stream.readUint16();\n\t}\n});\n\n// file:src/parsing/sthd.js\nBoxParser.createFullBoxCtor(\"sthd\");\n\n// file:src/parsing/stri.js\nBoxParser.createFullBoxCtor(\"stri\", function(stream) {\n\tthis.switch_group = stream.readUint16();\n\tthis.alternate_group = stream.readUint16();\n\tthis.sub_track_id = stream.readUint32();\n\tvar count = (this.size - this.hdr_size - 8)/4;\n\tthis.attribute_list = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.attribute_list[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/stsc.js\nBoxParser.createFullBoxCtor(\"stsc\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.first_chunk = [];\n\tthis.samples_per_chunk = [];\n\tthis.sample_description_index = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.first_chunk.push(stream.readUint32());\n\t\t\tthis.samples_per_chunk.push(stream.readUint32());\n\t\t\tthis.sample_description_index.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stsd.js\nBoxParser.createFullBoxCtor(\"stsd\", function(stream) {\n\tvar i;\n\tvar ret;\n\tvar entryCount;\n\tvar box;\n\tthis.entries = [];\n\tentryCount = stream.readUint32();\n\tfor (i = 1; i <= entryCount; i++) {\n\t\tret = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tif (BoxParser[ret.type+\"SampleEntry\"]) {\n\t\t\t\tbox = new BoxParser[ret.type+\"SampleEntry\"](ret.size);\n\t\t\t\tbox.hdr_size = ret.hdr_size;\n\t\t\t\tbox.start = ret.start;\n\t\t\t} else {\n\t\t\t\tLog.warn(\"BoxParser\", \"Unknown sample entry type: \"+ret.type);\n\t\t\t\tbox = new BoxParser.SampleEntry(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\t}\n\t\t\tif (box.write === BoxParser.SampleEntry.prototype.write) {\n\t\t\t\tLog.info(\"BoxParser\", \"SampleEntry \"+box.type+\" box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t\tbox.parseDataAndRewind(stream);\n\t\t\t}\n\t\t\tbox.parse(stream);\n\t\t\tthis.entries.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/stsg.js\nBoxParser.createFullBoxCtor(\"stsg\", function(stream) {\n\tthis.grouping_type = stream.readUint32();\n\tvar count = stream.readUint16();\n\tthis.group_description_index = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.group_description_index[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/stsh.js\nBoxParser.createFullBoxCtor(\"stsh\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tentry_count = stream.readUint32();\n\tthis.shadowed_sample_numbers = [];\n\tthis.sync_sample_numbers = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.shadowed_sample_numbers.push(stream.readUint32());\n\t\t\tthis.sync_sample_numbers.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stss.js\nBoxParser.createFullBoxCtor(\"stss\", function(stream) {\n\tvar i;\n\tvar entry_count;\n\tentry_count = stream.readUint32();\n\tif (this.version === 0) {\n\t\tthis.sample_numbers = [];\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_numbers.push(stream.readUint32());\n\t\t}\n\t}\n});\n\n// file:src/parsing/stsz.js\nBoxParser.createFullBoxCtor(\"stsz\", function(stream) {\n\tvar i;\n\tthis.sample_sizes = [];\n\tif (this.version === 0) {\n\t\tthis.sample_size = stream.readUint32();\n\t\tthis.sample_count = stream.readUint32();\n\t\tfor (i = 0; i < this.sample_count; i++) {\n\t\t\tif (this.sample_size === 0) {\n\t\t\t\tthis.sample_sizes.push(stream.readUint32());\n\t\t\t} else {\n\t\t\t\tthis.sample_sizes[i] = this.sample_size;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/stts.js\nBoxParser.createFullBoxCtor(\"stts\", function(stream) {\n\tvar entry_count;\n\tvar i;\n\tvar delta;\n\tentry_count = stream.readUint32();\n\tthis.sample_counts = [];\n\tthis.sample_deltas = [];\n\tif (this.version === 0) {\n\t\tfor(i=0; i<entry_count; i++) {\n\t\t\tthis.sample_counts.push(stream.readUint32());\n\t\t\tdelta = stream.readInt32();\n\t\t\tif (delta < 0) {\n\t\t\t\tLog.warn(\"BoxParser\", \"File uses negative stts sample delta, using value 1 instead, sync may be lost!\");\n\t\t\t\tdelta = 1;\n\t\t\t}\n\t\t\tthis.sample_deltas.push(delta);\n\t\t}\n\t}\n});\n\n// file:src/parsing/stvi.js\nBoxParser.createFullBoxCtor(\"stvi\", function(stream) {\n\tvar tmp32 = stream.readUint32();\n\tthis.single_view_allowed = tmp32 & 0x3;\n\tthis.stereo_scheme = stream.readUint32();\n\tvar length = stream.readUint32();\n\tthis.stereo_indication_type = stream.readString(length);\n\tvar ret;\n\tvar box;\n\tthis.boxes = [];\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\tthis.boxes.push(box);\n\t\t\tthis[box.type] = box;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/styp.js\nBoxParser.createBoxCtor(\"styp\", function(stream) {\n\tBoxParser.ftypBox.prototype.parse.call(this, stream);\n});\n\n// file:src/parsing/stz2.js\nBoxParser.createFullBoxCtor(\"stz2\", function(stream) {\n\tvar i;\n\tvar sample_count;\n\tthis.sample_sizes = [];\n\tif (this.version === 0) {\n\t\tthis.reserved = stream.readUint24();\n\t\tthis.field_size = stream.readUint8();\n\t\tsample_count = stream.readUint32();\n\t\tif (this.field_size === 4) {\n\t\t\tfor (i = 0; i < sample_count; i+=2) {\n\t\t\t\tvar tmp = stream.readUint8();\n\t\t\t\tthis.sample_sizes[i] = (tmp >> 4) & 0xF;\n\t\t\t\tthis.sample_sizes[i+1] = tmp & 0xF;\n\t\t\t}\n\t\t} else if (this.field_size === 8) {\n\t\t\tfor (i = 0; i < sample_count; i++) {\n\t\t\t\tthis.sample_sizes[i] = stream.readUint8();\n\t\t\t}\n\t\t} else if (this.field_size === 16) {\n\t\t\tfor (i = 0; i < sample_count; i++) {\n\t\t\t\tthis.sample_sizes[i] = stream.readUint16();\n\t\t\t}\n\t\t} else {\n\t\t\tLog.error(\"BoxParser\", \"Error in length field in stz2 box\");\n\t\t}\n\t}\n});\n\n// file:src/parsing/subs.js\nBoxParser.createFullBoxCtor(\"subs\", function(stream) {\n\tvar i,j;\n\tvar entry_count;\n\tvar subsample_count;\n\tentry_count = stream.readUint32();\n\tthis.entries = [];\n\tfor (i = 0; i < entry_count; i++) {\n\t\tvar sampleInfo = {};\n\t\tthis.entries[i] = sampleInfo;\n\t\tsampleInfo.sample_delta = stream.readUint32();\n\t\tsampleInfo.subsamples = [];\n\t\tsubsample_count = stream.readUint16();\n\t\tif (subsample_count>0) {\n\t\t\tfor (j = 0; j < subsample_count; j++) {\n\t\t\t\tvar subsample = {};\n\t\t\t\tsampleInfo.subsamples.push(subsample);\n\t\t\t\tif (this.version == 1) {\n\t\t\t\t\tsubsample.size = stream.readUint32();\n\t\t\t\t} else {\n\t\t\t\t\tsubsample.size = stream.readUint16();\n\t\t\t\t}\n\t\t\t\tsubsample.priority = stream.readUint8();\n\t\t\t\tsubsample.discardable = stream.readUint8();\n\t\t\t\tsubsample.codec_specific_parameters = stream.readUint32();\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/tenc.js\nBoxParser.createFullBoxCtor(\"tenc\", function(stream) {\n\tstream.readUint8(); // reserved\n\tif (this.version === 0) {\n\t\tstream.readUint8();\n\t} else {\n\t\tvar tmp = stream.readUint8();\n\t\tthis.default_crypt_byte_block = (tmp >> 4) & 0xF;\n\t\tthis.default_skip_byte_block = tmp & 0xF;\n\t}\n\tthis.default_isProtected = stream.readUint8();\n\tthis.default_Per_Sample_IV_Size = stream.readUint8();\n\tthis.default_KID = BoxParser.parseHex16(stream);\n\tif (this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0) {\n\t\tthis.default_constant_IV_size = stream.readUint8();\n\t\tthis.default_constant_IV = stream.readUint8Array(this.default_constant_IV_size);\n\t}\n});// file:src/parsing/tfdt.js\nBoxParser.createFullBoxCtor(\"tfdt\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.baseMediaDecodeTime = stream.readUint64();\n\t} else {\n\t\tthis.baseMediaDecodeTime = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/tfhd.js\nBoxParser.createFullBoxCtor(\"tfhd\", function(stream) {\n\tvar readBytes = 0;\n\tthis.track_id = stream.readUint32();\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET)) {\n\t\tthis.base_data_offset = stream.readUint64();\n\t\treadBytes += 8;\n\t} else {\n\t\tthis.base_data_offset = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC)) {\n\t\tthis.default_sample_description_index = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_description_index = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR)) {\n\t\tthis.default_sample_duration = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_duration = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE)) {\n\t\tthis.default_sample_size = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_size = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS)) {\n\t\tthis.default_sample_flags = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.default_sample_flags = 0;\n\t}\n});\n\n// file:src/parsing/tfra.js\nBoxParser.createFullBoxCtor(\"tfra\", function(stream) {\n\tthis.track_ID = stream.readUint32();\n\tstream.readUint24();\n\tvar tmp_byte = stream.readUint8();\n\tthis.length_size_of_traf_num = (tmp_byte >> 4) & 0x3;\n\tthis.length_size_of_trun_num = (tmp_byte >> 2) & 0x3;\n\tthis.length_size_of_sample_num = (tmp_byte) & 0x3;\n\tthis.entries = [];\n\tvar number_of_entries = stream.readUint32();\n\tfor (var i = 0; i < number_of_entries; i++) {\n\t\tif (this.version === 1) {\n\t\t\tthis.time = stream.readUint64();\n\t\t\tthis.moof_offset = stream.readUint64();\n\t\t} else {\n\t\t\tthis.time = stream.readUint32();\n\t\t\tthis.moof_offset = stream.readUint32();\n\t\t}\n\t\tthis.traf_number = stream[\"readUint\"+(8*(this.length_size_of_traf_num+1))]();\n\t\tthis.trun_number = stream[\"readUint\"+(8*(this.length_size_of_trun_num+1))]();\n\t\tthis.sample_number = stream[\"readUint\"+(8*(this.length_size_of_sample_num+1))]();\n\t}\n});\n\n// file:src/parsing/tkhd.js\nBoxParser.createFullBoxCtor(\"tkhd\", function(stream) {\n\tif (this.version == 1) {\n\t\tthis.creation_time = stream.readUint64();\n\t\tthis.modification_time = stream.readUint64();\n\t\tthis.track_id = stream.readUint32();\n\t\tstream.readUint32();\n\t\tthis.duration = stream.readUint64();\n\t} else {\n\t\tthis.creation_time = stream.readUint32();\n\t\tthis.modification_time = stream.readUint32();\n\t\tthis.track_id = stream.readUint32();\n\t\tstream.readUint32();\n\t\tthis.duration = stream.readUint32();\n\t}\n\tstream.readUint32Array(2);\n\tthis.layer = stream.readInt16();\n\tthis.alternate_group = stream.readInt16();\n\tthis.volume = stream.readInt16()>>8;\n\tstream.readUint16();\n\tthis.matrix = stream.readInt32Array(9);\n\tthis.width = stream.readUint32();\n\tthis.height = stream.readUint32();\n});\n\n// file:src/parsing/tmax.js\nBoxParser.createBoxCtor(\"tmax\", function(stream) {\n\tthis.time = stream.readUint32();\n});\n\n// file:src/parsing/tmin.js\nBoxParser.createBoxCtor(\"tmin\", function(stream) {\n\tthis.time = stream.readUint32();\n});\n\n// file:src/parsing/totl.js\nBoxParser.createBoxCtor(\"totl\",function(stream) {\n\tthis.bytessent = stream.readUint32();\n});\n\n// file:src/parsing/tpay.js\nBoxParser.createBoxCtor(\"tpay\", function(stream) {\n\tthis.bytessent = stream.readUint32();\n});\n\n// file:src/parsing/tpyl.js\nBoxParser.createBoxCtor(\"tpyl\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/TrackGroup.js\nBoxParser.TrackGroupTypeBox.prototype.parse = function(stream) {\n\tthis.parseFullHeader(stream);\n\tthis.track_group_id = stream.readUint32();\n};\n\n// file:src/parsing/trackgroups/msrc.js\nBoxParser.createTrackGroupCtor(\"msrc\");// file:src/parsing/TrakReference.js\nBoxParser.TrackReferenceTypeBox = function(type, size, hdr_size, start) {\n\tBoxParser.Box.call(this, type, size);\n\tthis.hdr_size = hdr_size;\n\tthis.start = start;\n};\nBoxParser.TrackReferenceTypeBox.prototype = new BoxParser.Box();\nBoxParser.TrackReferenceTypeBox.prototype.parse = function(stream) {\n\tthis.track_ids = stream.readUint32Array((this.size-this.hdr_size)/4);\n};\n\n// file:src/parsing/tref.js\nBoxParser.trefBox.prototype.parse = function(stream) {\n\tvar ret;\n\tvar box;\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, true, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = new BoxParser.TrackReferenceTypeBox(ret.type, ret.size, ret.hdr_size, ret.start);\n\t\t\tif (box.write === BoxParser.Box.prototype.write && box.type !== \"mdat\") {\n\t\t\t\tLog.info(\"BoxParser\", \"TrackReference \"+box.type+\" box writing not yet implemented, keeping unparsed data in memory for later write\");\n\t\t\t\tbox.parseDataAndRewind(stream);\n\t\t\t}\n\t\t\tbox.parse(stream);\n\t\t\tthis.boxes.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n};\n\n// file:src/parsing/trep.js\nBoxParser.createFullBoxCtor(\"trep\", function(stream) {\n\tthis.track_ID = stream.readUint32();\n\tthis.boxes = [];\n\twhile (stream.getPosition() < this.start+this.size) {\n\t\tret = BoxParser.parseOneBox(stream, false, this.size - (stream.getPosition() - this.start));\n\t\tif (ret.code === BoxParser.OK) {\n\t\t\tbox = ret.box;\n\t\t\tthis.boxes.push(box);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n});\n\n// file:src/parsing/trex.js\nBoxParser.createFullBoxCtor(\"trex\", function(stream) {\n\tthis.track_id = stream.readUint32();\n\tthis.default_sample_description_index = stream.readUint32();\n\tthis.default_sample_duration = stream.readUint32();\n\tthis.default_sample_size = stream.readUint32();\n\tthis.default_sample_flags = stream.readUint32();\n});\n\n// file:src/parsing/trpy.js\nBoxParser.createBoxCtor(\"trpy\", function(stream) {\n\tthis.bytessent = stream.readUint64();\n});\n\n// file:src/parsing/trun.js\nBoxParser.createFullBoxCtor(\"trun\", function(stream) {\n\tvar readBytes = 0;\n\tthis.sample_count = stream.readUint32();\n\treadBytes+= 4;\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) ) {\n\t\tthis.data_offset = stream.readInt32(); //signed\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.data_offset = 0;\n\t}\n\tif (this.size - this.hdr_size > readBytes && (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) ) {\n\t\tthis.first_sample_flags = stream.readUint32();\n\t\treadBytes += 4;\n\t} else {\n\t\tthis.first_sample_flags = 0;\n\t}\n\tthis.sample_duration = [];\n\tthis.sample_size = [];\n\tthis.sample_flags = [];\n\tthis.sample_composition_time_offset = [];\n\tif (this.size - this.hdr_size > readBytes) {\n\t\tfor (var i = 0; i < this.sample_count; i++) {\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\t\t\tthis.sample_duration[i] = stream.readUint32();\n\t\t\t}\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\t\t\tthis.sample_size[i] = stream.readUint32();\n\t\t\t}\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\t\t\tthis.sample_flags[i] = stream.readUint32();\n\t\t\t}\n\t\t\tif (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\t\t\tif (this.version === 0) {\n\t\t\t\t\tthis.sample_composition_time_offset[i] = stream.readUint32();\n\t\t\t\t} else {\n\t\t\t\t\tthis.sample_composition_time_offset[i] = stream.readInt32(); //signed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// file:src/parsing/tsel.js\nBoxParser.createFullBoxCtor(\"tsel\", function(stream) {\n\tthis.switch_group = stream.readUint32();\n\tvar count = (this.size - this.hdr_size - 4)/4;\n\tthis.attribute_list = [];\n\tfor (var i = 0; i < count; i++) {\n\t\tthis.attribute_list[i] = stream.readUint32();\n\t}\n});\n\n// file:src/parsing/txtC.js\nBoxParser.createFullBoxCtor(\"txtC\", function(stream) {\n\tthis.config = stream.readCString();\n});\n\n// file:src/parsing/url.js\nBoxParser.createFullBoxCtor(\"url \", function(stream) {\n\tif (this.flags !== 0x000001) {\n\t\tthis.location = stream.readCString();\n\t}\n});\n\n// file:src/parsing/urn.js\nBoxParser.createFullBoxCtor(\"urn \", function(stream) {\n\tthis.name = stream.readCString();\n\tif (this.size - this.hdr_size - this.name.length - 1 > 0) {\n\t\tthis.location = stream.readCString();\n\t}\n});\n\n// file:src/parsing/uuid/piff/piffLsm.js\nBoxParser.createUUIDBox(\"a5d40b30e81411ddba2f0800200c9a66\", true, false, function(stream) {\n    this.LiveServerManifest = stream.readString(this.size - this.hdr_size)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n});// file:src/parsing/uuid/piff/piffPssh.js\nBoxParser.createUUIDBox(\"d08a4f1810f34a82b6c832d8aba183d3\", true, false, function(stream) {\n\tthis.system_id = BoxParser.parseHex16(stream);\n\tvar datasize = stream.readUint32();\n\tif (datasize > 0) {\n\t\tthis.data = stream.readUint8Array(datasize);\n\t}\n});\n\n// file:src/parsing/uuid/piff/piffSenc.js\nBoxParser.createUUIDBox(\"a2394f525a9b4f14a2446c427c648df4\", true, false /*, function(stream) {\n\tif (this.flags & 0x1) {\n\t\tthis.AlgorithmID = stream.readUint24();\n\t\tthis.IV_size = stream.readUint8();\n\t\tthis.KID = BoxParser.parseHex16(stream);\n\t}\n\tvar sample_count = stream.readUint32();\n\tthis.samples = [];\n\tfor (var i = 0; i < sample_count; i++) {\n\t\tvar sample = {};\n\t\tsample.InitializationVector = this.readUint8Array(this.IV_size*8);\n\t\tif (this.flags & 0x2) {\n\t\t\tsample.subsamples = [];\n\t\t\tsample.NumberOfEntries = stream.readUint16();\n\t\t\tfor (var j = 0; j < sample.NumberOfEntries; j++) {\n\t\t\t\tvar subsample = {};\n\t\t\t\tsubsample.BytesOfClearData = stream.readUint16();\n\t\t\t\tsubsample.BytesOfProtectedData = stream.readUint32();\n\t\t\t\tsample.subsamples.push(subsample);\n\t\t\t}\n\t\t}\n\t\tthis.samples.push(sample);\n\t}\n}*/);\n// file:src/parsing/uuid/piff/piffTenc.js\nBoxParser.createUUIDBox(\"8974dbce7be74c5184f97148f9882554\", true, false, function(stream) {\n\tthis.default_AlgorithmID = stream.readUint24();\n\tthis.default_IV_size = stream.readUint8();\n\tthis.default_KID = BoxParser.parseHex16(stream);\n});// file:src/parsing/uuid/piff/piffTfrf.js\nBoxParser.createUUIDBox(\"d4807ef2ca3946958e5426cb9e46a79f\", true, false, function(stream) {\n    this.fragment_count = stream.readUint8();\n    this.entries = [];\n\n    for (var i = 0; i < this.fragment_count; i++) {\n        var entry = {};\n        var absolute_time = 0;\n        var absolute_duration = 0;\n\n        if (this.version === 1) {\n            absolute_time = stream.readUint64();\n            absolute_duration = stream.readUint64();\n        } else {\n            absolute_time = stream.readUint32();\n            absolute_duration = stream.readUint32();\n        }\n\n        entry.absolute_time = absolute_time;\n        entry.absolute_duration = absolute_duration;\n\n        this.entries.push(entry);\n    }\n});// file:src/parsing/uuid/piff/piffTfxd.js\nBoxParser.createUUIDBox(\"6d1d9b0542d544e680e2141daff757b2\", true, false, function(stream) {\n    if (this.version === 1) {\n       this.absolute_time = stream.readUint64();\n       this.duration = stream.readUint64();\n    } else {\n       this.absolute_time = stream.readUint32();\n       this.duration = stream.readUint32();\n    }\n});// file:src/parsing/vmhd.js\nBoxParser.createFullBoxCtor(\"vmhd\", function(stream) {\n\tthis.graphicsmode = stream.readUint16();\n\tthis.opcolor = stream.readUint16Array(3);\n});\n\n// file:src/parsing/vpcC.js\nBoxParser.createFullBoxCtor(\"vpcC\", function (stream) {\n\tvar tmp;\n\tif (this.version === 1) {\n\t\tthis.profile = stream.readUint8();\n\t\tthis.level = stream.readUint8();\n\t\ttmp = stream.readUint8();\n\t\tthis.bitDepth = tmp >> 4;\n\t\tthis.chromaSubsampling = (tmp >> 1) & 0x7;\n\t\tthis.videoFullRangeFlag = tmp & 0x1;\n\t\tthis.colourPrimaries = stream.readUint8();\n\t\tthis.transferCharacteristics = stream.readUint8();\n\t\tthis.matrixCoefficients = stream.readUint8();\n\t\tthis.codecIntializationDataSize = stream.readUint16();\n\t\tthis.codecIntializationData = stream.readUint8Array(this.codecIntializationDataSize);\n\t} else {\n\t\tthis.profile = stream.readUint8();\n\t\tthis.level = stream.readUint8();\n\t\ttmp = stream.readUint8();\n\t\tthis.bitDepth = (tmp >> 4) & 0xF;\n\t\tthis.colorSpace = tmp & 0xF;\n\t\ttmp = stream.readUint8();\n\t\tthis.chromaSubsampling = (tmp >> 4) & 0xF;\n\t\tthis.transferFunction = (tmp >> 1) & 0x7;\n\t\tthis.videoFullRangeFlag = tmp & 0x1;\n\t\tthis.codecIntializationDataSize = stream.readUint16();\n\t\tthis.codecIntializationData = stream.readUint8Array(this.codecIntializationDataSize);\n\t}\n});// file:src/parsing/vttC.js\nBoxParser.createBoxCtor(\"vttC\", function(stream) {\n\tthis.text = stream.readString(this.size - this.hdr_size);\n});\n\n// file:src/box-codecs.js\nBoxParser.SampleEntry.prototype.isVideo = function() {\n\treturn false;\n};\n\nBoxParser.SampleEntry.prototype.isAudio = function() {\n\treturn false;\n};\n\nBoxParser.SampleEntry.prototype.isSubtitle = function() {\n\treturn false;\n};\n\nBoxParser.SampleEntry.prototype.isMetadata = function() {\n\treturn false;\n};\n\nBoxParser.SampleEntry.prototype.isHint = function() {\n\treturn false;\n};\n\nBoxParser.SampleEntry.prototype.getCodec = function() {\n\treturn this.type.replace('.','');\n};\n\nBoxParser.SampleEntry.prototype.getWidth = function() {\n\treturn \"\";\n};\n\nBoxParser.SampleEntry.prototype.getHeight = function() {\n\treturn \"\";\n};\n\nBoxParser.SampleEntry.prototype.getChannelCount = function() {\n\treturn \"\";\n};\n\nBoxParser.SampleEntry.prototype.getSampleRate = function() {\n\treturn \"\";\n};\n\nBoxParser.SampleEntry.prototype.getSampleSize = function() {\n\treturn \"\";\n};\n\nBoxParser.VisualSampleEntry.prototype.isVideo = function() {\n\treturn true;\n};\n\nBoxParser.VisualSampleEntry.prototype.getWidth = function() {\n\treturn this.width;\n};\n\nBoxParser.VisualSampleEntry.prototype.getHeight = function() {\n\treturn this.height;\n};\n\nBoxParser.AudioSampleEntry.prototype.isAudio = function() {\n\treturn true;\n};\n\nBoxParser.AudioSampleEntry.prototype.getChannelCount = function() {\n\treturn this.channel_count;\n};\n\nBoxParser.AudioSampleEntry.prototype.getSampleRate = function() {\n\treturn this.samplerate;\n};\n\nBoxParser.AudioSampleEntry.prototype.getSampleSize = function() {\n\treturn this.samplesize;\n};\n\nBoxParser.SubtitleSampleEntry.prototype.isSubtitle = function() {\n\treturn true;\n};\n\nBoxParser.MetadataSampleEntry.prototype.isMetadata = function() {\n\treturn true;\n};\n\n\nBoxParser.decimalToHex = function(d, padding) {\n\tvar hex = Number(d).toString(16);\n\tpadding = typeof (padding) === \"undefined\" || padding === null ? padding = 2 : padding;\n\twhile (hex.length < padding) {\n\t\thex = \"0\" + hex;\n\t}\n\treturn hex;\n};\n\nBoxParser.avc1SampleEntry.prototype.getCodec =\nBoxParser.avc2SampleEntry.prototype.getCodec =\nBoxParser.avc3SampleEntry.prototype.getCodec =\nBoxParser.avc4SampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.avcC) {\n\t\treturn baseCodec+\".\"+BoxParser.decimalToHex(this.avcC.AVCProfileIndication)+\n\t\t\t\t\t\t  \"\"+BoxParser.decimalToHex(this.avcC.profile_compatibility)+\n\t\t\t\t\t\t  \"\"+BoxParser.decimalToHex(this.avcC.AVCLevelIndication);\n\t} else {\n\t\treturn baseCodec;\n\t}\n};\n\nBoxParser.hev1SampleEntry.prototype.getCodec =\nBoxParser.hvc1SampleEntry.prototype.getCodec = function() {\n\tvar i;\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.hvcC) {\n\t\tbaseCodec += '.';\n\t\tswitch (this.hvcC.general_profile_space) {\n\t\t\tcase 0:\n\t\t\t\tbaseCodec += '';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbaseCodec += 'A';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbaseCodec += 'B';\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbaseCodec += 'C';\n\t\t\t\tbreak;\n\t\t}\n\t\tbaseCodec += this.hvcC.general_profile_idc;\n\t\tbaseCodec += '.';\n\t\tvar val = this.hvcC.general_profile_compatibility;\n\t\tvar reversed = 0;\n\t\tfor (i=0; i<32; i++) {\n\t\t\treversed |= val & 1;\n\t\t\tif (i==31) break;\n\t\t\treversed <<= 1;\n\t\t\tval >>=1;\n\t\t}\n\t\tbaseCodec += BoxParser.decimalToHex(reversed, 0);\n\t\tbaseCodec += '.';\n\t\tif (this.hvcC.general_tier_flag === 0) {\n\t\t\tbaseCodec += 'L';\n\t\t} else {\n\t\t\tbaseCodec += 'H';\n\t\t}\n\t\tbaseCodec += this.hvcC.general_level_idc;\n\t\tvar hasByte = false;\n\t\tvar constraint_string = \"\";\n\t\tfor (i = 5; i >= 0; i--) {\n\t\t\tif (this.hvcC.general_constraint_indicator[i] || hasByte) {\n\t\t\t\tconstraint_string = \".\"+BoxParser.decimalToHex(this.hvcC.general_constraint_indicator[i], 0)+constraint_string;\n\t\t\t\thasByte = true;\n\t\t\t}\n\t\t}\n\t\tbaseCodec += constraint_string;\n\t}\n\treturn baseCodec;\n};\n\nBoxParser.mp4aSampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif (this.esds && this.esds.esd) {\n\t\tvar oti = this.esds.esd.getOTI();\n\t\tvar dsi = this.esds.esd.getAudioConfig();\n\t\treturn baseCodec+\".\"+BoxParser.decimalToHex(oti)+(dsi ? \".\"+dsi: \"\");\n\t} else {\n\t\treturn baseCodec;\n\t}\n};\n\nBoxParser.stxtSampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tif(this.mime_format) {\n\t\treturn baseCodec + \".\" + this.mime_format;\n\t} else {\n\t\treturn baseCodec\n\t}\n};\n\nBoxParser.av01SampleEntry.prototype.getCodec = function() {\n\tvar baseCodec = BoxParser.SampleEntry.prototype.getCodec.call(this);\n\tvar bitdepth;\n\tif (this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1) {\n\t\tbitdepth = (this.av1C.twelve_bit === 1) ? \"12\" : \"10\";\n\t} else if ( this.av1C.seq_profile <= 2 ) {\n\t\tbitdepth = (this.av1C.high_bitdepth === 1) ? \"10\" : \"08\";\n\t}\n\t// TODO need to parse the SH to find color config\n\treturn baseCodec+\".\"+this.av1C.seq_profile+\".\"+this.av1C.seq_level_idx_0+(this.av1C.seq_tier_0?\"H\":\"M\")+\".\"+bitdepth;//+\".\"+this.av1C.monochrome+\".\"+this.av1C.chroma_subsampling_x+\"\"+this.av1C.chroma_subsampling_y+\"\"+this.av1C.chroma_sample_position;\n};\n\n\n// file:src/box-write.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.Box.prototype.writeHeader = function(stream, msg) {\n\tthis.size += 8;\n\tif (this.size > MAX_SIZE) {\n\t\tthis.size += 8;\n\t}\n\tif (this.type === \"uuid\") {\n\t\tthis.size += 16;\n\t}\n\tLog.debug(\"BoxWriter\", \"Writing box \"+this.type+\" of size: \"+this.size+\" at position \"+stream.getPosition()+(msg || \"\"));\n\tif (this.size > MAX_SIZE) {\n\t\tstream.writeUint32(1);\n\t} else {\n\t\tthis.sizePosition = stream.getPosition();\n\t\tstream.writeUint32(this.size);\n\t}\n\tstream.writeString(this.type, null, 4);\n\tif (this.type === \"uuid\") {\n\t\tstream.writeUint8Array(this.uuid);\n\t}\n\tif (this.size > MAX_SIZE) {\n\t\tstream.writeUint64(this.size);\n\t} \n};\n\nBoxParser.FullBox.prototype.writeHeader = function(stream) {\n\tthis.size += 4;\n\tBoxParser.Box.prototype.writeHeader.call(this, stream, \" v=\"+this.version+\" f=\"+this.flags);\n\tstream.writeUint8(this.version);\n\tstream.writeUint24(this.flags);\n};\n\nBoxParser.Box.prototype.write = function(stream) {\n\tif (this.type === \"mdat\") {\n\t\t/* TODO: fix this */\n\t\tif (this.data) {\n\t\t\tthis.size = this.data.length;\n\t\t\tthis.writeHeader(stream);\n\t\t\tstream.writeUint8Array(this.data);\n\t\t}\n\t} else {\n\t\tthis.size = (this.data ? this.data.length : 0);\n\t\tthis.writeHeader(stream);\n\t\tif (this.data) {\n\t\t\tstream.writeUint8Array(this.data);\n\t\t}\n\t}\n};\n\nBoxParser.ContainerBox.prototype.write = function(stream) {\n\tthis.size = 0;\n\tthis.writeHeader(stream);\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tif (this.boxes[i]) {\n\t\t\tthis.boxes[i].write(stream);\n\t\t\tthis.size += this.boxes[i].size;\n\t\t}\n\t}\n\t/* adjusting the size, now that all sub-boxes are known */\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\n};\n\nBoxParser.TrackReferenceTypeBox.prototype.write = function(stream) {\n\tthis.size = this.track_ids.length*4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32Array(this.track_ids);\n};\n\n// file:src/writing/avcC.js\nBoxParser.avcCBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.size = 7;\n\tfor (i = 0; i < this.SPS.length; i++) {\n\t\tthis.size += 2+this.SPS[i].length;\n\t}\n\tfor (i = 0; i < this.PPS.length; i++) {\n\t\tthis.size += 2+this.PPS[i].length;\n\t}\n\tif (this.ext) {\n\t\tthis.size += this.ext.length;\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeUint8(this.configurationVersion);\n\tstream.writeUint8(this.AVCProfileIndication);\n\tstream.writeUint8(this.profile_compatibility);\n\tstream.writeUint8(this.AVCLevelIndication);\n\tstream.writeUint8(this.lengthSizeMinusOne + (63<<2));\n\tstream.writeUint8(this.SPS.length + (7<<5));\n\tfor (i = 0; i < this.SPS.length; i++) {\n\t\tstream.writeUint16(this.SPS[i].length);\n\t\tstream.writeUint8Array(this.SPS[i].nalu);\n\t}\n\tstream.writeUint8(this.PPS.length);\n\tfor (i = 0; i < this.PPS.length; i++) {\n\t\tstream.writeUint16(this.PPS[i].length);\n\t\tstream.writeUint8Array(this.PPS[i].nalu);\n\t}\n\tif (this.ext) {\n\t\tstream.writeUint8Array(this.ext);\n\t}\n};\n\n// file:src/writing/co64.js\nBoxParser.co64Box.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.chunk_offsets.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.chunk_offsets.length);\n\tfor(i=0; i<this.chunk_offsets.length; i++) {\n\t\tstream.writeUint64(this.chunk_offsets[i]);\n\t}\n};\n\n// file:src/writing/cslg.js\nBoxParser.cslgBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4*5;\n\tthis.writeHeader(stream);\n\tstream.writeInt32(this.compositionToDTSShift);\n\tstream.writeInt32(this.leastDecodeToDisplayDelta);\n\tstream.writeInt32(this.greatestDecodeToDisplayDelta);\n\tstream.writeInt32(this.compositionStartTime);\n\tstream.writeInt32(this.compositionEndTime);\n};\n\n// file:src/writing/ctts.js\nBoxParser.cttsBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.sample_counts.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_counts.length);\n\tfor(i=0; i<this.sample_counts.length; i++) {\n\t\tstream.writeUint32(this.sample_counts[i]);\n\t\tif (this.version === 1) {\n\t\t\tstream.writeInt32(this.sample_offsets[i]); /* signed */\n\t\t} else {\t\t\t\n\t\t\tstream.writeUint32(this.sample_offsets[i]); /* unsigned */\n\t\t}\n\t}\n};\n\n// file:src/writing/dref.js\nBoxParser.drefBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4; //\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.entries.length);\n\tfor (var i = 0; i < this.entries.length; i++) {\n\t\tthis.entries[i].write(stream);\n\t\tthis.size += this.entries[i].size;\n\t}\t\n\t/* adjusting the size, now that all sub-boxes are known */\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\n};\n\n// file:src/writing/elng.js\nBoxParser.elngBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = this.extended_language.length;\n\tthis.writeHeader(stream);\n\tstream.writeString(this.extended_language);\n};\n\n// file:src/writing/elst.js\nBoxParser.elstBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = 4+12*this.entries.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.entries.length);\n\tfor (var i = 0; i < this.entries.length; i++) {\n\t\tvar entry = this.entries[i];\n\t\tstream.writeUint32(entry.segment_duration);\n\t\tstream.writeInt32(entry.media_time);\n\t\tstream.writeInt16(entry.media_rate_integer);\n\t\tstream.writeInt16(entry.media_rate_fraction);\n\t}\n};\n\n// file:src/writing/emsg.js\nBoxParser.emsgBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = 4*4+this.message_data.length+(this.scheme_id_uri.length+1)+(this.value.length+1);\n\tthis.writeHeader(stream);\n\tstream.writeCString(this.scheme_id_uri);\n\tstream.writeCString(this.value);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.presentation_time_delta);\n\tstream.writeUint32(this.event_duration);\n\tstream.writeUint32(this.id);\n\tstream.writeUint8Array(this.message_data);\n};\n\n// file:src/writing/ftyp.js\nBoxParser.ftypBox.prototype.write = function(stream) {\n\tthis.size = 8+4*this.compatible_brands.length;\n\tthis.writeHeader(stream);\n\tstream.writeString(this.major_brand, null, 4);\n\tstream.writeUint32(this.minor_version);\n\tfor (var i = 0; i < this.compatible_brands.length; i++) {\n\t\tstream.writeString(this.compatible_brands[i], null, 4);\n\t}\n};\n\n// file:src/writing/hdlr.js\nBoxParser.hdlrBox.prototype.write = function(stream) {\n\tthis.size = 5*4+this.name.length+1;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(0);\n\tstream.writeString(this.handler, null, 4);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeCString(this.name);\n};\n\n// file:src/writing/kind.js\nBoxParser.kindBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = (this.schemeURI.length+1)+(this.value.length+1);\n\tthis.writeHeader(stream);\n\tstream.writeCString(this.schemeURI);\n\tstream.writeCString(this.value);\n};\n\n// file:src/writing/mdhd.js\nBoxParser.mdhdBox.prototype.write = function(stream) {\n\tthis.size = 4*4+2*2;\n\tthis.flags = 0;\n\tthis.version = 0;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.creation_time);\n\tstream.writeUint32(this.modification_time);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.duration);\n\tstream.writeUint16(this.language);\n\tstream.writeUint16(0);\n};\n\n// file:src/writing/mehd.js\nBoxParser.mehdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.fragment_duration);\n};\n\n// file:src/writing/mfhd.js\nBoxParser.mfhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sequence_number);\n};\n\n// file:src/writing/mvhd.js\nBoxParser.mvhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 23*4+2*2;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.creation_time);\n\tstream.writeUint32(this.modification_time);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.duration);\n\tstream.writeUint32(this.rate);\n\tstream.writeUint16(this.volume<<8);\n\tstream.writeUint16(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32Array(this.matrix);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(this.next_track_id);\n};\n\n// file:src/writing/sampleentry.js\nBoxParser.SampleEntry.prototype.writeHeader = function(stream) {\n\tthis.size = 8;\n\tBoxParser.Box.prototype.writeHeader.call(this, stream);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint8(0);\n\tstream.writeUint16(this.data_reference_index);\n};\n\nBoxParser.SampleEntry.prototype.writeFooter = function(stream) {\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tthis.boxes[i].write(stream);\n\t\tthis.size += this.boxes[i].size;\n\t}\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\t\n};\n\nBoxParser.SampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tstream.writeUint8Array(this.data);\n\tthis.size += this.data.length;\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\t\n};\n\nBoxParser.VisualSampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tthis.size += 2*7+6*4+32;\n\tstream.writeUint16(0); \n\tstream.writeUint16(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint16(this.width);\n\tstream.writeUint16(this.height);\n\tstream.writeUint32(this.horizresolution);\n\tstream.writeUint32(this.vertresolution);\n\tstream.writeUint32(0);\n\tstream.writeUint16(this.frame_count);\n\tstream.writeUint8(Math.min(31, this.compressorname.length));\n\tstream.writeString(this.compressorname, null, 31);\n\tstream.writeUint16(this.depth);\n\tstream.writeInt16(-1);\n\tthis.writeFooter(stream);\n};\n\nBoxParser.AudioSampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tthis.size += 2*4+3*4;\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeUint16(this.channel_count);\n\tstream.writeUint16(this.samplesize);\n\tstream.writeUint16(0);\n\tstream.writeUint16(0);\n\tstream.writeUint32(this.samplerate<<16);\n\tthis.writeFooter(stream);\n};\n\nBoxParser.stppSampleEntry.prototype.write = function(stream) {\n\tthis.writeHeader(stream);\n\tthis.size += this.namespace.length+1+\n\t\t\t\t this.schema_location.length+1+\n\t\t\t\t this.auxiliary_mime_types.length+1;\n\tstream.writeCString(this.namespace);\n\tstream.writeCString(this.schema_location);\n\tstream.writeCString(this.auxiliary_mime_types);\n\tthis.writeFooter(stream);\n};\n\n// file:src/writing/samplegroups/samplegroup.js\nBoxParser.SampleGroupEntry.prototype.write = function(stream) {\n\tstream.writeUint8Array(this.data);\n};\n\n// file:src/writing/sbgp.js\nBoxParser.sbgpBox.prototype.write = function(stream) {\n\tthis.version = 1;\t\n\tthis.flags = 0;\n\tthis.size = 12+8*this.entries.length;\n\tthis.writeHeader(stream);\n\tstream.writeString(this.grouping_type, null, 4);\n\tstream.writeUint32(this.grouping_type_parameter);\n\tstream.writeUint32(this.entries.length);\n\tfor (var i = 0; i < this.entries.length; i++) {\n\t\tvar entry = this.entries[i];\n\t\tstream.writeInt32(entry.sample_count);\n\t\tstream.writeInt32(entry.group_description_index);\n\t}\n};\n\n// file:src/writing/sgpd.js\nBoxParser.sgpdBox.prototype.write = function(stream) {\n\tvar i;\n\tvar entry;\n\t// leave version as read\n\t// this.version;\n\tthis.flags = 0;\n\tthis.size = 12;\n\tfor (i = 0; i < this.entries.length; i++) {\n\t\tentry = this.entries[i];\n\t\tif (this.version === 1) {\n\t\t\tif (this.default_length === 0) {\n\t\t\t\tthis.size += 4;\n\t\t\t}\n\t\t\tthis.size += entry.data.length;\n\t\t}\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeString(this.grouping_type, null, 4);\n\tif (this.version === 1) {\n\t\tstream.writeUint32(this.default_length);\n\t}\n\tif (this.version >= 2) {\n\t\tstream.writeUint32(this.default_sample_description_index);\n\t}\n\tstream.writeUint32(this.entries.length);\n\tfor (i = 0; i < this.entries.length; i++) {\n\t\tentry = this.entries[i];\n\t\tif (this.version === 1) {\n\t\t\tif (this.default_length === 0) {\n\t\t\t\tstream.writeUint32(entry.description_length);\n\t\t\t}\n\t\t}\n\t\tentry.write(stream);\n\t}\n};\n\n\n// file:src/writing/sidx.js\nBoxParser.sidxBox.prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = 4*4+2+2+12*this.references.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.reference_ID);\n\tstream.writeUint32(this.timescale);\n\tstream.writeUint32(this.earliest_presentation_time);\n\tstream.writeUint32(this.first_offset);\n\tstream.writeUint16(0);\n\tstream.writeUint16(this.references.length);\n\tfor (var i = 0; i < this.references.length; i++) {\n\t\tvar ref = this.references[i];\n\t\tstream.writeUint32(ref.reference_type << 31 | ref.referenced_size);\n\t\tstream.writeUint32(ref.subsegment_duration);\n\t\tstream.writeUint32(ref.starts_with_SAP << 31 | ref.SAP_type << 28 | ref.SAP_delta_time);\n\t}\n};\n\n// file:src/writing/stco.js\nBoxParser.stcoBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+4*this.chunk_offsets.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.chunk_offsets.length);\n\tstream.writeUint32Array(this.chunk_offsets);\n};\n\n// file:src/writing/stsc.js\nBoxParser.stscBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+12*this.first_chunk.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.first_chunk.length);\n\tfor(i=0; i<this.first_chunk.length; i++) {\n\t\tstream.writeUint32(this.first_chunk[i]);\n\t\tstream.writeUint32(this.samples_per_chunk[i]);\n\t\tstream.writeUint32(this.sample_description_index[i]);\n\t}\n};\n\n// file:src/writing/stsd.js\nBoxParser.stsdBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 0;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.entries.length);\n\tthis.size += 4;\n\tfor (i = 0; i < this.entries.length; i++) {\n\t\tthis.entries[i].write(stream);\n\t\tthis.size += this.entries[i].size;\n\t}\n\t/* adjusting the size, now that all sub-boxes are known */\n\tLog.debug(\"BoxWriter\", \"Adjusting box \"+this.type+\" with new size \"+this.size);\n\tstream.adjustUint32(this.sizePosition, this.size);\n};\n\n// file:src/writing/stsh.js\nBoxParser.stshBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.shadowed_sample_numbers.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.shadowed_sample_numbers.length);\n\tfor(i=0; i<this.shadowed_sample_numbers.length; i++) {\n\t\tstream.writeUint32(this.shadowed_sample_numbers[i]);\n\t\tstream.writeUint32(this.sync_sample_numbers[i]);\n\t}\n};\n\n// file:src/writing/stss.js\nBoxParser.stssBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+4*this.sample_numbers.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_numbers.length);\n\tstream.writeUint32Array(this.sample_numbers);\n};\n\n// file:src/writing/stsz.js\nBoxParser.stszBox.prototype.write = function(stream) {\n\tvar i;\n\tvar constant = true;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tif (this.sample_sizes.length > 0) {\n\t\ti = 0;\n\t\twhile (i+1 < this.sample_sizes.length) {\n\t\t\tif (this.sample_sizes[i+1] !==  this.sample_sizes[0]) {\n\t\t\t\tconstant = false;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconstant = false;\n\t}\n\tthis.size = 8;\n\tif (!constant) {\n\t\tthis.size += 4*this.sample_sizes.length;\n\t}\n\tthis.writeHeader(stream);\n\tif (!constant) {\n\t\tstream.writeUint32(0);\n\t} else {\n\t\tstream.writeUint32(this.sample_sizes[0]);\n\t}\n\tstream.writeUint32(this.sample_sizes.length);\n\tif (!constant) {\n\t\tstream.writeUint32Array(this.sample_sizes);\n\t}\t\n};\n\n// file:src/writing/stts.js\nBoxParser.sttsBox.prototype.write = function(stream) {\n\tvar i;\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4+8*this.sample_counts.length;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_counts.length);\n\tfor(i=0; i<this.sample_counts.length; i++) {\n\t\tstream.writeUint32(this.sample_counts[i]);\n\t\tstream.writeUint32(this.sample_deltas[i]);\n\t}\n};\n\n// file:src/writing/tfdt.js\nBoxParser.tfdtBox.prototype.write = function(stream) {\n\tvar UINT32_MAX = Math.pow(2, 32) - 1;\n\t// use version 1 if baseMediaDecodeTime does not fit 32 bits\n\tthis.version = this.baseMediaDecodeTime > UINT32_MAX ? 1 : 0;\n\tthis.flags = 0;\n\tthis.size = 4;\n\tif (this.version === 1) {\n\t\tthis.size += 4;\n\t}\n\tthis.writeHeader(stream);\n\tif (this.version === 1) {\n\t\tstream.writeUint64(this.baseMediaDecodeTime);\n\t} else {\n\t\tstream.writeUint32(this.baseMediaDecodeTime);\n\t}\n};\n\n// file:src/writing/tfhd.js\nBoxParser.tfhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.size = 4;\n\tif (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) {\n\t\tthis.size += 8;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n\t\tthis.size += 4;\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.track_id);\n\tif (this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) {\n\t\tstream.writeUint64(this.base_data_offset);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n\t\tstream.writeUint32(this.default_sample_description_index);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n\t\tstream.writeUint32(this.default_sample_duration);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n\t\tstream.writeUint32(this.default_sample_size);\n\t}\n\tif (this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n\t\tstream.writeUint32(this.default_sample_flags);\n\t}\n};\n\n// file:src/writing/tkhd.js\nBoxParser.tkhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\t//this.flags = 0;\n\tthis.size = 4*18+2*4;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.creation_time);\n\tstream.writeUint32(this.modification_time);\n\tstream.writeUint32(this.track_id);\n\tstream.writeUint32(0);\n\tstream.writeUint32(this.duration);\n\tstream.writeUint32(0);\n\tstream.writeUint32(0);\n\tstream.writeInt16(this.layer);\n\tstream.writeInt16(this.alternate_group);\n\tstream.writeInt16(this.volume<<8);\n\tstream.writeUint16(0);\n\tstream.writeInt32Array(this.matrix);\n\tstream.writeUint32(this.width);\n\tstream.writeUint32(this.height);\n};\n\n// file:src/writing/trex.js\nBoxParser.trexBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 0;\n\tthis.size = 4*5;\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.track_id);\n\tstream.writeUint32(this.default_sample_description_index);\n\tstream.writeUint32(this.default_sample_duration);\n\tstream.writeUint32(this.default_sample_size);\n\tstream.writeUint32(this.default_sample_flags);\n};\n\n// file:src/writing/trun.js\nBoxParser.trunBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.size = 4;\n\tif (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) {\n\t\tthis.size += 4;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\tthis.size += 4*this.sample_duration.length;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\tthis.size += 4*this.sample_size.length;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\tthis.size += 4*this.sample_flags.length;\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\tthis.size += 4*this.sample_composition_time_offset.length;\n\t}\n\tthis.writeHeader(stream);\n\tstream.writeUint32(this.sample_count);\n\tif (this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) {\n\t\tthis.data_offset_position = stream.getPosition();\n\t\tstream.writeInt32(this.data_offset); //signed\n\t}\n\tif (this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG) {\n\t\tstream.writeUint32(this.first_sample_flags);\n\t}\n\tfor (var i = 0; i < this.sample_count; i++) {\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\t\tstream.writeUint32(this.sample_duration[i]);\n\t\t}\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\t\tstream.writeUint32(this.sample_size[i]);\n\t\t}\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\t\tstream.writeUint32(this.sample_flags[i]);\n\t\t}\n\t\tif (this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\t\tif (this.version === 0) {\n\t\t\t\tstream.writeUint32(this.sample_composition_time_offset[i]);\n\t\t\t} else {\n\t\t\t\tstream.writeInt32(this.sample_composition_time_offset[i]); //signed\n\t\t\t}\n\t\t}\n\t}\t\t\n};\n\n// file:src/writing/url.js\nBoxParser[\"url Box\"].prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tif (this.location) {\n\t\tthis.flags = 0;\n\t\tthis.size = this.location.length+1;\n\t} else {\n\t\tthis.flags = 0x000001;\n\t\tthis.size = 0;\n\t}\n\tthis.writeHeader(stream);\n\tif (this.location) {\n\t\tstream.writeCString(this.location);\n\t}\n};\n\n// file:src/writing/urn.js\nBoxParser[\"urn Box\"].prototype.write = function(stream) {\n\tthis.version = 0;\t\n\tthis.flags = 0;\n\tthis.size = this.name.length+1+(this.location ? this.location.length+1 : 0);\n\tthis.writeHeader(stream);\n\tstream.writeCString(this.name);\n\tif (this.location) {\n\t\tstream.writeCString(this.location);\n\t}\n};\n\n// file:src/writing/vmhd.js\nBoxParser.vmhdBox.prototype.write = function(stream) {\n\tthis.version = 0;\n\tthis.flags = 1;\n\tthis.size = 8;\n\tthis.writeHeader(stream);\n\tstream.writeUint16(this.graphicsmode);\n\tstream.writeUint16Array(this.opcolor);\n};\n\n// file:src/box-unpack.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.cttsBox.prototype.unpack = function(samples) {\n\tvar i, j, k;\n\tk = 0;\n\tfor (i = 0; i < this.sample_counts.length; i++) {\n\t\tfor (j = 0; j < this.sample_counts[i]; j++) {\n\t\t\tsamples[k].pts = samples[k].dts + this.sample_offsets[i];\n\t\t\tk++;\n\t\t}\n\t}\n};\n\nBoxParser.sttsBox.prototype.unpack = function(samples) {\n\tvar i, j, k;\n\tk = 0;\n\tfor (i = 0; i < this.sample_counts.length; i++) {\n\t\tfor (j = 0; j < this.sample_counts[i]; j++) {\n\t\t\tif (k === 0) {\n\t\t\t\tsamples[k].dts = 0;\n\t\t\t} else {\n\t\t\t\tsamples[k].dts = samples[k-1].dts + this.sample_deltas[i];\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n};\n\nBoxParser.stcoBox.prototype.unpack = function(samples) {\n\tvar i;\n\tfor (i = 0; i < this.chunk_offsets.length; i++) {\n\t\tsamples[i].offset = this.chunk_offsets[i];\n\t}\n};\n\nBoxParser.stscBox.prototype.unpack = function(samples) {\n\tvar i, j, k, l, m;\n\tl = 0;\n\tm = 0;\n\tfor (i = 0; i < this.first_chunk.length; i++) {\n\t\tfor (j = 0; j < (i+1 < this.first_chunk.length ? this.first_chunk[i+1] : Infinity); j++) {\n\t\t\tm++;\n\t\t\tfor (k = 0; k < this.samples_per_chunk[i]; k++) {\n\t\t\t\tif (samples[l]) {\n\t\t\t\t\tsamples[l].description_index = this.sample_description_index[i];\n\t\t\t\t\tsamples[l].chunk_index = m;\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n};\n\nBoxParser.stszBox.prototype.unpack = function(samples) {\n\tvar i;\n\tfor (i = 0; i < this.sample_sizes.length; i++) {\n\t\tsamples[i].size = this.sample_sizes[i];\n\t}\n};\n// file:src/box-diff.js\n\nBoxParser.DIFF_BOXES_PROP_NAMES = [ \"boxes\", \"entries\", \"references\", \"subsamples\",\n\t\t\t\t\t \t \"items\", \"item_infos\", \"extents\", \"associations\",\n\t\t\t\t\t \t \"subsegments\", \"ranges\", \"seekLists\", \"seekPoints\",\n\t\t\t\t\t \t \"esd\", \"levels\"];\n\nBoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [ \"compatible_brands\", \"matrix\", \"opcolor\", \"sample_counts\", \"sample_counts\", \"sample_deltas\",\n\"first_chunk\", \"samples_per_chunk\", \"sample_sizes\", \"chunk_offsets\", \"sample_offsets\", \"sample_description_index\", \"sample_duration\" ];\n\nBoxParser.boxEqualFields = function(box_a, box_b) {\n\tif (box_a && !box_b) return false;\n\tvar prop;\n\tfor (prop in box_a) {\n\t\tif (BoxParser.DIFF_BOXES_PROP_NAMES.indexOf(prop) > -1) {\n\t\t\tcontinue;\n\t\t// } else if (excluded_fields && excluded_fields.indexOf(prop) > -1) {\n\t\t// \tcontinue;\n\t\t} else if (box_a[prop] instanceof BoxParser.Box || box_b[prop] instanceof BoxParser.Box) {\n\t\t\tcontinue;\n\t\t} else if (typeof box_a[prop] === \"undefined\" || typeof box_b[prop] === \"undefined\") {\n\t\t\tcontinue;\n\t\t} else if (typeof box_a[prop] === \"function\" || typeof box_b[prop] === \"function\") {\n\t\t\tcontinue;\n\t\t} else if (\n\t\t\t(box_a.subBoxNames && box_a.subBoxNames.indexOf(prop.slice(0,4)) > -1) ||\n\t\t\t(box_b.subBoxNames && box_b.subBoxNames.indexOf(prop.slice(0,4)) > -1))  {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (prop === \"data\" || prop === \"start\" || prop === \"size\" || prop === \"creation_time\" || prop === \"modification_time\") {\n\t\t\t\tcontinue;\n\t\t\t} else if (BoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(prop) > -1) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (box_a[prop] !== box_b[prop]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n\nBoxParser.boxEqual = function(box_a, box_b) {\n\tif (!BoxParser.boxEqualFields(box_a, box_b)) {\n\t\treturn false;\n\t}\n\tfor (var j = 0; j < BoxParser.DIFF_BOXES_PROP_NAMES.length; j++) {\n\t\tvar name = BoxParser.DIFF_BOXES_PROP_NAMES[j];\n\t\tif (box_a[name] && box_b[name]) {\n\t\t\tif (!BoxParser.boxEqual(box_a[name], box_b[name])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};// file:src/text-mp4.js\n\nvar XMLSubtitlein4Parser = function() {\t\n};\n\nXMLSubtitlein4Parser.prototype.parseSample = function(sample) {\n\tvar res = {};\t\n\tvar i;\n\tres.resources = [];\n\tvar stream = new MP4BoxStream(sample.data.buffer);\n\tif (!sample.subsamples || sample.subsamples.length === 0) {\n\t\tres.documentString = stream.readString(sample.data.length);\n\t} else {\n\t\tres.documentString = stream.readString(sample.subsamples[0].size);\n\t\tif (sample.subsamples.length > 1) {\n\t\t\tfor (i = 1; i < sample.subsamples.length; i++) {\n\t\t\t\tres.resources[i] = stream.readUint8Array(sample.subsamples[i].size);\n\t\t\t}\n\t\t}\n\t}\n\tif (typeof (DOMParser) !== \"undefined\") {\n\t\tres.document = (new DOMParser()).parseFromString(res.documentString, \"application/xml\");\n\t}\n\treturn res;\n};\n\nvar Textin4Parser = function() {\t\n};\n\nTextin4Parser.prototype.parseSample = function(sample) {\n\tvar textString;\n\tvar stream = new MP4BoxStream(sample.data.buffer);\n\ttextString = stream.readString(sample.data.length);\n\treturn textString;\n};\n\nTextin4Parser.prototype.parseConfig = function(data) {\n\tvar textString;\n\tvar stream = new MP4BoxStream(data.buffer);\n\tstream.readUint32(); // version & flags\n\ttextString = stream.readCString();\n\treturn textString;\n};\n\n{\n\texports.XMLSubtitlein4Parser = XMLSubtitlein4Parser;\n\texports.Textin4Parser = Textin4Parser;\n}\n// file:src/isofile.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar ISOFile = function (stream) {\n\t/* MutiBufferStream object used to parse boxes */\n\tthis.stream = stream || new MultiBufferStream();\n\t/* Array of all boxes (in order) found in the file */\n\tthis.boxes = [];\n\t/* Array of all mdats */\n\tthis.mdats = [];\n\t/* Array of all moofs */\n\tthis.moofs = [];\n\t/* Boolean indicating if the file is compatible with progressive parsing (moov first) */\n\tthis.isProgressive = false;\n\t/* Boolean used to fire moov start event only once */\n\tthis.moovStartFound = false;\n\t/* Callback called when the moov parsing starts */\n\tthis.onMoovStart = null;\n\t/* Boolean keeping track of the call to onMoovStart, to avoid double calls */\n\tthis.moovStartSent = false;\n\t/* Callback called when the moov is entirely parsed */\n\tthis.onReady = null;\n\t/* Boolean keeping track of the call to onReady, to avoid double calls */\n\tthis.readySent = false;\n\t/* Callback to call when segments are ready */\n\tthis.onSegment = null;\n\t/* Callback to call when samples are ready */\n\tthis.onSamples = null;\n\t/* Callback to call when there is an error in the parsing or processing of samples */\n\tthis.onError = null;\n\t/* Boolean indicating if the moov box run-length encoded tables of sample information have been processed */\n\tthis.sampleListBuilt = false;\n\t/* Array of Track objects for which fragmentation of samples is requested */\n\tthis.fragmentedTracks = [];\n\t/* Array of Track objects for which extraction of samples is requested */\n\tthis.extractedTracks = [];\n\t/* Boolean indicating that fragmention is ready */\n\tthis.isFragmentationInitialized = false;\n\t/* Boolean indicating that fragmented has started */\n\tthis.sampleProcessingStarted = false;\n\t/* Number of the next 'moof' to generate when fragmenting */\n\tthis.nextMoofNumber = 0;\n\t/* Boolean indicating if the initial list of items has been produced */\n\tthis.itemListBuilt = false;\n\t/* Callback called when the sidx box is entirely parsed */\n\tthis.onSidx = null;\n\t/* Boolean keeping track of the call to onSidx, to avoid double calls */\n\tthis.sidxSent = false;\n};\n\nISOFile.prototype.setSegmentOptions = function(id, user, options) {\n\tvar trak = this.getTrackById(id);\n\tif (trak) {\n\t\tvar fragTrack = {};\n\t\tthis.fragmentedTracks.push(fragTrack);\n\t\tfragTrack.id = id;\n\t\tfragTrack.user = user;\n\t\tfragTrack.trak = trak;\n\t\ttrak.nextSample = 0;\n\t\tfragTrack.segmentStream = null;\n\t\tfragTrack.nb_samples = 1000;\n\t\tfragTrack.rapAlignement = true;\n\t\tif (options) {\n\t\t\tif (options.nbSamples) fragTrack.nb_samples = options.nbSamples;\n\t\t\tif (options.rapAlignement) fragTrack.rapAlignement = options.rapAlignement;\n\t\t}\n\t}\n};\n\nISOFile.prototype.unsetSegmentOptions = function(id) {\n\tvar index = -1;\n\tfor (var i = 0; i < this.fragmentedTracks.length; i++) {\n\t\tvar fragTrack = this.fragmentedTracks[i];\n\t\tif (fragTrack.id == id) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index > -1) {\n\t\tthis.fragmentedTracks.splice(index, 1);\n\t}\n};\n\nISOFile.prototype.setExtractionOptions = function(id, user, options) {\n\tvar trak = this.getTrackById(id);\n\tif (trak) {\n\t\tvar extractTrack = {};\n\t\tthis.extractedTracks.push(extractTrack);\n\t\textractTrack.id = id;\n\t\textractTrack.user = user;\n\t\textractTrack.trak = trak;\n\t\ttrak.nextSample = 0;\n\t\textractTrack.nb_samples = 1000;\n\t\textractTrack.samples = [];\n\t\tif (options) {\n\t\t\tif (options.nbSamples) extractTrack.nb_samples = options.nbSamples;\n\t\t}\n\t}\n};\n\nISOFile.prototype.unsetExtractionOptions = function(id) {\n\tvar index = -1;\n\tfor (var i = 0; i < this.extractedTracks.length; i++) {\n\t\tvar extractTrack = this.extractedTracks[i];\n\t\tif (extractTrack.id == id) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index > -1) {\n\t\tthis.extractedTracks.splice(index, 1);\n\t}\n};\n\nISOFile.prototype.parse = function() {\n\tvar ret;\n\tvar box;\n\tvar parseBoxHeadersOnly = false;\n\n\tif (this.restoreParsePosition)\t{\n\t\tif (!this.restoreParsePosition()) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (true) {\n\n\t\tif (this.hasIncompleteMdat && this.hasIncompleteMdat()) {\n\t\t\tif (this.processIncompleteMdat()) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.saveParsePosition)\t{\n\t\t\t\tthis.saveParsePosition();\n\t\t\t}\n\t\t\tret = BoxParser.parseOneBox(this.stream, parseBoxHeadersOnly);\n\t\t\tif (ret.code === BoxParser.ERR_NOT_ENOUGH_DATA) {\n\t\t\t\tif (this.processIncompleteBox) {\n\t\t\t\t\tif (this.processIncompleteBox(ret)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar box_type;\n\t\t\t\t/* the box is entirely parsed */\n\t\t\t\tbox = ret.box;\n\t\t\t\tbox_type = (box.type !== \"uuid\" ? box.type : box.uuid);\n\t\t\t\t/* store the box in the 'boxes' array to preserve box order (for file rewrite if needed)  */\n\t\t\t\tthis.boxes.push(box);\n\t\t\t\t/* but also store box in a property for more direct access */\n\t\t\t\tswitch (box_type) {\n\t\t\t\t\tcase \"mdat\":\n\t\t\t\t\t\tthis.mdats.push(box);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"moof\":\n\t\t\t\t\t\tthis.moofs.push(box);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"moov\":\n\t\t\t\t\t\tthis.moovStartFound = true;\n\t\t\t\t\t\tif (this.mdats.length === 0) {\n\t\t\t\t\t\t\tthis.isProgressive = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* no break */\n\t\t\t\t\t\t/* falls through */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (this[box_type] !== undefined) {\n\t\t\t\t\t\t\tLog.warn(\"ISOFile\", \"Duplicate Box of type: \"+box_type+\", overriding previous occurrence\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis[box_type] = box;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this.updateUsedBytes) {\n\t\t\t\t\tthis.updateUsedBytes(box, ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nISOFile.prototype.checkBuffer = function (ab) {\n\tif (ab === null || ab === undefined) {\n\t\tthrow(\"Buffer must be defined and non empty\");\n\t}\n\tif (ab.fileStart === undefined) {\n\t\tthrow(\"Buffer must have a fileStart property\");\n\t}\n\tif (ab.byteLength === 0) {\n\t\tLog.warn(\"ISOFile\", \"Ignoring empty buffer (fileStart: \"+ab.fileStart+\")\");\n\t\tthis.stream.logBufferLevel();\n\t\treturn false;\n\t}\n\tLog.info(\"ISOFile\", \"Processing buffer (fileStart: \"+ab.fileStart+\")\");\n\n\t/* mark the bytes in the buffer as not being used yet */\n\tab.usedBytes = 0;\n\tthis.stream.insertBuffer(ab);\n\tthis.stream.logBufferLevel();\n\n\tif (!this.stream.initialized()) {\n\t\tLog.warn(\"ISOFile\", \"Not ready to start parsing\");\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n/* Processes a new ArrayBuffer (with a fileStart property)\n   Returns the next expected file position, or undefined if not ready to parse */\nISOFile.prototype.appendBuffer = function(ab, last) {\n\tvar nextFileStart;\n\tif (!this.checkBuffer(ab)) {\n\t\treturn;\n\t}\n\n\t/* Parse whatever is in the existing buffers */\n\tthis.parse();\n\n\t/* Check if the moovStart callback needs to be called */\n\tif (this.moovStartFound && !this.moovStartSent) {\n\t\tthis.moovStartSent = true;\n\t\tif (this.onMoovStart) this.onMoovStart();\n\t}\n\n\tif (this.moov) {\n\t\t/* A moov box has been entirely parsed */\n\n\t\t/* if this is the first call after the moov is found we initialize the list of samples (may be empty in fragmented files) */\n\t\tif (!this.sampleListBuilt) {\n\t\t\tthis.buildSampleLists();\n\t\t\tthis.sampleListBuilt = true;\n\t\t}\n\n\t\t/* We update the sample information if there are any new moof boxes */\n\t\tthis.updateSampleLists();\n\n\t\t/* If the application needs to be informed that the 'moov' has been found,\n\t\t   we create the information object and callback the application */\n\t\tif (this.onReady && !this.readySent) {\n\t\t\tthis.readySent = true;\n\t\t\tthis.onReady(this.getInfo());\n\t\t}\n\n\t\t/* See if any sample extraction or segment creation needs to be done with the available samples */\n\t\tthis.processSamples(last);\n\n\t\t/* Inform about the best range to fetch next */\n\t\tif (this.nextSeekPosition) {\n\t\t\tnextFileStart = this.nextSeekPosition;\n\t\t\tthis.nextSeekPosition = undefined;\n\t\t} else {\n\t\t\tnextFileStart = this.nextParsePosition;\n\t\t}\n\t\tif (this.stream.getEndFilePositionAfter) {\n\t\t\tnextFileStart = this.stream.getEndFilePositionAfter(nextFileStart);\n\t\t}\n\t} else {\n\t\tif (this.nextParsePosition) {\n\t\t\t/* moov has not been parsed but the first buffer was received,\n\t\t\t   the next fetch should probably be the next box start */\n\t\t\tnextFileStart = this.nextParsePosition;\n\t\t} else {\n\t\t\t/* No valid buffer has been parsed yet, we cannot know what to parse next */\n\t\t\tnextFileStart = 0;\n\t\t}\n\t}\n\tif (this.sidx) {\n\t\tif (this.onSidx && !this.sidxSent) {\n\t\t\tthis.onSidx(this.sidx);\n\t\t\tthis.sidxSent = true;\n\t\t}\n\t}\n\tif (this.meta) {\n\t\tif (this.flattenItemInfo && !this.itemListBuilt) {\n\t\t\tthis.flattenItemInfo();\n\t\t\tthis.itemListBuilt = true;\n\t\t}\n\t\tif (this.processItems) {\n\t\t\tthis.processItems(this.onItem);\n\t\t}\n\t}\n\n\tif (this.stream.cleanBuffers) {\n\t\tLog.info(\"ISOFile\", \"Done processing buffer (fileStart: \"+ab.fileStart+\") - next buffer to fetch should have a fileStart position of \"+nextFileStart);\n\t\tthis.stream.logBufferLevel();\n\t\tthis.stream.cleanBuffers();\n\t\tthis.stream.logBufferLevel(true);\n\t\tLog.info(\"ISOFile\", \"Sample data size in memory: \"+this.getAllocatedSampleDataSize());\n\t}\n\treturn nextFileStart;\n};\n\nISOFile.prototype.getInfo = function() {\n\tvar i, j;\n\tvar movie = {};\n\tvar trak;\n\tvar track;\n\tvar sample_desc;\n\tvar _1904 = (new Date('1904-01-01T00:00:00Z').getTime());\n\n\tif (this.moov) {\n\t\tmovie.hasMoov = true;\n\t\tmovie.duration = this.moov.mvhd.duration;\n\t\tmovie.timescale = this.moov.mvhd.timescale;\n\t\tmovie.isFragmented = (this.moov.mvex != null);\n\t\tif (movie.isFragmented && this.moov.mvex.mehd) {\n\t\t\tmovie.fragment_duration = this.moov.mvex.mehd.fragment_duration;\n\t\t}\n\t\tmovie.isProgressive = this.isProgressive;\n\t\tmovie.hasIOD = (this.moov.iods != null);\n\t\tmovie.brands = [];\n\t\tmovie.brands.push(this.ftyp.major_brand);\n\t\tmovie.brands = movie.brands.concat(this.ftyp.compatible_brands);\n\t\tmovie.created = new Date(_1904+this.moov.mvhd.creation_time*1000);\n\t\tmovie.modified = new Date(_1904+this.moov.mvhd.modification_time*1000);\n\t\tmovie.tracks = [];\n\t\tmovie.audioTracks = [];\n\t\tmovie.videoTracks = [];\n\t\tmovie.subtitleTracks = [];\n\t\tmovie.metadataTracks = [];\n\t\tmovie.hintTracks = [];\n\t\tmovie.otherTracks = [];\n\t\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\t\ttrak = this.moov.traks[i];\n\t\t\tsample_desc = trak.mdia.minf.stbl.stsd.entries[0];\n\t\t\ttrack = {};\n\t\t\tmovie.tracks.push(track);\n\t\t\ttrack.id = trak.tkhd.track_id;\n\t\t\ttrack.name = trak.mdia.hdlr.name;\n\t\t\ttrack.references = [];\n\t\t\tif (trak.tref) {\n\t\t\t\tfor (j = 0; j < trak.tref.boxes.length; j++) {\n\t\t\t\t\tref = {};\n\t\t\t\t\ttrack.references.push(ref);\n\t\t\t\t\tref.type = trak.tref.boxes[j].type;\n\t\t\t\t\tref.track_ids = trak.tref.boxes[j].track_ids;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (trak.edts) {\n\t\t\t\ttrack.edits = trak.edts.elst.entries;\n\t\t\t}\n\t\t\ttrack.created = new Date(_1904+trak.tkhd.creation_time*1000);\n\t\t\ttrack.modified = new Date(_1904+trak.tkhd.modification_time*1000);\n\t\t\ttrack.movie_duration = trak.tkhd.duration;\n\t\t\ttrack.movie_timescale = movie.timescale;\n\t\t\ttrack.layer = trak.tkhd.layer;\n\t\t\ttrack.alternate_group = trak.tkhd.alternate_group;\n\t\t\ttrack.volume = trak.tkhd.volume;\n\t\t\ttrack.matrix = trak.tkhd.matrix;\n\t\t\ttrack.track_width = trak.tkhd.width/(1<<16);\n\t\t\ttrack.track_height = trak.tkhd.height/(1<<16);\n\t\t\ttrack.timescale = trak.mdia.mdhd.timescale;\n\t\t\ttrack.cts_shift = trak.mdia.minf.stbl.cslg;\n\t\t\ttrack.duration = trak.mdia.mdhd.duration;\n\t\t\ttrack.samples_duration = trak.samples_duration;\n\t\t\ttrack.codec = sample_desc.getCodec();\n\t\t\ttrack.kind = (trak.udta && trak.udta.kinds.length ? trak.udta.kinds[0] : { schemeURI: \"\", value: \"\"});\n\t\t\ttrack.language = (trak.mdia.elng ? trak.mdia.elng.extended_language : trak.mdia.mdhd.languageString);\n\t\t\ttrack.nb_samples = trak.samples.length;\n\t\t\ttrack.size = trak.samples_size;\n\t\t\ttrack.bitrate = (track.size*8*track.timescale)/track.samples_duration;\n\t\t\tif (sample_desc.isAudio()) {\n\t\t\t\ttrack.type = \"audio\";\n\t\t\t\tmovie.audioTracks.push(track);\n\t\t\t\ttrack.audio = {};\n\t\t\t\ttrack.audio.sample_rate = sample_desc.getSampleRate();\n\t\t\t\ttrack.audio.channel_count = sample_desc.getChannelCount();\n\t\t\t\ttrack.audio.sample_size = sample_desc.getSampleSize();\n\t\t\t} else if (sample_desc.isVideo()) {\n\t\t\t\ttrack.type = \"video\";\n\t\t\t\tmovie.videoTracks.push(track);\n\t\t\t\ttrack.video = {};\n\t\t\t\ttrack.video.width = sample_desc.getWidth();\n\t\t\t\ttrack.video.height = sample_desc.getHeight();\n\t\t\t} else if (sample_desc.isSubtitle()) {\n\t\t\t\ttrack.type = \"subtitles\";\n\t\t\t\tmovie.subtitleTracks.push(track);\n\t\t\t} else if (sample_desc.isHint()) {\n\t\t\t\ttrack.type = \"metadata\";\n\t\t\t\tmovie.hintTracks.push(track);\n\t\t\t} else if (sample_desc.isMetadata()) {\n\t\t\t\ttrack.type = \"metadata\";\n\t\t\t\tmovie.metadataTracks.push(track);\n\t\t\t} else {\n\t\t\t\ttrack.type = \"metadata\";\n\t\t\t\tmovie.otherTracks.push(track);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmovie.hasMoov = false;\n\t}\n\tmovie.mime = \"\";\n\tif (movie.hasMoov && movie.tracks) {\n\t\tif (movie.videoTracks && movie.videoTracks.length > 0) {\n\t\t\tmovie.mime += 'video/mp4; codecs=\\\"';\n\t\t} else if (movie.audioTracks && movie.audioTracks.length > 0) {\n\t\t\tmovie.mime += 'audio/mp4; codecs=\\\"';\n\t\t} else {\n\t\t\tmovie.mime += 'application/mp4; codecs=\\\"';\n\t\t}\n\t\tfor (i = 0; i < movie.tracks.length; i++) {\n\t\t\tif (i !== 0) movie.mime += ',';\n\t\t\tmovie.mime+= movie.tracks[i].codec;\n\t\t}\n\t\tmovie.mime += '\\\"; profiles=\\\"';\n\t\tmovie.mime += this.ftyp.compatible_brands.join();\n\t\tmovie.mime += '\\\"';\n\t}\n\treturn movie;\n};\n\nISOFile.prototype.processSamples = function(last) {\n\tvar i;\n\tvar trak;\n\tif (!this.sampleProcessingStarted) return;\n\n\t/* For each track marked for fragmentation,\n\t   check if the next sample is there (i.e. if the sample information is known (i.e. moof has arrived) and if it has been downloaded)\n\t   and create a fragment with it */\n\tif (this.isFragmentationInitialized && this.onSegment !== null) {\n\t\tfor (i = 0; i < this.fragmentedTracks.length; i++) {\n\t\t\tvar fragTrak = this.fragmentedTracks[i];\n\t\t\ttrak = fragTrak.trak;\n\t\t\twhile (trak.nextSample < trak.samples.length && this.sampleProcessingStarted) {\n\t\t\t\t/* The sample information is there (either because the file is not fragmented and this is not the last sample,\n\t\t\t\tor because the file is fragmented and the moof for that sample has been received */\n\t\t\t\tLog.debug(\"ISOFile\", \"Creating media fragment on track #\"+fragTrak.id +\" for sample \"+trak.nextSample);\n\t\t\t\tvar result = this.createFragment(fragTrak.id, trak.nextSample, fragTrak.segmentStream);\n\t\t\t\tif (result) {\n\t\t\t\t\tfragTrak.segmentStream = result;\n\t\t\t\t\ttrak.nextSample++;\n\t\t\t\t} else {\n\t\t\t\t\t/* The fragment could not be created because the media data is not there (not downloaded), wait for it */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* A fragment is created by sample, but the segment is the accumulation in the buffer of these fragments.\n\t\t\t\t   It is flushed only as requested by the application (nb_samples) to avoid too many callbacks */\n\t\t\t\tif (trak.nextSample % fragTrak.nb_samples === 0 || (last || trak.nextSample >= trak.samples.length)) {\n\t\t\t\t\tLog.info(\"ISOFile\", \"Sending fragmented data on track #\"+fragTrak.id+\" for samples [\"+Math.max(0,trak.nextSample-fragTrak.nb_samples)+\",\"+(trak.nextSample-1)+\"]\");\n\t\t\t\t\tLog.info(\"ISOFile\", \"Sample data size in memory: \"+this.getAllocatedSampleDataSize());\n\t\t\t\t\tif (this.onSegment) {\n\t\t\t\t\t\tthis.onSegment(fragTrak.id, fragTrak.user, fragTrak.segmentStream.buffer, trak.nextSample, (last || trak.nextSample >= trak.samples.length));\n\t\t\t\t\t}\n\t\t\t\t\t/* force the creation of a new buffer */\n\t\t\t\t\tfragTrak.segmentStream = null;\n\t\t\t\t\tif (fragTrak !== this.fragmentedTracks[i]) {\n\t\t\t\t\t\t/* make sure we can stop fragmentation if needed */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.onSamples !== null) {\n\t\t/* For each track marked for data export,\n\t\t   check if the next sample is there (i.e. has been downloaded) and send it */\n\t\tfor (i = 0; i < this.extractedTracks.length; i++) {\n\t\t\tvar extractTrak = this.extractedTracks[i];\n\t\t\ttrak = extractTrak.trak;\n\t\t\twhile (trak.nextSample < trak.samples.length && this.sampleProcessingStarted) {\n\t\t\t\tLog.debug(\"ISOFile\", \"Exporting on track #\"+extractTrak.id +\" sample #\"+trak.nextSample);\n\t\t\t\tvar sample = this.getSample(trak, trak.nextSample);\n\t\t\t\tif (sample) {\n\t\t\t\t\ttrak.nextSample++;\n\t\t\t\t\textractTrak.samples.push(sample);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trak.nextSample % extractTrak.nb_samples === 0 || trak.nextSample >= trak.samples.length) {\n\t\t\t\t\tLog.debug(\"ISOFile\", \"Sending samples on track #\"+extractTrak.id+\" for sample \"+trak.nextSample);\n\t\t\t\t\tif (this.onSamples) {\n\t\t\t\t\t\tthis.onSamples(extractTrak.id, extractTrak.user, extractTrak.samples);\n\t\t\t\t\t}\n\t\t\t\t\textractTrak.samples = [];\n\t\t\t\t\tif (extractTrak !== this.extractedTracks[i]) {\n\t\t\t\t\t\t/* check if the extraction needs to be stopped */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/* Find and return specific boxes using recursion and early return */\nISOFile.prototype.getBox = function(type) {\n  var result = this.getBoxes(type, true);\n  return (result.length ? result[0] : null);\n};\n\nISOFile.prototype.getBoxes = function(type, returnEarly) {\n  var result = [];\n  ISOFile._sweep.call(this, type, result, returnEarly);\n  return result;\n};\n\nISOFile._sweep = function(type, result, returnEarly) {\n  if (this.type && this.type == type) result.push(this);\n  for (var box in this.boxes) {\n    if (result.length && returnEarly) return;\n    ISOFile._sweep.call(this.boxes[box], type, result, returnEarly);\n  }\n};\n\nISOFile.prototype.getTrackSamplesInfo = function(track_id) {\n\tvar track = this.getTrackById(track_id);\n\tif (track) {\n\t\treturn track.samples;\n\t} else {\n\t\treturn;\n\t}\n};\n\nISOFile.prototype.getTrackSample = function(track_id, number) {\n\tvar track = this.getTrackById(track_id);\n\tvar sample = this.getSample(track, number);\n\treturn sample;\n};\n\n/* Called by the application to release the resources associated to samples already forwarded to the application */\nISOFile.prototype.releaseUsedSamples = function (id, sampleNum) {\n\tvar size = 0;\n\tvar trak = this.getTrackById(id);\n\tif (!trak.lastValidSample) trak.lastValidSample = 0;\n\tfor (var i = trak.lastValidSample; i < sampleNum; i++) {\n\t\tsize+=this.releaseSample(trak, i);\n\t}\n\tLog.info(\"ISOFile\", \"Track #\"+id+\" released samples up to \"+sampleNum+\" (released size: \"+size+\", remaining: \"+this.samplesDataSize+\")\");\n\ttrak.lastValidSample = sampleNum;\n};\n\nISOFile.prototype.start = function() {\n\tthis.sampleProcessingStarted = true;\n\tthis.processSamples(false);\n};\n\nISOFile.prototype.stop = function() {\n\tthis.sampleProcessingStarted = false;\n};\n\n/* Called by the application to flush the remaining samples (e.g. once the download is finished or when no more samples will be added) */\nISOFile.prototype.flush = function() {\n\tLog.info(\"ISOFile\", \"Flushing remaining samples\");\n\tthis.updateSampleLists();\n\tthis.processSamples(true);\n\tthis.stream.cleanBuffers();\n\tthis.stream.logBufferLevel(true);\n};\n\n/* Finds the byte offset for a given time on a given track\n   also returns the time of the previous rap */\nISOFile.prototype.seekTrack = function(time, useRap, trak) {\n\tvar j;\n\tvar sample;\n\tvar seek_offset = Infinity;\n\tvar rap_seek_sample_num = 0;\n\tvar seek_sample_num = 0;\n\tvar timescale;\n\n\tif (trak.samples.length === 0) {\n\t\tLog.info(\"ISOFile\", \"No sample in track, cannot seek! Using time \"+Log.getDurationString(0, 1) +\" and offset: \"+0);\n\t\treturn { offset: 0, time: 0 };\n\t}\n\n\tfor (j = 0; j < trak.samples.length; j++) {\n\t\tsample = trak.samples[j];\n\t\tif (j === 0) {\n\t\t\tseek_sample_num = 0;\n\t\t\ttimescale = sample.timescale;\n\t\t} else if (sample.cts > time * sample.timescale) {\n\t\t\tseek_sample_num = j-1;\n\t\t\tbreak;\n\t\t}\n\t\tif (useRap && sample.is_sync) {\n\t\t\trap_seek_sample_num = j;\n\t\t}\n\t}\n\tif (useRap) {\n\t\tseek_sample_num = rap_seek_sample_num;\n\t}\n\ttime = trak.samples[seek_sample_num].cts;\n\ttrak.nextSample = seek_sample_num;\n\twhile (trak.samples[seek_sample_num].alreadyRead === trak.samples[seek_sample_num].size) {\n\t\t// No remaining samples to look for, all are downloaded.\n\t\tif (!trak.samples[seek_sample_num + 1]) {\n\t\t\tbreak;\n\t\t}\n\t\tseek_sample_num++;\n\t}\n\tseek_offset = trak.samples[seek_sample_num].offset+trak.samples[seek_sample_num].alreadyRead;\n\tLog.info(\"ISOFile\", \"Seeking to \"+(useRap ? \"RAP\": \"\")+\" sample #\"+trak.nextSample+\" on track \"+trak.tkhd.track_id+\", time \"+Log.getDurationString(time, timescale) +\" and offset: \"+seek_offset);\n\treturn { offset: seek_offset, time: time/timescale };\n};\n\n/* Finds the byte offset in the file corresponding to the given time or to the time of the previous RAP */\nISOFile.prototype.seek = function(time, useRap) {\n\tvar moov = this.moov;\n\tvar trak;\n\tvar trak_seek_info;\n\tvar i;\n\tvar seek_info = { offset: Infinity, time: Infinity };\n\tif (!this.moov) {\n\t\tthrow \"Cannot seek: moov not received!\";\n\t} else {\n\t\tfor (i = 0; i<moov.traks.length; i++) {\n\t\t\ttrak = moov.traks[i];\n\t\t\ttrak_seek_info = this.seekTrack(time, useRap, trak);\n\t\t\tif (trak_seek_info.offset < seek_info.offset) {\n\t\t\t\tseek_info.offset = trak_seek_info.offset;\n\t\t\t}\n\t\t\tif (trak_seek_info.time < seek_info.time) {\n\t\t\t\tseek_info.time = trak_seek_info.time;\n\t\t\t}\n\t\t}\n\t\tLog.info(\"ISOFile\", \"Seeking at time \"+Log.getDurationString(seek_info.time, 1)+\" needs a buffer with a fileStart position of \"+seek_info.offset);\n\t\tif (seek_info.offset === Infinity) {\n\t\t\t/* No sample info, in all tracks, cannot seek */\n\t\t\tseek_info = { offset: this.nextParsePosition, time: 0 };\n\t\t} else {\n\t\t\t/* check if the seek position is already in some buffer and\n\t\t\t in that case return the end of that buffer (or of the last contiguous buffer) */\n\t\t\t/* TODO: Should wait until append operations are done */\n\t\t\tseek_info.offset = this.stream.getEndFilePositionAfter(seek_info.offset);\n\t\t}\n\t\tLog.info(\"ISOFile\", \"Adjusted seek position (after checking data already in buffer): \"+seek_info.offset);\n\t\treturn seek_info;\n\t}\n};\n\nISOFile.prototype.equal = function(b) {\n\tvar box_index = 0;\n\twhile (box_index < this.boxes.length && box_index < b.boxes.length) {\n\t\tvar a_box = this.boxes[box_index];\n\t\tvar b_box = b.boxes[box_index];\n\t\tif (!BoxParser.boxEqual(a_box, b_box)) {\n\t\t\treturn false;\n\t\t}\n\t\tbox_index++;\n\t}\n\treturn true;\n};\n\n{\n\texports.ISOFile = ISOFile;\n}\n// file:src/isofile-advanced-parsing.js\n/* position in the current buffer of the beginning of the last box parsed */\nISOFile.prototype.lastBoxStartPosition = 0;\n/* indicator if the parsing is stuck in the middle of an mdat box */\nISOFile.prototype.parsingMdat = null;\n/* next file position that the parser needs:\n    - 0 until the first buffer (i.e. fileStart ===0) has been received \n    - otherwise, the next box start until the moov box has been parsed\n    - otherwise, the position of the next sample to fetch\n */\nISOFile.prototype.nextParsePosition = 0;\n/* keep mdat data */\nISOFile.prototype.discardMdatData = false;\n\nISOFile.prototype.processIncompleteBox = function(ret) {\n\tvar box;\n\tvar merged;\n\tvar found;\n\t\n\t/* we did not have enough bytes in the current buffer to parse the entire box */\n\tif (ret.type === \"mdat\") { \n\t\t/* we had enough bytes to get its type and size and it's an 'mdat' */\n\t\t\n\t\t/* special handling for mdat boxes, since we don't actually need to parse it linearly \n\t\t   we create the box */\n\t\tbox = new BoxParser[ret.type+\"Box\"](ret.size);\t\n\t\tthis.parsingMdat = box;\n\t\tthis.boxes.push(box);\n\t\tthis.mdats.push(box);\t\t\t\n\t\tbox.start = ret.start;\n\t\tbox.hdr_size = ret.hdr_size;\n\t\tthis.stream.addUsedBytes(box.hdr_size);\n\n\t\t/* indicate that the parsing should start from the end of the box */\n\t\tthis.lastBoxStartPosition = box.start + box.size;\n \t\t/* let's see if we have the end of the box in the other buffers */\n\t\tfound = this.stream.seek(box.start + box.size, false, this.discardMdatData);\n\t\tif (found) {\n\t\t\t/* found the end of the box */\n\t\t\tthis.parsingMdat = null;\n\t\t\t/* let's see if we can parse more in this buffer */\n\t\t\treturn true;\n\t\t} else {\n\t\t\t/* 'mdat' end not found in the existing buffers */\n\t\t\t/* determine the next position in the file to start parsing from */\n\t\t\tif (!this.moovStartFound) {\n\t\t\t\t/* moov not find yet, \n\t\t\t\t   the file probably has 'mdat' at the beginning, and 'moov' at the end, \n\t\t\t\t   indicate that the downloader should not try to download those bytes now */\n\t\t\t\tthis.nextParsePosition = box.start + box.size;\n\t\t\t} else {\n\t\t\t\t/* we have the start of the moov box, \n\t\t\t\t   the next bytes should try to complete the current 'mdat' */\n\t\t\t\tthis.nextParsePosition = this.stream.findEndContiguousBuf();\n\t\t\t}\n\t\t\t/* not much we can do, wait for more buffers to arrive */\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/* box is incomplete, we may not even know its type */\n\t\tif (ret.type === \"moov\") { \n\t\t\t/* the incomplete box is a 'moov' box */\n\t\t\tthis.moovStartFound = true;\n\t\t\tif (this.mdats.length === 0) {\n\t\t\t\tthis.isProgressive = true;\n\t\t\t}\n\t\t}\n\t\t/* either it's not an mdat box (and we need to parse it, we cannot skip it)\n\t\t   (TODO: we could skip 'free' boxes ...)\n\t\t\t   or we did not have enough data to parse the type and size of the box, \n\t\t   we try to concatenate the current buffer with the next buffer to restart parsing */\n\t\tmerged = (this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : false);\n\t\tif (merged) {\n\t\t\t/* The next buffer was contiguous, the merging succeeded,\n\t\t\t   we can now continue parsing, \n\t\t\t   the next best position to parse is at the end of this new buffer */\n\t\t\tthis.nextParsePosition = this.stream.getEndPosition();\n\t\t\treturn true;\n\t\t} else {\n\t\t\t/* we cannot concatenate existing buffers because they are not contiguous or because there is no additional buffer */\n\t\t\t/* The next best position to parse is still at the end of this old buffer */\n\t\t\tif (!ret.type) {\n\t\t\t\t/* There were not enough bytes in the buffer to parse the box type and length,\n\t\t\t\t   the next fetch should retrieve those missing bytes, i.e. the next bytes after this buffer */\n\t\t\t\tthis.nextParsePosition = this.stream.getEndPosition();\n\t\t\t} else {\n\t\t\t\t/* we had enough bytes to parse size and type of the incomplete box\n\t\t\t\t   if we haven't found yet the moov box, skip this one and try the next one \n\t\t\t\t   if we have found the moov box, let's continue linear parsing */\n\t\t\t\tif (this.moovStartFound) {\n\t\t\t\t\tthis.nextParsePosition = this.stream.getEndPosition();\n\t\t\t\t} else {\n\t\t\t\t\tthis.nextParsePosition = this.stream.getPosition() + ret.size;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nISOFile.prototype.hasIncompleteMdat = function () {\n\treturn (this.parsingMdat !== null);\n};\n\nISOFile.prototype.processIncompleteMdat = function () {\n\tvar box;\n\tvar found;\n\t\n\t/* we are in the parsing of an incomplete mdat box */\n\tbox = this.parsingMdat;\n\n\tfound = this.stream.seek(box.start + box.size, false, this.discardMdatData);\n\tif (found) {\n\t\tLog.debug(\"ISOFile\", \"Found 'mdat' end in buffered data\");\n\t\t/* the end of the mdat has been found */ \n\t\tthis.parsingMdat = null;\n\t\t/* we can parse more in this buffer */\n\t\treturn true;\n\t} else {\n\t\t/* we don't have the end of this mdat yet, \n\t\t   indicate that the next byte to fetch is the end of the buffers we have so far, \n\t\t   return and wait for more buffer to come */\n\t\tthis.nextParsePosition = this.stream.findEndContiguousBuf();\n\t\treturn false;\n\t}\n};\n\nISOFile.prototype.restoreParsePosition = function() {\n\t/* Reposition at the start position of the previous box not entirely parsed */\n\treturn this.stream.seek(this.lastBoxStartPosition, true, this.discardMdatData);\n};\n\nISOFile.prototype.saveParsePosition = function() {\n\t/* remember the position of the box start in case we need to roll back (if the box is incomplete) */\n\tthis.lastBoxStartPosition = this.stream.getPosition();\t\n};\n\nISOFile.prototype.updateUsedBytes = function(box, ret) {\n\tif (this.stream.addUsedBytes) {\n\t\tif (box.type === \"mdat\") {\n\t\t\t/* for an mdat box, only its header is considered used, other bytes will be used when sample data is requested */\n\t\t\tthis.stream.addUsedBytes(box.hdr_size);\n\t\t\tif (this.discardMdatData) {\n\t\t\t\tthis.stream.addUsedBytes(box.size-box.hdr_size);\n\t\t\t}\n\t\t} else {\n\t\t\t/* for all other boxes, the entire box data is considered used */\n\t\t\tthis.stream.addUsedBytes(box.size);\n\t\t}\t\n\t}\n};\n// file:src/isofile-advanced-creation.js\nISOFile.prototype.add = BoxParser.Box.prototype.add;\nISOFile.prototype.addBox = BoxParser.Box.prototype.addBox;\n\nISOFile.prototype.init = function (_options) {\n\tvar options = _options || {}; \n\tthis.add(\"ftyp\").set(\"major_brand\", (options.brands && options.brands[0]) || \"iso4\")\n\t\t\t\t\t\t\t   .set(\"minor_version\", 0)\n\t\t\t\t\t\t\t   .set(\"compatible_brands\", options.brands || [\"iso4\"]);\n\tvar moov = this.add(\"moov\");\n\tmoov.add(\"mvhd\").set(\"timescale\", options.timescale || 600)\n\t\t\t\t\t.set(\"rate\", options.rate || 1<<16)\n\t\t\t\t\t.set(\"creation_time\", 0)\n\t\t\t\t\t.set(\"modification_time\", 0)\n\t\t\t\t\t.set(\"duration\", options.duration || 0)\n\t\t\t\t\t.set(\"volume\", (options.width) ? 0 : 0x0100)\n\t\t\t\t\t.set(\"matrix\", [ 1<<16, 0, 0, 0, 1<<16, 0, 0, 0, 0x40000000])\n\t\t\t\t\t.set(\"next_track_id\", 1);\n\tmoov.add(\"mvex\");\n\treturn this;\n};\n\nISOFile.prototype.addTrack = function (_options) {\n\tif (!this.moov) {\n\t\tthis.init(_options);\n\t}\n\n\tvar options = _options || {}; \n\toptions.width = options.width || 320;\n\toptions.height = options.height || 320;\n\toptions.id = options.id || this.moov.mvhd.next_track_id;\n\toptions.type = options.type || \"avc1\";\n\n\tvar trak = this.moov.add(\"trak\");\n\tthis.moov.mvhd.next_track_id = options.id+1;\n\ttrak.add(\"tkhd\").set(\"flags\",BoxParser.TKHD_FLAG_ENABLED | \n\t\t\t\t\t\t\t\t BoxParser.TKHD_FLAG_IN_MOVIE | \n\t\t\t\t\t\t\t\t BoxParser.TKHD_FLAG_IN_PREVIEW)\n\t\t\t\t\t.set(\"creation_time\",0)\n\t\t\t\t\t.set(\"modification_time\", 0)\n\t\t\t\t\t.set(\"track_id\", options.id)\n\t\t\t\t\t.set(\"duration\", options.duration || 0)\n\t\t\t\t\t.set(\"layer\", options.layer || 0)\n\t\t\t\t\t.set(\"alternate_group\", 0)\n\t\t\t\t\t.set(\"volume\", 1)\n\t\t\t\t\t.set(\"matrix\", [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ])\n\t\t\t\t\t.set(\"width\", options.width)\n\t\t\t\t\t.set(\"height\", options.height);\n\n\tvar mdia = trak.add(\"mdia\");\n\tmdia.add(\"mdhd\").set(\"creation_time\", 0)\n\t\t\t\t\t.set(\"modification_time\", 0)\n\t\t\t\t\t.set(\"timescale\", options.timescale || 1)\n\t\t\t\t\t.set(\"duration\", options.media_duration || 0)\n\t\t\t\t\t.set(\"language\", options.language || \"und\");\n\n\tmdia.add(\"hdlr\").set(\"handler\", options.hdlr || \"vide\")\n\t\t\t\t\t.set(\"name\", options.name || \"Track created with MP4Box.js\");\n\n\tmdia.add(\"elng\").set(\"extended_language\", options.language || \"fr-FR\");\n\n\tvar minf = mdia.add(\"minf\");\n\tif (BoxParser[options.type+\"SampleEntry\"] === undefined) return;\n\tvar sample_description_entry = new BoxParser[options.type+\"SampleEntry\"]();\n\tsample_description_entry.data_reference_index = 1;\n\tvar media_type = \"\";\n\tfor (var mediaType in BoxParser.sampleEntryCodes) {\n\t\tvar codes = BoxParser.sampleEntryCodes[mediaType];\n\t\tfor (var i = 0; i < codes.length; i++) {\n\t\t\tif (codes.indexOf(options.type) > -1) {\n\t\t\t\tmedia_type = mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tswitch(media_type) {\n\t\tcase \"Visual\":\n\t\t\tminf.add(\"vmhd\").set(\"graphicsmode\",0).set(\"opcolor\", [ 0, 0, 0 ]);\n\t\t\tsample_description_entry.set(\"width\", options.width)\n\t\t\t\t\t\t.set(\"height\", options.height)\n\t\t\t\t\t\t.set(\"horizresolution\", 0x48<<16)\n\t\t\t\t\t\t.set(\"vertresolution\", 0x48<<16)\n\t\t\t\t\t\t.set(\"frame_count\", 1)\n\t\t\t\t\t\t.set(\"compressorname\", options.type+\" Compressor\")\n\t\t\t\t\t\t.set(\"depth\", 0x18);\n\t\t\tif (options.avcDecoderConfigRecord) {\n\t\t\t\tvar avcC = new BoxParser.avcCBox();\n\t\t\t\tvar stream = new MP4BoxStream(options.avcDecoderConfigRecord);\n\t\t\t\tavcC.parse(stream);\n\t\t\t\tsample_description_entry.addBox(avcC);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Audio\":\n\t\t\tminf.add(\"smhd\").set(\"balance\", options.balance || 0);\n\t\t\tsample_description_entry.set(\"channel_count\", options.channel_count || 2)\n\t\t\t\t\t\t.set(\"samplesize\", options.samplesize || 16)\n\t\t\t\t\t\t.set(\"samplerate\", options.samplerate || 1<<16);\n\t\t\tbreak;\n\t\tcase \"Hint\":\n\t\t\tminf.add(\"hmhd\"); // TODO: add properties\n\t\t\tbreak;\n\t\tcase \"Subtitle\":\n\t\t\tminf.add(\"sthd\");\n\t\t\tswitch (options.type) {\n\t\t\t\tcase \"stpp\":\n\t\t\t\t\tsample_description_entry.set(\"namespace\", options.namespace || \"nonamespace\")\n\t\t\t\t\t\t\t\t.set(\"schema_location\", options.schema_location || \"\")\n\t\t\t\t\t\t\t\t.set(\"auxiliary_mime_types\", options.auxiliary_mime_types || \"\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Metadata\":\n\t\t\tminf.add(\"nmhd\");\n\t\t\tbreak;\n\t\tcase \"System\":\n\t\t\tminf.add(\"nmhd\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tminf.add(\"nmhd\");\n\t\t\tbreak;\n\t}\n\tif (options.description) {\n\t\tsample_description_entry.addBox(options.description);\n\t}\n\tif (options.description_boxes) {\n\t\toptions.description_boxes.forEach(function (b) {\n\t\t\tsample_description_entry.addBox(b);\n\t\t});\n\t}\n\tminf.add(\"dinf\").add(\"dref\").addEntry((new BoxParser[\"url Box\"]()).set(\"flags\", 0x1));\n\tvar stbl = minf.add(\"stbl\");\n\tstbl.add(\"stsd\").addEntry(sample_description_entry);\n\tstbl.add(\"stts\").set(\"sample_counts\", [])\n\t\t\t\t\t.set(\"sample_deltas\", []);\n\tstbl.add(\"stsc\").set(\"first_chunk\", [])\n\t\t\t\t\t.set(\"samples_per_chunk\", [])\n\t\t\t\t\t.set(\"sample_description_index\", []);\n\tstbl.add(\"stco\").set(\"chunk_offsets\", []);\n\tstbl.add(\"stsz\").set(\"sample_sizes\", []);\n\n\tthis.moov.mvex.add(\"trex\").set(\"track_id\", options.id)\n\t\t\t\t\t\t\t  .set(\"default_sample_description_index\", options.default_sample_description_index || 1)\n\t\t\t\t\t\t\t  .set(\"default_sample_duration\", options.default_sample_duration || 0)\n\t\t\t\t\t\t\t  .set(\"default_sample_size\", options.default_sample_size || 0)\n\t\t\t\t\t\t\t  .set(\"default_sample_flags\", options.default_sample_flags || 0);\n\tthis.buildTrakSampleLists(trak);\n\treturn options.id;\n};\n\nBoxParser.Box.prototype.computeSize = function(stream_) {\n\tvar stream = stream_ || new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tthis.write(stream);\n};\n\nISOFile.prototype.addSample = function (track_id, data, _options) {\n\tvar options = _options || {};\n\tvar sample = {};\n\tvar trak = this.getTrackById(track_id);\n\tif (trak === null) return;\n    sample.number = trak.samples.length;\n\tsample.track_id = trak.tkhd.track_id;\n\tsample.timescale = trak.mdia.mdhd.timescale;\n\tsample.description_index = (options.sample_description_index ? options.sample_description_index - 1: 0);\n\tsample.description = trak.mdia.minf.stbl.stsd.entries[sample.description_index];\n\tsample.data = data;\n\tsample.size = data.byteLength;\n\tsample.alreadyRead = sample.size;\n\tsample.duration = options.duration || 1;\n\tsample.cts = options.cts || 0;\n\tsample.dts = options.dts || 0;\n\tsample.is_sync = options.is_sync || false;\n\tsample.is_leading = options.is_leading || 0;\n\tsample.depends_on = options.depends_on || 0;\n\tsample.is_depended_on = options.is_depended_on || 0;\n\tsample.has_redundancy = options.has_redundancy || 0;\n\tsample.degradation_priority = options.degradation_priority || 0;\n\tsample.offset = 0;\n\tsample.subsamples = options.subsamples;\n\ttrak.samples.push(sample);\n\ttrak.samples_size += sample.size;\n\ttrak.samples_duration += sample.duration;\n\tif (!trak.first_dts) {\n\t\ttrak.first_dts = options.dts;\n\t}\n\n\tthis.processSamples();\n\t\n\tvar moof = this.createSingleSampleMoof(sample);\n\tthis.addBox(moof);\n\tmoof.computeSize();\n\t/* adjusting the data_offset now that the moof size is known*/\n\tmoof.trafs[0].truns[0].data_offset = moof.size+8; //8 is mdat header\n\tthis.add(\"mdat\").data = new Uint8Array(data);\n\treturn sample;\n};\n\nISOFile.prototype.createSingleSampleMoof = function(sample) {\n\tvar sample_flags = 0;\n\tif (sample.is_sync)\n\t\tsample_flags = (1 << 25);  // sample_depends_on_none (I picture)\n\telse\n\t\tsample_flags = (1 << 16);  // non-sync\n\n\tvar moof = new BoxParser.moofBox();\n\tmoof.add(\"mfhd\").set(\"sequence_number\", this.nextMoofNumber);\n\tthis.nextMoofNumber++;\n\tvar traf = moof.add(\"traf\");\n\tvar trak = this.getTrackById(sample.track_id);\n\ttraf.add(\"tfhd\").set(\"track_id\", sample.track_id)\n\t\t\t\t\t.set(\"flags\", BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF);\n\ttraf.add(\"tfdt\").set(\"baseMediaDecodeTime\", (sample.dts - trak.first_dts));\n\ttraf.add(\"trun\").set(\"flags\", BoxParser.TRUN_FLAGS_DATA_OFFSET | BoxParser.TRUN_FLAGS_DURATION | \n\t\t\t\t \t\t\t\t  BoxParser.TRUN_FLAGS_SIZE | BoxParser.TRUN_FLAGS_FLAGS | \n\t\t\t\t \t\t\t\t  BoxParser.TRUN_FLAGS_CTS_OFFSET)\n\t\t\t\t\t.set(\"data_offset\",0)\n\t\t\t\t\t.set(\"first_sample_flags\",0)\n\t\t\t\t\t.set(\"sample_count\",1)\n\t\t\t\t\t.set(\"sample_duration\",[sample.duration])\n\t\t\t\t\t.set(\"sample_size\",[sample.size])\n\t\t\t\t\t.set(\"sample_flags\",[sample_flags])\n\t\t\t\t\t.set(\"sample_composition_time_offset\", [sample.cts - sample.dts]);\n\treturn moof;\n};\n\n// file:src/isofile-sample-processing.js\n/* Index of the last moof box received */\nISOFile.prototype.lastMoofIndex = 0;\n\n/* size of the buffers allocated for samples */\nISOFile.prototype.samplesDataSize = 0;\n\n/* Resets all sample tables */\nISOFile.prototype.resetTables = function () {\n\tvar i;\n\tvar trak, stco, stsc, stsz, stts, ctts, stss;\n\tthis.initial_duration = this.moov.mvhd.duration;\n\tthis.moov.mvhd.duration = 0;\n\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\ttrak = this.moov.traks[i];\n\t\ttrak.tkhd.duration = 0;\n\t\ttrak.mdia.mdhd.duration = 0;\n\t\tstco = trak.mdia.minf.stbl.stco || trak.mdia.minf.stbl.co64;\n\t\tstco.chunk_offsets = [];\n\t\tstsc = trak.mdia.minf.stbl.stsc;\n\t\tstsc.first_chunk = [];\n\t\tstsc.samples_per_chunk = [];\n\t\tstsc.sample_description_index = [];\n\t\tstsz = trak.mdia.minf.stbl.stsz || trak.mdia.minf.stbl.stz2;\n\t\tstsz.sample_sizes = [];\n\t\tstts = trak.mdia.minf.stbl.stts;\n\t\tstts.sample_counts = [];\n\t\tstts.sample_deltas = [];\n\t\tctts = trak.mdia.minf.stbl.ctts;\n\t\tif (ctts) {\n\t\t\tctts.sample_counts = [];\n\t\t\tctts.sample_offsets = [];\n\t\t}\n\t\tstss = trak.mdia.minf.stbl.stss;\n\t\tvar k = trak.mdia.minf.stbl.boxes.indexOf(stss);\n\t\tif (k != -1) trak.mdia.minf.stbl.boxes[k] = null;\n\t}\n};\n\nISOFile.initSampleGroups = function(trak, traf, sbgps, trak_sgpds, traf_sgpds) {\n\tvar l;\n\tvar k;\n\tvar sample_group_info;\n\tvar sample_group_key;\n\tfunction SampleGroupInfo(_type, _parameter, _sbgp) {\n\t\tthis.grouping_type = _type;\n\t\tthis.grouping_type_parameter = _parameter;\n\t\tthis.sbgp = _sbgp;\n\t\tthis.last_sample_in_run = -1;\n\t\tthis.entry_index = -1;\t\t\n\t}\n\tif (traf) {\n\t\ttraf.sample_groups_info = [];\n\t} \n\tif (!trak.sample_groups_info) {\n\t\ttrak.sample_groups_info = [];\n\t}\n\tfor (k = 0; k < sbgps.length; k++) {\n\t\tsample_group_key = sbgps[k].grouping_type +\"/\"+ sbgps[k].grouping_type_parameter;\n\t\tsample_group_info = new SampleGroupInfo(sbgps[k].grouping_type, sbgps[k].grouping_type_parameter, sbgps[k]);\n\t\tif (traf) {\n\t\t\ttraf.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t}\n\t\tif (!trak.sample_groups_info[sample_group_key]) {\n\t\t\ttrak.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t}\n\t\tfor (l=0; l <trak_sgpds.length; l++) {\n\t\t\tif (trak_sgpds[l].grouping_type === sbgps[k].grouping_type) {\n\t\t\t\tsample_group_info.description = trak_sgpds[l];\n\t\t\t\tsample_group_info.description.used = true;\n\t\t\t}\n\t\t}\n\t\tif (traf_sgpds) {\n\t\t\tfor (l=0; l <traf_sgpds.length; l++) {\n\t\t\t\tif (traf_sgpds[l].grouping_type === sbgps[k].grouping_type) {\n\t\t\t\t\tsample_group_info.fragment_description = traf_sgpds[l];\n\t\t\t\t\tsample_group_info.fragment_description.used = true;\n\t\t\t\t\tsample_group_info.is_fragment = true;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tif (!traf) {\n\t\tfor (k = 0; k < trak_sgpds.length; k++) {\n\t\t\tif (!trak_sgpds[k].used && trak_sgpds[k].version >= 2) {\n\t\t\t\tsample_group_key = trak_sgpds[k].grouping_type +\"/0\";\n\t\t\t\tsample_group_info = new SampleGroupInfo(trak_sgpds[k].grouping_type, 0);\n\t\t\t\tif (!trak.sample_groups_info[sample_group_key]) {\n\t\t\t\t\ttrak.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (traf_sgpds) {\n\t\t\tfor (k = 0; k < traf_sgpds.length; k++) {\n\t\t\t\tif (!traf_sgpds[k].used && traf_sgpds[k].version >= 2) {\n\t\t\t\t\tsample_group_key = traf_sgpds[k].grouping_type +\"/0\";\n\t\t\t\t\tsample_group_info = new SampleGroupInfo(traf_sgpds[k].grouping_type, 0);\n\t\t\t\t\tsample_group_info.is_fragment = true;\n\t\t\t\t\tif (!traf.sample_groups_info[sample_group_key]) {\n\t\t\t\t\t\ttraf.sample_groups_info[sample_group_key] = sample_group_info;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nISOFile.setSampleGroupProperties = function(trak, sample, sample_number, sample_groups_info) {\n\tvar k;\n\tvar index;\n\tsample.sample_groups = [];\n\tfor (k in sample_groups_info) {\n\t\tsample.sample_groups[k] = {};\n\t\tsample.sample_groups[k].grouping_type = sample_groups_info[k].grouping_type;\n\t\tsample.sample_groups[k].grouping_type_parameter = sample_groups_info[k].grouping_type_parameter;\n\t\tif (sample_number >= sample_groups_info[k].last_sample_in_run) {\n\t\t\tif (sample_groups_info[k].last_sample_in_run < 0) {\n\t\t\t\tsample_groups_info[k].last_sample_in_run = 0;\n\t\t\t}\n\t\t\tsample_groups_info[k].entry_index++;\t\n\t\t\tif (sample_groups_info[k].entry_index <= sample_groups_info[k].sbgp.entries.length - 1) {\n\t\t\t\tsample_groups_info[k].last_sample_in_run += sample_groups_info[k].sbgp.entries[sample_groups_info[k].entry_index].sample_count;\n\t\t\t}\n\t\t}\n\t\tif (sample_groups_info[k].entry_index <= sample_groups_info[k].sbgp.entries.length - 1) {\n\t\t\tsample.sample_groups[k].group_description_index = sample_groups_info[k].sbgp.entries[sample_groups_info[k].entry_index].group_description_index;\n\t\t} else {\n\t\t\tsample.sample_groups[k].group_description_index = -1; // special value for not defined\n\t\t}\n\t\tif (sample.sample_groups[k].group_description_index !== 0) {\n\t\t\tvar description;\n\t\t\tif (sample_groups_info[k].fragment_description) {\n\t\t\t\tdescription = sample_groups_info[k].fragment_description;\n\t\t\t} else {\n\t\t\t\tdescription = sample_groups_info[k].description;\n\t\t\t}\n\t\t\tif (sample.sample_groups[k].group_description_index > 0) {\n\t\t\t\tif (sample.sample_groups[k].group_description_index > 65535) {\n\t\t\t\t\tindex = (sample.sample_groups[k].group_description_index >> 16)-1;\n\t\t\t\t} else {\n\t\t\t\t\tindex = sample.sample_groups[k].group_description_index-1;\n\t\t\t\t}\n\t\t\t\tif (description && index >= 0) {\n\t\t\t\t\tsample.sample_groups[k].description = description.entries[index];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (description && description.version >= 2) {\n\t\t\t\t\tif (description.default_group_description_index > 0) {\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tsample.sample_groups[k].description = description.entries[description.default_group_description_index-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nISOFile.process_sdtp = function (sdtp, sample, number) {\n\tif (!sample) {\n\t\treturn;\n\t}\n\tif (sdtp) {\n\t\tsample.is_leading = sdtp.is_leading[number];\n\t\tsample.depends_on = sdtp.sample_depends_on[number];\n\t\tsample.is_depended_on = sdtp.sample_is_depended_on[number];\n\t\tsample.has_redundancy = sdtp.sample_has_redundancy[number];\n\t} else {\n\t\tsample.is_leading = 0;\n\t\tsample.depends_on = 0;\n\t\tsample.is_depended_on = 0;\n\t\tsample.has_redundancy = 0;\n\t}\t\n};\n\n/* Build initial sample list from  sample tables */\nISOFile.prototype.buildSampleLists = function() {\t\n\tvar i;\n\tvar trak;\n\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\ttrak = this.moov.traks[i];\n\t\tthis.buildTrakSampleLists(trak);\n\t}\n};\n\nISOFile.prototype.buildTrakSampleLists = function(trak) {\t\n\tvar j;\n\tvar stco, stsc, stsz, stts, ctts, stss, stsd, subs, sbgps, sgpds, stdp;\n\tvar chunk_run_index, chunk_index, last_chunk_in_run, offset_in_chunk, last_sample_in_chunk;\n\tvar last_sample_in_stts_run, stts_run_index, last_sample_in_ctts_run, ctts_run_index, last_stss_index, subs_entry_index, last_subs_sample_index;\n\n\ttrak.samples = [];\n\ttrak.samples_duration = 0;\n\ttrak.samples_size = 0;\n\tstco = trak.mdia.minf.stbl.stco || trak.mdia.minf.stbl.co64;\n\tstsc = trak.mdia.minf.stbl.stsc;\n\tstsz = trak.mdia.minf.stbl.stsz || trak.mdia.minf.stbl.stz2;\n\tstts = trak.mdia.minf.stbl.stts;\n\tctts = trak.mdia.minf.stbl.ctts;\n\tstss = trak.mdia.minf.stbl.stss;\n\tstsd = trak.mdia.minf.stbl.stsd;\n\tsubs = trak.mdia.minf.stbl.subs;\n\tstdp = trak.mdia.minf.stbl.stdp;\n\tsbgps = trak.mdia.minf.stbl.sbgps;\n\tsgpds = trak.mdia.minf.stbl.sgpds;\n\t\n\tlast_sample_in_stts_run = -1;\n\tstts_run_index = -1;\n\tlast_sample_in_ctts_run = -1;\n\tctts_run_index = -1;\n\tlast_stss_index = 0;\n\tsubs_entry_index = 0;\n\tlast_subs_sample_index = 0;\t\t\n\n\tISOFile.initSampleGroups(trak, null, sbgps, sgpds);\n\n\tif (typeof stsz === \"undefined\") {\n\t\treturn;\n\t}\n\n\t/* we build the samples one by one and compute their properties */\n\tfor (j = 0; j < stsz.sample_sizes.length; j++) {\n\t\tvar sample = {};\n\t\tsample.number = j;\n\t\tsample.track_id = trak.tkhd.track_id;\n\t\tsample.timescale = trak.mdia.mdhd.timescale;\n\t\tsample.alreadyRead = 0;\n\t\ttrak.samples[j] = sample;\n\t\t/* size can be known directly */\n\t\tsample.size = stsz.sample_sizes[j];\n\t\ttrak.samples_size += sample.size;\n\t\t/* computing chunk-based properties (offset, sample description index)*/\n\t\tif (j === 0) {\t\t\t\t\n\t\t\tchunk_index = 1; /* the first sample is in the first chunk (chunk indexes are 1-based) */\n\t\t\tchunk_run_index = 0; /* the first chunk is the first entry in the first_chunk table */\n\t\t\tsample.chunk_index = chunk_index;\n\t\t\tsample.chunk_run_index = chunk_run_index;\n\t\t\tlast_sample_in_chunk = stsc.samples_per_chunk[chunk_run_index];\n\t\t\toffset_in_chunk = 0;\n\n\t\t\t/* Is there another entry in the first_chunk table ? */\n\t\t\tif (chunk_run_index + 1 < stsc.first_chunk.length) {\n\t\t\t\t/* The last chunk in the run is the chunk before the next first chunk */\n\t\t\t\tlast_chunk_in_run = stsc.first_chunk[chunk_run_index+1]-1; \t\n\t\t\t} else {\n\t\t\t\t/* There is only one entry in the table, it is valid for all future chunks*/\n\t\t\t\tlast_chunk_in_run = Infinity;\n\t\t\t}\n\t\t} else {\n\t\t\tif (j < last_sample_in_chunk) {\n\t\t\t\t/* the sample is still in the current chunk */\n\t\t\t\tsample.chunk_index = chunk_index;\n\t\t\t\tsample.chunk_run_index = chunk_run_index;\n\t\t\t} else {\n\t\t\t\t/* the sample is in the next chunk */\n\t\t\t\tchunk_index++;\n\t\t\t\tsample.chunk_index = chunk_index;\n\t\t\t\t/* reset the accumulated offset in the chunk */\n\t\t\t\toffset_in_chunk = 0;\n\t\t\t\tif (chunk_index <= last_chunk_in_run) ; else {\n\t\t\t\t\tchunk_run_index++;\n\t\t\t\t\t/* Is there another entry in the first_chunk table ? */\n\t\t\t\t\tif (chunk_run_index + 1 < stsc.first_chunk.length) {\n\t\t\t\t\t\t/* The last chunk in the run is the chunk before the next first chunk */\n\t\t\t\t\t\tlast_chunk_in_run = stsc.first_chunk[chunk_run_index+1]-1; \t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* There is only one entry in the table, it is valid for all future chunks*/\n\t\t\t\t\t\tlast_chunk_in_run = Infinity;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tsample.chunk_run_index = chunk_run_index;\n\t\t\t\tlast_sample_in_chunk += stsc.samples_per_chunk[chunk_run_index];\n\t\t\t}\n\t\t}\n\n\t\tsample.description_index = stsc.sample_description_index[sample.chunk_run_index]-1;\n\t\tsample.description = stsd.entries[sample.description_index];\n\t\tsample.offset = stco.chunk_offsets[sample.chunk_index-1] + offset_in_chunk; /* chunk indexes are 1-based */\n\t\toffset_in_chunk += sample.size;\n\n\t\t/* setting dts, cts, duration and rap flags */\n\t\tif (j > last_sample_in_stts_run) {\n\t\t\tstts_run_index++;\n\t\t\tif (last_sample_in_stts_run < 0) {\n\t\t\t\tlast_sample_in_stts_run = 0;\n\t\t\t}\n\t\t\tlast_sample_in_stts_run += stts.sample_counts[stts_run_index];\t\t\t\t\n\t\t}\n\t\tif (j > 0) {\n\t\t\ttrak.samples[j-1].duration = stts.sample_deltas[stts_run_index];\n\t\t\ttrak.samples_duration += trak.samples[j-1].duration;\n\t\t\tsample.dts = trak.samples[j-1].dts + trak.samples[j-1].duration;\n\t\t} else {\n\t\t\tsample.dts = 0;\n\t\t}\n\t\tif (ctts) {\n\t\t\tif (j >= last_sample_in_ctts_run) {\n\t\t\t\tctts_run_index++;\n\t\t\t\tif (last_sample_in_ctts_run < 0) {\n\t\t\t\t\tlast_sample_in_ctts_run = 0;\n\t\t\t\t}\n\t\t\t\tlast_sample_in_ctts_run += ctts.sample_counts[ctts_run_index];\t\t\t\t\n\t\t\t}\n\t\t\tsample.cts = trak.samples[j].dts + ctts.sample_offsets[ctts_run_index];\n\t\t} else {\n\t\t\tsample.cts = sample.dts;\n\t\t}\n\t\tif (stss) {\n\t\t\tif (j == stss.sample_numbers[last_stss_index] - 1) { // sample numbers are 1-based\n\t\t\t\tsample.is_sync = true;\n\t\t\t\tlast_stss_index++;\n\t\t\t} else {\n\t\t\t\tsample.is_sync = false;\t\t\t\t\n\t\t\t\tsample.degradation_priority = 0;\n\t\t\t}\n\t\t\tif (subs) {\n\t\t\t\tif (subs.entries[subs_entry_index].sample_delta + last_subs_sample_index == j+1) {\n\t\t\t\t\tsample.subsamples = subs.entries[subs_entry_index].subsamples;\n\t\t\t\t\tlast_subs_sample_index += subs.entries[subs_entry_index].sample_delta;\n\t\t\t\t\tsubs_entry_index++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsample.is_sync = true;\n\t\t}\n\t\tISOFile.process_sdtp(trak.mdia.minf.stbl.sdtp, sample, sample.number);\n\t\tif (stdp) {\n\t\t\tsample.degradation_priority = stdp.priority[j];\n\t\t} else {\n\t\t\tsample.degradation_priority = 0;\n\t\t}\n\t\tif (subs) {\n\t\t\tif (subs.entries[subs_entry_index].sample_delta + last_subs_sample_index == j) {\n\t\t\t\tsample.subsamples = subs.entries[subs_entry_index].subsamples;\n\t\t\t\tlast_subs_sample_index += subs.entries[subs_entry_index].sample_delta;\n\t\t\t}\n\t\t}\n\t\tif (sbgps.length > 0 || sgpds.length > 0) {\n\t\t\tISOFile.setSampleGroupProperties(trak, sample, j, trak.sample_groups_info);\n\t\t}\n\t}\n\tif (j>0) {\n\t\ttrak.samples[j-1].duration = Math.max(trak.mdia.mdhd.duration - trak.samples[j-1].dts, 0);\n\t\ttrak.samples_duration += trak.samples[j-1].duration;\n\t}\n};\n\n/* Update sample list when new 'moof' boxes are received */\nISOFile.prototype.updateSampleLists = function() {\t\n\tvar i, j, k;\n\tvar default_sample_description_index, default_sample_duration, default_sample_size, default_sample_flags;\n\tvar last_run_position;\n\tvar box, moof, traf, trak, trex;\n\tvar sample;\n\tvar sample_flags;\n\t\n\tif (this.moov === undefined) {\n\t\treturn;\n\t}\n\t/* if the input file is fragmented and fetched in multiple downloads, we need to update the list of samples */\n\twhile (this.lastMoofIndex < this.moofs.length) {\n\t\tbox = this.moofs[this.lastMoofIndex];\n\t\tthis.lastMoofIndex++;\n\t\tif (box.type == \"moof\") {\n\t\t\tmoof = box;\n\t\t\tfor (i = 0; i < moof.trafs.length; i++) {\n\t\t\t\ttraf = moof.trafs[i];\n\t\t\t\ttrak = this.getTrackById(traf.tfhd.track_id);\n\t\t\t\ttrex = this.getTrexById(traf.tfhd.track_id);\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC) {\n\t\t\t\t\tdefault_sample_description_index = traf.tfhd.default_sample_description_index;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_description_index = (trex ? trex.default_sample_description_index: 1);\n\t\t\t\t}\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR) {\n\t\t\t\t\tdefault_sample_duration = traf.tfhd.default_sample_duration;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_duration = (trex ? trex.default_sample_duration : 0);\n\t\t\t\t}\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE) {\n\t\t\t\t\tdefault_sample_size = traf.tfhd.default_sample_size;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_size = (trex ? trex.default_sample_size : 0);\n\t\t\t\t}\n\t\t\t\tif (traf.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS) {\n\t\t\t\t\tdefault_sample_flags = traf.tfhd.default_sample_flags;\n\t\t\t\t} else {\n\t\t\t\t\tdefault_sample_flags = (trex ? trex.default_sample_flags : 0);\n\t\t\t\t}\n\t\t\t\ttraf.sample_number = 0;\n\t\t\t\t/* process sample groups */\n\t\t\t\tif (traf.sbgps.length > 0) {\n\t\t\t\t\tISOFile.initSampleGroups(trak, traf, traf.sbgps, trak.mdia.minf.stbl.sgpds, traf.sgpds);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < traf.truns.length; j++) {\n\t\t\t\t\tvar trun = traf.truns[j];\n\t\t\t\t\tfor (k = 0; k < trun.sample_count; k++) {\n\t\t\t\t\t\tsample = {};\n\t\t\t\t\t\tsample.moof_number = this.lastMoofIndex;\n\t\t\t\t\t\tsample.number_in_traf = traf.sample_number;\n\t\t\t\t\t\ttraf.sample_number++;\n\t\t\t            sample.number = trak.samples.length;\n\t\t\t\t\t\ttraf.first_sample_index = trak.samples.length;\n\t\t\t\t\t\ttrak.samples.push(sample);\n\t\t\t\t\t\tsample.track_id = trak.tkhd.track_id;\n\t\t\t\t\t\tsample.timescale = trak.mdia.mdhd.timescale;\n\t\t\t\t\t\tsample.description_index = default_sample_description_index-1;\n\t\t\t\t\t\tsample.description = trak.mdia.minf.stbl.stsd.entries[sample.description_index];\n\t\t\t\t\t\tsample.size = default_sample_size;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_SIZE) {\n\t\t\t\t\t\t\tsample.size = trun.sample_size[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrak.samples_size += sample.size;\n\t\t\t\t\t\tsample.duration = default_sample_duration;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_DURATION) {\n\t\t\t\t\t\t\tsample.duration = trun.sample_duration[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrak.samples_duration += sample.duration;\n\t\t\t\t\t\tif (trak.first_traf_merged || k > 0) {\n\t\t\t\t\t\t\tsample.dts = trak.samples[trak.samples.length-2].dts+trak.samples[trak.samples.length-2].duration;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (traf.tfdt) {\n\t\t\t\t\t\t\t\tsample.dts = traf.tfdt.baseMediaDecodeTime;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsample.dts = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttrak.first_traf_merged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsample.cts = sample.dts;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET) {\n\t\t\t\t\t\t\tsample.cts = sample.dts + trun.sample_composition_time_offset[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsample_flags = default_sample_flags;\n\t\t\t\t\t\tif (trun.flags & BoxParser.TRUN_FLAGS_FLAGS) {\n\t\t\t\t\t\t\tsample_flags = trun.sample_flags[k];\n\t\t\t\t\t\t} else if (k === 0 && (trun.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG)) {\n\t\t\t\t\t\t\tsample_flags = trun.first_sample_flags;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsample.is_sync = ((sample_flags >> 16 & 0x1) ? false : true);\n\t\t\t\t\t\tsample.is_leading = (sample_flags >> 26 & 0x3);\n\t\t\t\t\t\tsample.depends_on = (sample_flags >> 24 & 0x3);\n\t\t\t\t\t\tsample.is_depended_on = (sample_flags >> 22 & 0x3);\n\t\t\t\t\t\tsample.has_redundancy = (sample_flags >> 20 & 0x3);\n\t\t\t\t\t\tsample.degradation_priority = (sample_flags & 0xFFFF);\n\t\t\t\t\t\t//ISOFile.process_sdtp(traf.sdtp, sample, sample.number_in_traf);\n\t\t\t\t\t\tvar bdop = (traf.tfhd.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET) ? true : false;\n\t\t\t\t\t\tvar dbim = (traf.tfhd.flags & BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF) ? true : false;\n\t\t\t\t\t\tvar dop = (trun.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET) ? true : false;\n\t\t\t\t\t\tvar bdo = 0;\n\t\t\t\t\t\tif (!bdop) {\n\t\t\t\t\t\t\tif (!dbim) {\n\t\t\t\t\t\t\t\tif (j === 0) { // the first track in the movie fragment\n\t\t\t\t\t\t\t\t\tbdo = moof.start; // the position of the first byte of the enclosing Movie Fragment Box\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbdo = last_run_position; // end of the data defined by the preceding *track* (irrespective of the track id) fragment in the moof\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbdo = moof.start;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbdo = traf.tfhd.base_data_offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === 0 && k === 0) {\n\t\t\t\t\t\t\tif (dop) {\n\t\t\t\t\t\t\t\tsample.offset = bdo + trun.data_offset; // If the data-offset is present, it is relative to the base-data-offset established in the track fragment header\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsample.offset = bdo; // the data for this run starts the base-data-offset defined by the track fragment header\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsample.offset = last_run_position; // this run starts immediately after the data of the previous run\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast_run_position = sample.offset + sample.size;\n\t\t\t\t\t\tif (traf.sbgps.length > 0 || traf.sgpds.length > 0 ||\n\t\t\t\t\t\t\ttrak.mdia.minf.stbl.sbgps.length > 0 || trak.mdia.minf.stbl.sgpds.length > 0) {\n\t\t\t\t\t\t\tISOFile.setSampleGroupProperties(trak, sample, sample.number_in_traf, traf.sample_groups_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (traf.subs) {\n\t\t\t\t\ttrak.has_fragment_subsamples = true;\n\t\t\t\t\tvar sample_index = traf.first_sample_index;\n\t\t\t\t\tfor (j = 0; j < traf.subs.entries.length; j++) {\n\t\t\t\t\t\tsample_index += traf.subs.entries[j].sample_delta;\n\t\t\t\t\t\tsample = trak.samples[sample_index-1];\n\t\t\t\t\t\tsample.subsamples = traf.subs.entries[j].subsamples;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n};\n\n/* Try to get sample data for a given sample:\n   returns null if not found\n   returns the same sample if already requested\n */\nISOFile.prototype.getSample = function(trak, sampleNum) {\t\n\tvar buffer;\n\tvar sample = trak.samples[sampleNum];\n\t\n\tif (!this.moov) {\n\t\treturn null;\n\t}\n\n\tif (!sample.data) {\n\t\t/* Not yet fetched */\n\t\tsample.data = new Uint8Array(sample.size);\n\t\tsample.alreadyRead = 0;\n\t\tthis.samplesDataSize += sample.size;\n\t\tLog.debug(\"ISOFile\", \"Allocating sample #\"+sampleNum+\" on track #\"+trak.tkhd.track_id+\" of size \"+sample.size+\" (total: \"+this.samplesDataSize+\")\");\n\t} else if (sample.alreadyRead == sample.size) {\n\t\t/* Already fetched entirely */\n\t\treturn sample;\n\t}\n\n\t/* The sample has only been partially fetched, we need to check in all buffers */\n\twhile(true) {\n\t\tvar index =\tthis.stream.findPosition(true, sample.offset + sample.alreadyRead, false);\n\t\tif (index > -1) {\n\t\t\tbuffer = this.stream.buffers[index];\n\t\t\tvar lengthAfterStart = buffer.byteLength - (sample.offset + sample.alreadyRead - buffer.fileStart);\n\t\t\tif (sample.size - sample.alreadyRead <= lengthAfterStart) {\n\t\t\t\t/* the (rest of the) sample is entirely contained in this buffer */\n\n\t\t\t\tLog.debug(\"ISOFile\",\"Getting sample #\"+sampleNum+\" data (alreadyRead: \"+sample.alreadyRead+\" offset: \"+\n\t\t\t\t\t(sample.offset+sample.alreadyRead - buffer.fileStart)+\" read size: \"+(sample.size - sample.alreadyRead)+\" full size: \"+sample.size+\")\");\n\n\t\t\t\tDataStream.memcpy(sample.data.buffer, sample.alreadyRead,\n\t\t\t\t                  buffer, sample.offset+sample.alreadyRead - buffer.fileStart, sample.size - sample.alreadyRead);\n\n\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\tbuffer.usedBytes += sample.size - sample.alreadyRead;\n\t\t\t\tthis.stream.logBufferLevel();\n\n\t\t\t\tsample.alreadyRead = sample.size;\n\n\t\t\t\treturn sample;\n\t\t\t} else {\n\t\t\t\t/* the sample does not end in this buffer */\n\n\t\t\t\tif (lengthAfterStart === 0) return null;\n\n\t\t\t\tLog.debug(\"ISOFile\",\"Getting sample #\"+sampleNum+\" partial data (alreadyRead: \"+sample.alreadyRead+\" offset: \"+\n\t\t\t\t\t(sample.offset+sample.alreadyRead - buffer.fileStart)+\" read size: \"+lengthAfterStart+\" full size: \"+sample.size+\")\");\n\n\t\t\t\tDataStream.memcpy(sample.data.buffer, sample.alreadyRead,\n\t\t\t\t                  buffer, sample.offset+sample.alreadyRead - buffer.fileStart, lengthAfterStart);\n\t\t\t\tsample.alreadyRead += lengthAfterStart;\n\n\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\tbuffer.usedBytes += lengthAfterStart;\n\t\t\t\tthis.stream.logBufferLevel();\n\n\t\t\t\t/* keep looking in the next buffer */\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n};\n\n/* Release the memory used to store the data of the sample */\nISOFile.prototype.releaseSample = function(trak, sampleNum) {\t\n\tvar sample = trak.samples[sampleNum];\n\tif (sample.data) {\n\t\tthis.samplesDataSize -= sample.size;\n\t\tsample.data = null;\n\t\tsample.alreadyRead = 0;\n\t\treturn sample.size;\n\t} else {\n\t\treturn 0;\n\t}\n};\n\nISOFile.prototype.getAllocatedSampleDataSize = function() {\n\treturn this.samplesDataSize;\n};\n\n/* Builds the MIME Type 'codecs' sub-parameters for the whole file */\nISOFile.prototype.getCodecs = function() {\t\n\tvar i;\n\tvar codecs = \"\";\n\tfor (i = 0; i < this.moov.traks.length; i++) {\n\t\tvar trak = this.moov.traks[i];\n\t\tif (i>0) {\n\t\t\tcodecs+=\",\"; \n\t\t}\n\t\tcodecs += trak.mdia.minf.stbl.stsd.entries[0].getCodec();\t\t\n\t}\n\treturn codecs;\n};\n\n/* Helper function */\nISOFile.prototype.getTrexById = function(id) {\t\n\tvar i;\n\tif (!this.moov || !this.moov.mvex) return null;\n\tfor (i = 0; i < this.moov.mvex.trexs.length; i++) {\n\t\tvar trex = this.moov.mvex.trexs[i];\n\t\tif (trex.track_id == id) return trex;\n\t}\n\treturn null;\n};\n\n/* Helper function */\nISOFile.prototype.getTrackById = function(id) {\n\tif (this.moov === undefined) {\n\t\treturn null;\n\t}\n\tfor (var j = 0; j < this.moov.traks.length; j++) {\n\t\tvar trak = this.moov.traks[j];\n\t\tif (trak.tkhd.track_id == id) return trak;\n\t}\n\treturn null;\n};\n// file:src/isofile-item-processing.js\nISOFile.prototype.items = [];\n/* size of the buffers allocated for samples */\nISOFile.prototype.itemsDataSize = 0;\n\nISOFile.prototype.flattenItemInfo = function() {\t\n\tvar items = this.items;\n\tvar i, j;\n\tvar item;\n\tvar meta = this.meta;\n\tif (meta === null || meta === undefined) return;\n\tif (meta.hdlr === undefined) return;\n\tif (meta.iinf === undefined) return;\n\tfor (i = 0; i < meta.iinf.item_infos.length; i++) {\n\t\titem = {};\n\t\titem.id = meta.iinf.item_infos[i].item_ID;\n\t\titems[item.id] = item;\n\t\titem.ref_to = [];\n\t\titem.name = meta.iinf.item_infos[i].item_name;\n\t\tif (meta.iinf.item_infos[i].protection_index > 0) {\n\t\t\titem.protection = meta.ipro.protections[meta.iinf.item_infos[i].protection_index-1];\n\t\t}\n\t\tif (meta.iinf.item_infos[i].item_type) {\n\t\t\titem.type = meta.iinf.item_infos[i].item_type;\n\t\t} else {\n\t\t\titem.type = \"mime\";\n\t\t}\n\t\titem.content_type = meta.iinf.item_infos[i].content_type;\n\t\titem.content_encoding = meta.iinf.item_infos[i].content_encoding;\n\t}\n\tif (meta.iloc) {\n\t\tfor(i = 0; i < meta.iloc.items.length; i++) {\n\t\t\tvar itemloc = meta.iloc.items[i];\n\t\t\titem = items[itemloc.item_ID];\n\t\t\tif (itemloc.data_reference_index !== 0) {\n\t\t\t\tLog.warn(\"Item storage with reference to other files: not supported\");\n\t\t\t\titem.source = meta.dinf.boxes[itemloc.data_reference_index-1];\n\t\t\t}\n\t\t\tswitch(itemloc.construction_method) {\n\t\t\t\tcase 0: // offset into the file referenced by the data reference index\n\t\t\t\tbreak;\n\t\t\t\tcase 1: // offset into the idat box of this meta box\n\t\t\t\tLog.warn(\"Item storage with construction_method : not supported\");\n\t\t\t\tbreak;\n\t\t\t\tcase 2: // offset into another item\n\t\t\t\tLog.warn(\"Item storage with construction_method : not supported\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem.extents = [];\n\t\t\titem.size = 0;\n\t\t\tfor (j = 0; j < itemloc.extents.length; j++) {\n\t\t\t\titem.extents[j] = {};\n\t\t\t\titem.extents[j].offset = itemloc.extents[j].extent_offset + itemloc.base_offset;\n\t\t\t\titem.extents[j].length = itemloc.extents[j].extent_length;\n\t\t\t\titem.extents[j].alreadyRead = 0;\n\t\t\t\titem.size += item.extents[j].length;\n\t\t\t}\n\t\t}\n\t}\n\tif (meta.pitm) {\n\t\titems[meta.pitm.item_id].primary = true;\n\t}\n\tif (meta.iref) {\n\t\tfor (i=0; i <meta.iref.references.length; i++) {\n\t\t\tvar ref = meta.iref.references[i];\n\t\t\tfor (j=0; j<ref.references.length; j++) {\n\t\t\t\titems[ref.from_item_ID].ref_to.push({type: ref.type, id: ref.references[j]});\n\t\t\t}\n\t\t}\n\t}\n\tif (meta.iprp) {\n\t\tfor (var k = 0; k < meta.iprp.ipmas.length; k++) {\n\t\t\tvar ipma = meta.iprp.ipmas[k];\n\t\t\tfor (i = 0; i < ipma.associations.length; i++) {\n\t\t\t\tvar association = ipma.associations[i];\n\t\t\t\titem = items[association.id];\n\t\t\t\tif (item.properties === undefined) {\n\t\t\t\t\titem.properties = {};\n\t\t\t\t\titem.properties.boxes = [];\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < association.props.length; j++) {\n\t\t\t\t\tvar propEntry = association.props[j];\n\t\t\t\t\tif (propEntry.property_index > 0 && propEntry.property_index-1 < meta.iprp.ipco.boxes.length) {\n\t\t\t\t\t\tvar propbox = meta.iprp.ipco.boxes[propEntry.property_index-1];\n\t\t\t\t\t\titem.properties[propbox.type] = propbox;\n\t\t\t\t\t\titem.properties.boxes.push(propbox);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nISOFile.prototype.getItem = function(item_id) {\t\n\tvar buffer;\n\tvar item;\n\t\n\tif (!this.meta) {\n\t\treturn null;\n\t}\n\n \titem = this.items[item_id];\n\tif (!item.data && item.size) {\n\t\t/* Not yet fetched */\n\t\titem.data = new Uint8Array(item.size);\n\t\titem.alreadyRead = 0;\n\t\tthis.itemsDataSize += item.size;\n\t\tLog.debug(\"ISOFile\", \"Allocating item #\"+item_id+\" of size \"+item.size+\" (total: \"+this.itemsDataSize+\")\");\n\t} else if (item.alreadyRead === item.size) {\n\t\t/* Already fetched entirely */\n\t\treturn item;\n\t}\n\n\t/* The item has only been partially fetched, we need to check in all buffers to find the remaining extents*/\n\n\tfor (var i = 0; i < item.extents.length; i++) {\n\t\tvar extent = item.extents[i];\n\t\tif (extent.alreadyRead === extent.length) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tvar index =\tthis.stream.findPosition(true, extent.offset + extent.alreadyRead, false);\n\t\t\tif (index > -1) {\n\t\t\t\tbuffer = this.stream.buffers[index];\n\t\t\t\tvar lengthAfterStart = buffer.byteLength - (extent.offset + extent.alreadyRead - buffer.fileStart);\n\t\t\t\tif (extent.length - extent.alreadyRead <= lengthAfterStart) {\n\t\t\t\t\t/* the (rest of the) extent is entirely contained in this buffer */\n\n\t\t\t\t\tLog.debug(\"ISOFile\",\"Getting item #\"+item_id+\" extent #\"+i+\" data (alreadyRead: \"+extent.alreadyRead+\n\t\t\t\t\t\t\" offset: \"+(extent.offset+extent.alreadyRead - buffer.fileStart)+\" read size: \"+(extent.length - extent.alreadyRead)+\n\t\t\t\t\t\t\" full extent size: \"+extent.length+\" full item size: \"+item.size+\")\");\n\n\t\t\t\t\tDataStream.memcpy(item.data.buffer, item.alreadyRead, \n\t\t\t\t\t                  buffer, extent.offset+extent.alreadyRead - buffer.fileStart, extent.length - extent.alreadyRead);\n\n\t\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\t\tbuffer.usedBytes += extent.length - extent.alreadyRead;\n\t\t\t\t\tthis.stream.logBufferLevel();\n\n\t\t\t\t\titem.alreadyRead += (extent.length - extent.alreadyRead);\n\t\t\t\t\textent.alreadyRead = extent.length;\n\t\t\t\t} else {\n\t\t\t\t\t/* the sample does not end in this buffer */\n\n\t\t\t\t\tLog.debug(\"ISOFile\",\"Getting item #\"+item_id+\" extent #\"+i+\" partial data (alreadyRead: \"+extent.alreadyRead+\" offset: \"+\n\t\t\t\t\t\t(extent.offset+extent.alreadyRead - buffer.fileStart)+\" read size: \"+lengthAfterStart+\n\t\t\t\t\t\t\" full extent size: \"+extent.length+\" full item size: \"+item.size+\")\");\n\n\t\t\t\t\tDataStream.memcpy(item.data.buffer, item.alreadyRead, \n\t\t\t\t\t                  buffer, extent.offset+extent.alreadyRead - buffer.fileStart, lengthAfterStart);\n\t\t\t\t\textent.alreadyRead += lengthAfterStart;\n\t\t\t\t\titem.alreadyRead += lengthAfterStart;\n\n\t\t\t\t\t/* update the number of bytes used in this buffer and check if it needs to be removed */\n\t\t\t\t\tbuffer.usedBytes += lengthAfterStart;\n\t\t\t\t\tthis.stream.logBufferLevel();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tif (item.alreadyRead === item.size) {\n\t\t/* fetched entirely */\n\t\treturn item;\n\t} else {\n\t\treturn null;\n\t}\n};\n\n/* Release the memory used to store the data of the item */\nISOFile.prototype.releaseItem = function(item_id) {\t\n\tvar item = this.items[item_id];\n\tif (item.data) {\n\t\tthis.itemsDataSize -= item.size;\n\t\titem.data = null;\n\t\titem.alreadyRead = 0;\n\t\tfor (var i = 0; i < item.extents.length; i++) {\n\t\t\tvar extent = item.extents[i];\n\t\t\textent.alreadyRead = 0;\n\t\t}\n\t\treturn item.size;\n\t} else {\n\t\treturn 0;\n\t}\n};\n\n\nISOFile.prototype.processItems = function(callback) {\n\tfor(var i in this.items) {\n\t\tvar item = this.items[i];\n\t\tthis.getItem(item.id);\n\t\tif (callback && !item.sent) {\n\t\t\tcallback(item);\n\t\t\titem.sent = true;\n\t\t\titem.data = null;\n\t\t}\n\t}\n};\n\nISOFile.prototype.hasItem = function(name) {\n\tfor(var i in this.items) {\n\t\tvar item = this.items[i];\n\t\tif (item.name === name) {\n\t\t\treturn item.id;\n\t\t}\n\t}\n\treturn -1;\n};\n\nISOFile.prototype.getMetaHandler = function() {\n\tif (!this.meta) {\n\t\treturn null;\n\t} else {\n\t\treturn this.meta.hdlr.handler;\t\t\n\t}\n};\n\nISOFile.prototype.getPrimaryItem = function() {\n\tif (!this.meta || !this.meta.pitm) {\n\t\treturn null;\n\t} else {\n\t\treturn this.getItem(this.meta.pitm.item_id);\n\t}\n};\n\nISOFile.prototype.itemToFragmentedTrackFile = function(_options) {\n\tvar options = _options || {};\n\tvar item = null;\n\tif (options.itemId) {\n\t\titem = this.getItem(options.itemId);\n\t} else {\n\t\titem = this.getPrimaryItem();\n\t}\n\tif (item == null) return null;\n\n\tvar file = new ISOFile();\n\tfile.discardMdatData = false;\n\t// assuming the track type is the same as the item type\n\tvar trackOptions = { type: item.type, description_boxes: item.properties.boxes};\n\tif (item.properties.ispe) {\n\t\ttrackOptions.width = item.properties.ispe.image_width;\n\t\ttrackOptions.height = item.properties.ispe.image_height;\n\t}\n\tvar trackId = file.addTrack(trackOptions);\n\tif (trackId) {\n\t\tfile.addSample(trackId, item.data);\n\t\treturn file;\n\t} else {\n\t\treturn null;\n\t}\n};\n\n// file:src/isofile-write.js\n/* Rewrite the entire file */\nISOFile.prototype.write = function(outstream) {\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tthis.boxes[i].write(outstream);\n\t}\n};\n\nISOFile.prototype.createFragment = function(track_id, sampleNumber, stream_) {\n\tvar trak = this.getTrackById(track_id);\n\tvar sample = this.getSample(trak, sampleNumber);\n\tif (sample == null) {\n\t\tsample = trak.samples[sampleNumber];\n\t\tif (this.nextSeekPosition) {\n\t\t\tthis.nextSeekPosition = Math.min(sample.offset+sample.alreadyRead,this.nextSeekPosition);\n\t\t} else {\n\t\t\tthis.nextSeekPosition = trak.samples[sampleNumber].offset+sample.alreadyRead;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tvar stream = stream_ || new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\n\tvar moof = this.createSingleSampleMoof(sample);\n\tmoof.write(stream);\n\n\t/* adjusting the data_offset now that the moof size is known*/\n\tmoof.trafs[0].truns[0].data_offset = moof.size+8; //8 is mdat header\n\tLog.debug(\"MP4Box\", \"Adjusting data_offset with new value \"+moof.trafs[0].truns[0].data_offset);\n\tstream.adjustUint32(moof.trafs[0].truns[0].data_offset_position, moof.trafs[0].truns[0].data_offset);\n\t\t\n\tvar mdat = new BoxParser.mdatBox();\n\tmdat.data = sample.data;\n\tmdat.write(stream);\n\treturn stream;\n};\n\n/* Modify the file and create the initialization segment */\nISOFile.writeInitializationSegment = function(ftyp, moov, total_duration, sample_duration) {\n\tvar i;\n\tLog.debug(\"ISOFile\", \"Generating initialization segment\");\n\n\tvar stream = new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tftyp.write(stream);\n\t\n\t/* we can now create the new mvex box */\n\tvar mvex = moov.add(\"mvex\");\n\tif (total_duration) {\n\t\tmvex.add(\"mehd\").set(\"fragment_duration\", total_duration);\n\t}\n\tfor (i = 0; i < moov.traks.length; i++) {\n\t\tmvex.add(\"trex\").set(\"track_id\", moov.traks[i].tkhd.track_id)\n\t\t\t\t\t\t.set(\"default_sample_description_index\", 1)\n\t\t\t\t\t\t.set(\"default_sample_duration\", sample_duration)\n\t\t\t\t\t\t.set(\"default_sample_size\", 0)\n\t\t\t\t\t\t.set(\"default_sample_flags\", 1<<16);\n\t}\n\tmoov.write(stream);\n\n\treturn stream.buffer;\n\n};\n\nISOFile.prototype.save = function(name) {\n\tvar stream = new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tthis.write(stream);\n\tstream.save(name);\t\n};\n\nISOFile.prototype.getBuffer = function() {\n\tvar stream = new DataStream();\n\tstream.endianness = DataStream.BIG_ENDIAN;\n\tthis.write(stream);\n\treturn stream.buffer;\n};\n\nISOFile.prototype.initializeSegmentation = function() {\n\tvar i;\n\tvar initSegs;\n\tvar trak;\n\tvar seg;\n\tif (this.onSegment === null) {\n\t\tLog.warn(\"MP4Box\", \"No segmentation callback set!\");\n\t}\n\tif (!this.isFragmentationInitialized) {\n\t\tthis.isFragmentationInitialized = true;\t\t\n\t\tthis.nextMoofNumber = 0;\n\t\tthis.resetTables();\n\t}\t\n\tinitSegs = [];\t\n\tfor (i = 0; i < this.fragmentedTracks.length; i++) {\n\t\tvar moov = new BoxParser.moovBox();\n\t\tmoov.mvhd = this.moov.mvhd;\n\t    moov.boxes.push(moov.mvhd);\n\t\ttrak = this.getTrackById(this.fragmentedTracks[i].id);\n\t\tmoov.boxes.push(trak);\n\t\tmoov.traks.push(trak);\n\t\tseg = {};\n\t\tseg.id = trak.tkhd.track_id;\n\t\tseg.user = this.fragmentedTracks[i].user;\n\t\tseg.buffer = ISOFile.writeInitializationSegment(this.ftyp, moov, (this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration: undefined), (this.moov.traks[i].samples.length>0 ? this.moov.traks[i].samples[0].duration: 0));\n\t\tinitSegs.push(seg);\n\t}\n\treturn initSegs;\n};\n\n// file:src/box-print.js\n/* \n * Copyright (c) Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nBoxParser.Box.prototype.printHeader = function(output) {\n\tthis.size += 8;\n\tif (this.size > MAX_SIZE) {\n\t\tthis.size += 8;\n\t}\n\tif (this.type === \"uuid\") {\n\t\tthis.size += 16;\n\t}\n\toutput.log(output.indent+\"size:\"+this.size);\n\toutput.log(output.indent+\"type:\"+this.type);\n};\n\nBoxParser.FullBox.prototype.printHeader = function(output) {\n\tthis.size += 4;\n\tBoxParser.Box.prototype.printHeader.call(this, output);\n\toutput.log(output.indent+\"version:\"+this.version);\n\toutput.log(output.indent+\"flags:\"+this.flags);\n};\n\nBoxParser.Box.prototype.print = function(output) {\n\tthis.printHeader(output);\n};\n\nBoxParser.ContainerBox.prototype.print = function(output) {\n\tthis.printHeader(output);\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tif (this.boxes[i]) {\n\t\t\tvar prev_indent = output.indent;\n\t\t\toutput.indent += \" \";\n\t\t\tthis.boxes[i].print(output);\n\t\t\toutput.indent = prev_indent;\n\t\t}\n\t}\n};\n\nISOFile.prototype.print = function(output) {\n\toutput.indent = \"\";\n\tfor (var i=0; i<this.boxes.length; i++) {\n\t\tif (this.boxes[i]) {\n\t\t\tthis.boxes[i].print(output);\n\t\t}\n\t}\t\n};\n\nBoxParser.mvhdBox.prototype.print = function(output) {\n\tBoxParser.FullBox.prototype.printHeader.call(this, output);\n\toutput.log(output.indent+\"creation_time: \"+this.creation_time);\n\toutput.log(output.indent+\"modification_time: \"+this.modification_time);\n\toutput.log(output.indent+\"timescale: \"+this.timescale);\n\toutput.log(output.indent+\"duration: \"+this.duration);\n\toutput.log(output.indent+\"rate: \"+this.rate);\n\toutput.log(output.indent+\"volume: \"+(this.volume>>8));\n\toutput.log(output.indent+\"matrix: \"+this.matrix.join(\", \"));\n\toutput.log(output.indent+\"next_track_id: \"+this.next_track_id);\n};\n\nBoxParser.tkhdBox.prototype.print = function(output) {\n\tBoxParser.FullBox.prototype.printHeader.call(this, output);\n\toutput.log(output.indent+\"creation_time: \"+this.creation_time);\n\toutput.log(output.indent+\"modification_time: \"+this.modification_time);\n\toutput.log(output.indent+\"track_id: \"+this.track_id);\n\toutput.log(output.indent+\"duration: \"+this.duration);\n\toutput.log(output.indent+\"volume: \"+(this.volume>>8));\n\toutput.log(output.indent+\"matrix: \"+this.matrix.join(\", \"));\n\toutput.log(output.indent+\"layer: \"+this.layer);\n\toutput.log(output.indent+\"alternate_group: \"+this.alternate_group);\n\toutput.log(output.indent+\"width: \"+this.width);\n\toutput.log(output.indent+\"height: \"+this.height);\n};// file:src/mp4box.js\n/*\n * Copyright (c) 2012-2013. Telecom ParisTech/TSI/MM/GPAC Cyril Concolato\n * License: BSD-3-Clause (see LICENSE file)\n */\nvar MP4Box = {};\n\nMP4Box.createFile = function (_keepMdatData, _stream) {\n\t/* Boolean indicating if bytes containing media data should be kept in memory */\n\tvar keepMdatData = (_keepMdatData !== undefined ? _keepMdatData : true);\n\tvar file = new ISOFile(_stream);\n\tfile.discardMdatData = (keepMdatData ? false : true);\n\treturn file;\n};\n\n{\n\texports.createFile = MP4Box.createFile;\n}\n}(mp4box_all));\n\n/**\n * Taken from https://github.com/w3c/webcodecs/blob/main/samples/mp4-decode/mp4_demuxer.js\n */\nvar Writer = /*#__PURE__*/function () {\n  function Writer(size) {\n    _classCallCheck(this, Writer);\n    this.data = new Uint8Array(size);\n    this.idx = 0;\n    this.size = size;\n  }\n  _createClass(Writer, [{\n    key: \"getData\",\n    value: function getData() {\n      if (this.idx !== this.size) throw new Error('Mismatch between size reserved and sized used');\n      return this.data.slice(0, this.idx);\n    }\n  }, {\n    key: \"writeUint8\",\n    value: function writeUint8(value) {\n      this.data.set([value], this.idx);\n      this.idx += 1;\n    }\n  }, {\n    key: \"writeUint16\",\n    value: function writeUint16(value) {\n      var arr = new Uint16Array(1);\n      arr[0] = value;\n      var buffer = new Uint8Array(arr.buffer);\n      this.data.set([buffer[1], buffer[0]], this.idx);\n      this.idx += 2;\n    }\n  }, {\n    key: \"writeUint8Array\",\n    value: function writeUint8Array(value) {\n      this.data.set(value, this.idx);\n      this.idx += value.length;\n    }\n  }]);\n  return Writer;\n}();\n/**\n * Taken from https://github.com/w3c/webcodecs/blob/main/samples/mp4-decode/mp4_demuxer.js\n *\n * @param avccBox\n * @returns {*}\n */\nvar getExtradata = function getExtradata(avccBox) {\n  var i;\n  var size = 7;\n  for (i = 0; i < avccBox.SPS.length; i += 1) {\n    // nalu length is encoded as a uint16.\n    size += 2 + avccBox.SPS[i].length;\n  }\n  for (i = 0; i < avccBox.PPS.length; i += 1) {\n    // nalu length is encoded as a uint16.\n    size += 2 + avccBox.PPS[i].length;\n  }\n  var writer = new Writer(size);\n  writer.writeUint8(avccBox.configurationVersion);\n  writer.writeUint8(avccBox.AVCProfileIndication);\n  writer.writeUint8(avccBox.profile_compatibility);\n  writer.writeUint8(avccBox.AVCLevelIndication);\n  // eslint-disable-next-line no-bitwise\n  writer.writeUint8(avccBox.lengthSizeMinusOne + (63 << 2));\n\n  // eslint-disable-next-line no-bitwise\n  writer.writeUint8(avccBox.nb_SPS_nalus + (7 << 5));\n  for (i = 0; i < avccBox.SPS.length; i += 1) {\n    writer.writeUint16(avccBox.SPS[i].length);\n    writer.writeUint8Array(avccBox.SPS[i].nalu);\n  }\n  writer.writeUint8(avccBox.nb_PPS_nalus);\n  for (i = 0; i < avccBox.PPS.length; i += 1) {\n    writer.writeUint16(avccBox.PPS[i].length);\n    writer.writeUint8Array(avccBox.PPS[i].nalu);\n  }\n  return writer.getData();\n};\n\n/**\n * decodeVideo takes an url to a mp4 file and converts it into frames.\n *\n * The steps for this are:\n *  1. Determine the codec for this video file and demux it into chunks.\n *  2. Read the chunks with VideoDecoder as fast as possible.\n *  3. Return an array of frames that we can efficiently draw to a canvas.\n *\n * @param src\n * @param VideoDecoder\n * @param EncodedVideoChunk\n * @param emitFrame\n * @param debug\n * @returns {Promise<unknown>}\n */\nvar decodeVideo = function decodeVideo(src, emitFrame, _ref) {\n  var VideoDecoder = _ref.VideoDecoder,\n    EncodedVideoChunk = _ref.EncodedVideoChunk,\n    debug = _ref.debug;\n  return new Promise(function (resolve, reject) {\n    if (debug) console.info('Decoding video from', src);\n    try {\n      // Uses mp4box for demuxing\n      var mp4boxfile = mp4box_all.createFile();\n\n      // Holds the codec value\n      var codec;\n\n      // Creates a VideoDecoder instance\n      var decoder = new VideoDecoder({\n        output: function output(frame) {\n          createImageBitmap(frame, {\n            resizeQuality: 'low'\n          }).then(function (bitmap) {\n            emitFrame(bitmap);\n            frame.close();\n            if (decoder.decodeQueueSize <= 0) {\n              // Give it an extra half second to finish everything\n              setTimeout(function () {\n                if (decoder.state !== 'closed') {\n                  decoder.close();\n                  resolve();\n                }\n              }, 500);\n            }\n          });\n        },\n        error: function error(e) {\n          // eslint-disable-next-line no-console\n          console.error(e);\n          reject(e);\n        }\n      });\n      mp4boxfile.onReady = function (info) {\n        if (info && info.videoTracks && info.videoTracks[0]) {\n          var _info$videoTracks = _slicedToArray(info.videoTracks, 1);\n          codec = _info$videoTracks[0].codec;\n          if (debug) console.info('Video with codec:', codec);\n\n          // Gets the avccbox used for reading extradata\n          var avccBox = mp4boxfile.moov.traks[0].mdia.minf.stbl.stsd.entries[0].avcC;\n          var extradata = getExtradata(avccBox);\n\n          // configure decoder\n          decoder.configure({\n            codec: codec,\n            description: extradata\n          });\n\n          // Setup mp4box file for breaking it into chunks\n          mp4boxfile.setExtractionOptions(info.videoTracks[0].id);\n          mp4boxfile.start();\n        } else reject(new Error('URL provided is not a valid mp4 video file.'));\n      };\n      mp4boxfile.onSamples = function (track_id, ref, samples) {\n        for (var i = 0; i < samples.length; i += 1) {\n          var sample = samples[i];\n          var type = sample.is_sync ? 'key' : 'delta';\n          var chunk = new EncodedVideoChunk({\n            type: type,\n            timestamp: sample.cts,\n            duration: sample.duration,\n            data: sample.data\n          });\n          decoder.decode(chunk);\n        }\n      };\n\n      // Fetches the file into arraybuffers\n      fetch(src).then(function (res) {\n        var reader = res.body.getReader();\n        var offset = 0;\n        function appendBuffers(_ref2) {\n          var done = _ref2.done,\n            value = _ref2.value;\n          if (done) {\n            mp4boxfile.flush();\n            return null;\n          }\n          var buf = value.buffer;\n          buf.fileStart = offset;\n          offset += buf.byteLength;\n          mp4boxfile.appendBuffer(buf);\n          return reader.read().then(appendBuffers);\n        }\n        return reader.read().then(appendBuffers);\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\n\n/**\n * The main function for decoding video. Deals with the polyfill cases first,\n * then calls our decodeVideo.\n *\n * @param src\n * @param emitFrame\n * @param debug\n * @returns {Promise<never>|Promise<void>|*}\n */\nvar videoDecoder = (function (src, emitFrame, debug) {\n  // If our browser supports WebCodecs natively\n  if (typeof VideoDecoder === 'function' && typeof EncodedVideoChunk === 'function') {\n    if (debug) console.info('WebCodecs is natively supported, using native version...');\n    return decodeVideo(src, emitFrame, {\n      VideoDecoder: VideoDecoder,\n      EncodedVideoChunk: EncodedVideoChunk,\n      debug: debug\n    });\n  }\n\n  // Otherwise, resolve nothing\n  if (debug) console.info('WebCodecs is not available in this browser.');\n  return Promise.resolve();\n});\n\n/**\n *   ____                 _ _     __     ___     _\n *  / ___|  ___ _ __ ___ | | |_   \\ \\   / (_) __| | ___  ___\n *  \\___ \\ / __| '__/ _ \\| | | | | \\ \\ / /| |/ _` |/ _ \\/ _ \\\n *   ___) | (__| | | (_) | | | |_| |\\ V / | | (_| |  __/ (_) |\n *  |____/ \\___|_|  \\___/|_|_|\\__, | \\_/  |_|\\__,_|\\___|\\___/\n *                            |___/\n *\n * Responsive scrollable videos without obscure video encoding requirements.\n * Compatible with React, Svelte, Vue, and plain HTML.\n */\nvar ScrollyVideo = /*#__PURE__*/function () {\n  function ScrollyVideo(_ref) {\n    var _this = this;\n    var src = _ref.src,\n      scrollyVideoContainer = _ref.scrollyVideoContainer,\n      _ref$cover = _ref.cover,\n      cover = _ref$cover === void 0 ? true : _ref$cover,\n      _ref$sticky = _ref.sticky,\n      sticky = _ref$sticky === void 0 ? true : _ref$sticky,\n      _ref$full = _ref.full,\n      full = _ref$full === void 0 ? true : _ref$full,\n      _ref$trackScroll = _ref.trackScroll,\n      trackScroll = _ref$trackScroll === void 0 ? true : _ref$trackScroll,\n      _ref$transitionSpeed = _ref.transitionSpeed,\n      transitionSpeed = _ref$transitionSpeed === void 0 ? 8 : _ref$transitionSpeed,\n      _ref$frameThreshold = _ref.frameThreshold,\n      frameThreshold = _ref$frameThreshold === void 0 ? 0.1 : _ref$frameThreshold,\n      _ref$useWebCodecs = _ref.useWebCodecs,\n      useWebCodecs = _ref$useWebCodecs === void 0 ? true : _ref$useWebCodecs,\n      _ref$debug = _ref.debug,\n      debug = _ref$debug === void 0 ? false : _ref$debug;\n    _classCallCheck(this, ScrollyVideo);\n    // Make sure that we have a DOM\n    if ((typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) !== 'object') {\n      console.error('ScrollyVideo must be initiated in a DOM context');\n      return;\n    }\n\n    // Make sure the basic arguments are set for scrollyvideo\n    if (!scrollyVideoContainer) {\n      console.error('scrollyVideoContainer must be a valid DOM object');\n      return;\n    }\n    if (!src) {\n      console.error('Must provide valid video src to ScrollyVideo');\n      return;\n    }\n\n    // Save the container. If the container is a string we get the element\n    // eslint-disable-next-line no-undef\n    if (scrollyVideoContainer instanceof Element) this.container = scrollyVideoContainer;\n    // otherwise it should better be an element\n    else if (typeof scrollyVideoContainer === 'string') {\n      // eslint-disable-next-line no-undef\n      this.container = document.getElementById(scrollyVideoContainer);\n      if (!this.container) throw new Error('scrollyVideoContainer must be a valid DOM object');\n    } else {\n      throw new Error('scrollyVideoContainer must be a valid DOM object');\n    }\n\n    // Save the constructor options\n    this.src = src;\n    this.transitionSpeed = transitionSpeed;\n    this.frameThreshold = frameThreshold;\n    this.useWebCodecs = useWebCodecs;\n    this.cover = cover;\n    this.sticky = sticky;\n    this.full = full;\n    this.trackScroll = trackScroll;\n    this.debug = debug;\n\n    // Create the initial video object. Even if we are going to use webcodecs,\n    // we start with a paused video object\n    // eslint-disable-next-line no-undef\n    this.video = document.createElement('video');\n    this.video.src = src;\n    this.video.preload = 'auto';\n    this.video.tabIndex = 0;\n    this.video.autobuffer = true;\n    this.video.playsInline = true;\n    this.video.muted = true;\n    this.video.pause();\n    this.video.load();\n\n    // Adds the video to the container\n    this.container.appendChild(this.video);\n\n    // Setting CSS properties for sticky\n    if (sticky) {\n      this.container.style.display = 'block';\n      this.container.style.position = 'sticky';\n      this.container.style.top = '0';\n    }\n\n    // Setting CSS properties for full\n    if (full) {\n      this.container.style.width = '100%';\n      this.container.style.height = '100vh';\n      this.container.style.overflow = 'hidden';\n    }\n\n    // Setting CSS properties for cover\n    if (cover) this.setCoverStyle(this.video);\n\n    // Detect webkit (safari), because webkit requires special attention\n    var browserEngine = new UAParser().getEngine();\n    // eslint-disable-next-line no-undef\n    this.isSafari = browserEngine.name === 'WebKit';\n    if (debug && this.isSafari) console.info('Safari browser detected');\n\n    // Initialize state variables\n    this.currentTime = 0; // Saves the currentTime of the video, synced with this.video.currentTime\n    this.targetTime = 0; // The target time before a transition happens\n    this.canvas = null; // The canvas for drawing the frames decoded by webCodecs\n    this.context = null; // The canvas context\n    this.frames = []; // The frames decoded by webCodecs\n    this.frameRate = 0; // Calculation of frameRate so we know which frame to paint\n\n    // Add scroll listener for responding to scroll position\n    this.updateScrollPercentage = function (jump) {\n      // Used for internally setting the scroll percentage based on built-in listeners\n      var containerBoundingClientRect = _this.container.parentNode.getBoundingClientRect();\n\n      // Calculate the current scroll percent of the video\n      var scrollPercent = -containerBoundingClientRect.top\n      // eslint-disable-next-line no-undef\n      / (containerBoundingClientRect.height - window.innerHeight);\n      if (_this.debug) console.info('ScrollyVideo scrolled to', scrollPercent);\n\n      // Set the target time percent\n      _this.setTargetTimePercent(scrollPercent, jump);\n    };\n\n    // Add our event listeners for handling changes to the window or scroll\n    if (this.trackScroll) {\n      // eslint-disable-next-line no-undef\n      window.addEventListener('scroll', this.updateScrollPercentage);\n\n      // Set the initial scroll percentage\n      this.video.addEventListener('loadedmetadata', function () {\n        return _this.updateScrollPercentage(true);\n      }, {\n        once: true\n      });\n    } else {\n      this.video.addEventListener('loadedmetadata', function () {\n        return _this.setTargetTimePercent(0, true);\n      }, {\n        once: true\n      });\n    }\n\n    // Add resize function\n    this.resize = function () {\n      if (_this.debug) console.info('ScrollyVideo resizing...');\n      // On resize, we need to reset the cover style\n      if (_this.cover) _this.setCoverStyle(_this.canvas || _this.video);\n      // Then repaint the canvas, if we are in useWebcodecs\n      _this.paintCanvasFrame(Math.floor(_this.currentTime * _this.frameRate));\n    };\n\n    // eslint-disable-next-line no-undef\n    window.addEventListener('resize', this.resize);\n    this.video.addEventListener('progress', this.resize);\n\n    // Calls decode video to attempt webcodecs method\n    this.decodeVideo();\n  }\n\n  /**\n   * Sets the style of the video or canvas to \"cover\" it's container\n   *\n   * @param el\n   */\n  _createClass(ScrollyVideo, [{\n    key: \"setCoverStyle\",\n    value: function setCoverStyle(el) {\n      if (this.cover) {\n        /* eslint-disable no-param-reassign */\n        el.style.position = 'absolute';\n        el.style.top = '50%';\n        el.style.left = '50%';\n        el.style.transform = 'translate(-50%, -50%)';\n        el.style.minWidth = '101%';\n        el.style.minHeight = '101%';\n\n        // Gets the width and height of the container\n        var _this$container$getBo = this.container.getBoundingClientRect(),\n          containerWidth = _this$container$getBo.width,\n          containerHeight = _this$container$getBo.height;\n\n        // Gets the width and height of the video frames\n        var width = el.videoWidth || el.width;\n        var height = el.videoHeight || el.height;\n        if (this.debug) console.info('Container dimensions:', [containerWidth, containerHeight]);\n        if (this.debug) console.info('Element dimensions:', [width, height]);\n\n        // Determines which axis needs to be 100% and which needs to be scaled\n        if (containerWidth / containerHeight > width / height) {\n          el.style.width = '100%';\n          el.style.height = 'auto';\n        } else {\n          el.style.height = '100%';\n          el.style.width = 'auto';\n        }\n        /* eslint-enable no-param-reassign */\n      }\n    }\n\n    /**\n     * Uses webCodecs to decode the video into frames\n     */\n  }, {\n    key: \"decodeVideo\",\n    value: function decodeVideo() {\n      var _this2 = this;\n      if (this.useWebCodecs && this.src) {\n        videoDecoder(this.src, function (frame) {\n          _this2.frames.push(frame);\n        }, this.debug)[\"catch\"](function () {\n          if (_this2.debug) console.error('Error encountered while decoding video');\n          // Remove all decoded frames if a failure happens during decoding\n          _this2.frames = [];\n\n          // Force a video reload when videoDecoder fails\n          _this2.video.load();\n        }).then(function () {\n          // If no frames, something went wrong\n          if (_this2.frames.length === 0) {\n            if (_this2.debug) console.error('No frames were received from webCodecs');\n            return;\n          }\n\n          // Calculate the frameRate based on number of frames and the duration\n          _this2.frameRate = _this2.frames.length / _this2.video.duration;\n          if (_this2.debug) console.info('Received', _this2.frames.length, 'frames');\n\n          // Remove the video and add the canvas\n          // eslint-disable-next-line no-undef\n          _this2.canvas = document.createElement('canvas');\n          _this2.context = _this2.canvas.getContext('2d');\n\n          // Hide the video and add the canvas to the container\n          _this2.video.style.display = 'none';\n          _this2.container.appendChild(_this2.canvas);\n          if (_this2.cover) _this2.setCoverStyle(_this2.canvas);\n\n          // Paint our first frame\n          _this2.paintCanvasFrame(Math.floor(_this2.currentTime * _this2.frameRate));\n        });\n      }\n    }\n\n    /**\n     * Paints the frame of to the canvas\n     *\n     * @param frameNum\n     */\n  }, {\n    key: \"paintCanvasFrame\",\n    value: function paintCanvasFrame(frameNum) {\n      if (this.canvas) {\n        // Get the frame and paint it to the canvas\n        var currFrame = this.frames[frameNum];\n        if (currFrame) {\n          if (this.debug) console.info('Painting frame', frameNum);\n\n          // Make sure the canvas is scaled properly, similar to setCoverStyle\n          this.canvas.width = currFrame.width;\n          this.canvas.height = currFrame.height;\n          var _this$container$getBo2 = this.container.getBoundingClientRect(),\n            width = _this$container$getBo2.width,\n            height = _this$container$getBo2.height;\n          if (width / height > currFrame.width / currFrame.height) {\n            this.canvas.style.width = '100%';\n            this.canvas.style.height = 'auto';\n          } else {\n            this.canvas.style.height = '100%';\n            this.canvas.style.width = 'auto';\n          }\n\n          // Draw the frame to the canvas context\n          this.context.drawImage(currFrame, 0, 0, currFrame.width, currFrame.height);\n        }\n      }\n    }\n\n    /**\n     * Transitions the video or the canvas to the proper frame\n     *\n     * @param jump\n     */\n  }, {\n    key: \"transitionToTargetTime\",\n    value: function transitionToTargetTime(jump) {\n      var _this3 = this;\n      if (this.debug) {\n        console.info('Transitioning targetTime:', this.targetTime, 'currentTime:', this.currentTime);\n      }\n\n      // If we are already close enough to our target, pause the video and return.\n      // This is the base case of the recursive function\n      if (\n      // eslint-disable-next-line no-restricted-globals\n      isNaN(this.targetTime)\n      // If the currentTime is already close enough to the targetTime\n      || Math.abs(this.currentTime - this.targetTime) < this.frameThreshold) {\n        this.video.pause();\n        this.transitioning = false;\n        return;\n      }\n\n      // Make sure we don't go out of time bounds\n      if (this.targetTime > this.video.duration) this.targetTime = this.video.duration;\n      if (this.targetTime < 0) this.targetTime = 0;\n\n      // How far forward we need to transition\n      var transitionForward = this.targetTime - this.currentTime;\n      if (this.canvas) {\n        // Update currentTime and paint the closest frame\n        this.currentTime += transitionForward / (256 / this.transitionSpeed);\n        // If jump, we go directly to the frame\n        if (jump) this.currentTime = this.targetTime;\n        this.paintCanvasFrame(Math.floor(this.currentTime * this.frameRate));\n      } else if (jump || this.isSafari || this.targetTime - this.currentTime < 0) {\n        // We can't use a negative playbackRate, so if the video needs to go backwards,\n        // We have to use the inefficient method of modifying currentTime rapidly to\n        // get an effect.\n        this.video.pause();\n        this.currentTime += transitionForward / (64 / this.transitionSpeed);\n        // If jump, we go directly to the frame\n        if (jump) this.currentTime = this.targetTime;\n        this.video.currentTime = this.currentTime;\n      } else {\n        // Otherwise, we play the video and adjust the playbackRate to get a smoother\n        // animation effect.\n        var playbackRate = Math.max(Math.min(transitionForward * 4, this.transitionSpeed, 16), 1);\n        if (this.debug) console.info('ScrollyVideo playbackRate:', playbackRate);\n        // eslint-disable-next-line no-restricted-globals\n        if (!isNaN(playbackRate)) {\n          this.video.playbackRate = playbackRate;\n          this.video.play();\n        }\n        // Set the currentTime to the video's currentTime\n        this.currentTime = this.video.currentTime;\n      }\n\n      // Recursively calls ourselves until the animation is done.\n      // eslint-disable-next-line no-undef\n      if (typeof requestAnimationFrame === 'function') {\n        // eslint-disable-next-line no-undef\n        requestAnimationFrame(function () {\n          return _this3.transitionToTargetTime();\n        });\n      }\n    }\n\n    /**\n     * Sets the currentTime as a percentage of the video duration.\n     *\n     * @param setPercentage\n     * @param jump\n     */\n  }, {\n    key: \"setTargetTimePercent\",\n    value: function setTargetTimePercent(setPercentage, jump) {\n      // The time we want to transition to\n      this.targetTime = Math.max(Math.min(setPercentage, 1), 0) * (this.frames.length && this.frameRate ? this.frames.length / this.frameRate : this.video.duration);\n\n      // If we are close enough, return early\n      if (!jump && Math.abs(this.currentTime - this.targetTime) < this.frameThreshold) return;\n\n      // If we are already transitioning, bail early\n      if (!jump && this.transitioning) return;\n\n      // Play the video if we are in video mode\n      if (!this.canvas && !this.video.paused) this.video.play();\n\n      // Set transitioning state to true and begin transition\n      this.transitioning = true;\n      this.transitionToTargetTime(jump);\n    }\n\n    /**\n     * Call to destroy this ScrollyVideo object\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.debug) console.info('Destroying ScrollyVideo');\n\n      // eslint-disable-next-line no-undef\n      if (this.trackScroll) window.removeEventListener('scroll', this.updateScrollPercentage);\n\n      // eslint-disable-next-line no-undef\n      window.removeEventListener('resize', this.resize);\n\n      // Clear component\n      if (this.container) this.container.innerHTML = '';\n    }\n  }]);\n  return ScrollyVideo;\n}();\n\nvar _excluded = [\"videoPercentage\"];\nfunction ScrollyVideoComponent(props) {\n  // variable to hold the DOM element\n  var containerElement = React.useRef(null);\n\n  // ref to hold the scrollyVideo object\n  var scrollyVideoRef = React.useRef(null);\n\n  // Store the props so we know when things change\n  var _useState = React.useState(''),\n    _useState2 = _slicedToArray(_useState, 2),\n    lastPropsString = _useState2[0],\n    setLastPropsString = _useState2[1];\n  React.useEffect(function () {\n    if (containerElement) {\n      // separate out the videoPercentage prop\n      var videoPercentage = props.videoPercentage,\n        restProps = _objectWithoutProperties(props, _excluded);\n      if (JSON.stringify(restProps) !== lastPropsString) {\n        // if scrollyvideo already exists and any parameter is updated, destroy and recreate.\n        if (scrollyVideoRef.current && scrollyVideoRef.current.destroy) scrollyVideoRef.current.destroy();\n        scrollyVideoRef.current = new ScrollyVideo(_objectSpread2({\n          scrollyVideoContainer: containerElement.current\n        }, props));\n\n        // Save the new props\n        setLastPropsString(JSON.stringify(restProps));\n      }\n\n      // If we need to update the target time percent\n      if (scrollyVideoRef.current && typeof videoPercentage === 'number' && videoPercentage >= 0 && videoPercentage <= 1) {\n        scrollyVideoRef.current.setTargetTimePercent(videoPercentage);\n      }\n    }\n\n    // Cleanup the component on unmount\n    return function () {\n      if (scrollyVideoRef.current && scrollyVideoRef.current.destroy) scrollyVideoRef.current.destroy();\n    };\n  }, [containerElement, props]);\n  return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n    ref: containerElement\n  });\n}\n\nmodule.exports = ScrollyVideoComponent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zY3JvbGx5LXZpZGVvL2Rpc3QvU2Nyb2xseVZpZGVvLmNqcy5qc3giLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1GQUFPOztBQUUzQixxQ0FBcUMsNERBQTREOztBQUVqRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZLDZFQUE2RTtBQUNqRyxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzSEFBc0gscUJBQU0sbUJBQW1CLHFCQUFNOztBQUVySixnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLEdBQUc7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0RBQXNEO0FBQ3REOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQSwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxJQUFJLFdBQVcsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQSx3REFBd0QsRUFBRTtBQUMxRDtBQUNBLHdDQUF3QztBQUN4Qyw0QkFBNEIsSUFBSTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZiwwQkFBMEIsRUFBRTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsaUJBQWlCO0FBQzNDOztBQUVBO0FBQ0EsMEJBQTBCLEVBQUUsVUFBVTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDOztBQUVBO0FBQ0EsZ0NBQWdDLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxhQUFhLElBQUk7QUFDeEU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxXQUFXLEVBQUU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWUsSUFBSTtBQUN6Qzs7QUFFQTtBQUNBLGdDQUFnQyxFQUFFLFdBQVcsRUFBRSx5REFBeUQsSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLElBQUk7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLHlCQUF5QixHQUFHO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QyxnQ0FBZ0MsRUFBRTtBQUNsQyxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTyxJQUFJLElBQUk7QUFDNUQ7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0IsUUFBUSxJQUFJO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLElBQUk7QUFDNUI7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDhCQUE4QixJQUFJLEVBQUU7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsSUFBSSw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSSxtQ0FBbUMsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxhQUFhO0FBQ3ZCLFVBQVUsU0FBUztBQUNuQixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0IsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQixVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQ7QUFDQTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFVBQVU7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxhQUFhO0FBQ3pCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxhQUFhO0FBQ3pCLFlBQVksYUFBYTtBQUN6QixZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsdURBQXVEO0FBQ3ZELDBEQUEwRDtBQUMxRCxrREFBa0Q7QUFDbEQsZ0RBQWdEO0FBQ2hEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVcsZUFBZTtBQUMxQjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0gsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0EsOENBQThDO0FBQzlDLElBQUk7QUFDSiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUMsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDLGNBQWMsd0VBQXdFO0FBQ3RGO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRDQUE0QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx5QkFBeUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsSUFBSTtBQUNKLDZCQUE2QjtBQUM3QixJQUFJO0FBQ0osbUNBQW1DO0FBQ25DO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQSxRQUFRO0FBQ1IsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlDQUFpQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQSxhQUFhLHlCQUF5QjtBQUN0Qyx5Q0FBeUMsc0NBQXNDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2Nyb2xseS12aWRlby9kaXN0L1Njcm9sbHlWaWRlby5janMuanN4PzY5NjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IF9pKSB7XG4gICAgdmFyIF9zLFxuICAgICAgX2UsXG4gICAgICBfeCxcbiAgICAgIF9yLFxuICAgICAgX2FyciA9IFtdLFxuICAgICAgX24gPSAhMCxcbiAgICAgIF9kID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfeCA9IChfaSA9IF9pLmNhbGwoYXJyKSkubmV4dCwgMCA9PT0gaSkge1xuICAgICAgICBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjtcbiAgICAgICAgX24gPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShfbiA9IChfcyA9IF94LmNhbGwoX2kpKS5kb25lKSAmJiAoX2Fyci5wdXNoKF9zLnZhbHVlKSwgX2Fyci5sZW5ndGggIT09IGkpOyBfbiA9ICEwKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gITAsIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIG51bGwgIT0gX2kucmV0dXJuICYmIChfciA9IF9pLnJldHVybigpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgdWFQYXJzZXIgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKiBVQVBhcnNlci5qcyB2MS4wLjMzXG4gICBDb3B5cmlnaHQgwqkgMjAxMi0yMDIxIEZhaXNhbCBTYWxtYW4gPGZAZmFpc2FsbWFuLmNvbT5cbiAgIE1JVCBMaWNlbnNlICovLypcbiAgIERldGVjdCBCcm93c2VyLCBFbmdpbmUsIE9TLCBDUFUsIGFuZCBEZXZpY2UgdHlwZS9tb2RlbCBmcm9tIFVzZXItQWdlbnQgZGF0YS5cbiAgIFN1cHBvcnRzIGJyb3dzZXIgJiBub2RlLmpzIGVudmlyb25tZW50LiBcbiAgIERlbW8gICA6IGh0dHBzOi8vZmFpc2FsbWFuLmdpdGh1Yi5pby91YS1wYXJzZXItanNcbiAgIFNvdXJjZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWlzYWxtYW4vdWEtcGFyc2VyLWpzICovXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uICh3aW5kb3csIHVuZGVmaW5lZCQxKSB7XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIENvbnN0YW50c1xuICAgIC8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIExJQlZFUlNJT04gID0gJzEuMC4zMycsXG4gICAgICAgIEVNUFRZICAgICAgID0gJycsXG4gICAgICAgIFVOS05PV04gICAgID0gJz8nLFxuICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG4gICAgICAgIFVOREVGX1RZUEUgID0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIE9CSl9UWVBFICAgID0gJ29iamVjdCcsXG4gICAgICAgIFNUUl9UWVBFICAgID0gJ3N0cmluZycsXG4gICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJyxcbiAgICAgICAgTU9ERUwgICAgICAgPSAnbW9kZWwnLFxuICAgICAgICBOQU1FICAgICAgICA9ICduYW1lJyxcbiAgICAgICAgVFlQRSAgICAgICAgPSAndHlwZScsXG4gICAgICAgIFZFTkRPUiAgICAgID0gJ3ZlbmRvcicsXG4gICAgICAgIFZFUlNJT04gICAgID0gJ3ZlcnNpb24nLFxuICAgICAgICBBUkNISVRFQ1RVUkU9ICdhcmNoaXRlY3R1cmUnLFxuICAgICAgICBDT05TT0xFICAgICA9ICdjb25zb2xlJyxcbiAgICAgICAgTU9CSUxFICAgICAgPSAnbW9iaWxlJyxcbiAgICAgICAgVEFCTEVUICAgICAgPSAndGFibGV0JyxcbiAgICAgICAgU01BUlRUViAgICAgPSAnc21hcnR0dicsXG4gICAgICAgIFdFQVJBQkxFICAgID0gJ3dlYXJhYmxlJyxcbiAgICAgICAgRU1CRURERUQgICAgPSAnZW1iZWRkZWQnLFxuICAgICAgICBVQV9NQVhfTEVOR1RIID0gMzUwO1xuXG4gICAgdmFyIEFNQVpPTiAgPSAnQW1hem9uJyxcbiAgICAgICAgQVBQTEUgICA9ICdBcHBsZScsXG4gICAgICAgIEFTVVMgICAgPSAnQVNVUycsXG4gICAgICAgIEJMQUNLQkVSUlkgPSAnQmxhY2tCZXJyeScsXG4gICAgICAgIEJST1dTRVIgPSAnQnJvd3NlcicsXG4gICAgICAgIENIUk9NRSAgPSAnQ2hyb21lJyxcbiAgICAgICAgRURHRSAgICA9ICdFZGdlJyxcbiAgICAgICAgRklSRUZPWCA9ICdGaXJlZm94JyxcbiAgICAgICAgR09PR0xFICA9ICdHb29nbGUnLFxuICAgICAgICBIVUFXRUkgID0gJ0h1YXdlaScsXG4gICAgICAgIExHICAgICAgPSAnTEcnLFxuICAgICAgICBNSUNST1NPRlQgPSAnTWljcm9zb2Z0JyxcbiAgICAgICAgTU9UT1JPTEEgID0gJ01vdG9yb2xhJyxcbiAgICAgICAgT1BFUkEgICA9ICdPcGVyYScsXG4gICAgICAgIFNBTVNVTkcgPSAnU2Ftc3VuZycsXG4gICAgICAgIFNIQVJQICAgPSAnU2hhcnAnLFxuICAgICAgICBTT05ZICAgID0gJ1NvbnknLFxuICAgICAgICBYSUFPTUkgID0gJ1hpYW9taScsXG4gICAgICAgIFpFQlJBICAgPSAnWmVicmEnLFxuICAgICAgICBGQUNFQk9PSyAgID0gJ0ZhY2Vib29rJztcblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gSGVscGVyXG4gICAgLy8vLy8vLy8vL1xuXG4gICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChyZWdleGVzLCBleHRlbnNpb25zKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkUmVnZXhlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByZWdleGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbaV0gJiYgZXh0ZW5zaW9uc1tpXS5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlZ2V4ZXNbaV0gPSBleHRlbnNpb25zW2ldLmNvbmNhdChyZWdleGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZWdleGVzW2ldID0gcmVnZXhlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkUmVnZXhlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyaXplID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIGVudW1zID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZW51bXNbYXJyW2ldLnRvVXBwZXJDYXNlKCldID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudW1zO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgPSBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdHIxID09PSBTVFJfVFlQRSA/IGxvd2VyaXplKHN0cjIpLmluZGV4T2YobG93ZXJpemUoc3RyMSkpICE9PSAtMSA6IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JpemUgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCBFTVBUWSkuc3BsaXQoJy4nKVswXSA6IHVuZGVmaW5lZCQxO1xuICAgICAgICB9LFxuICAgICAgICB0cmltID0gZnVuY3Rpb24gKHN0ciwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHN0cikgPT09IFNUUl9UWVBFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgRU1QVFkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YobGVuKSA9PT0gVU5ERUZfVFlQRSA/IHN0ciA6IHN0ci5zdWJzdHJpbmcoMCwgVUFfTUFYX0xFTkdUSCk7XG4gICAgICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE1hcCBoZWxwZXJcbiAgICAvLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIHJneE1hcHBlciA9IGZ1bmN0aW9uICh1YSwgYXJyYXlzKSB7XG5cbiAgICAgICAgICAgIHZhciBpID0gMCwgaiwgaywgcCwgcSwgbWF0Y2hlcywgbWF0Y2g7XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgcmVnZXhlcyBtYXBzXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGFycmF5cy5sZW5ndGggJiYgIW1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciByZWdleCA9IGFycmF5c1tpXSwgICAgICAgLy8gZXZlbiBzZXF1ZW5jZSAoMCwyLDQsLi4pXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gYXJyYXlzW2kgKyAxXTsgICAvLyBvZGQgc2VxdWVuY2UgKDEsMyw1LC4uKVxuICAgICAgICAgICAgICAgIGogPSBrID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSBtYXRjaGluZyB1YXN0cmluZyB3aXRoIHJlZ2V4ZXNcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IHJlZ2V4Lmxlbmd0aCAmJiAhbWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleFtqKytdLmV4ZWModWEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1srK2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcm9wc1twXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBnaXZlbiBwcm9wZXJ0eSBpcyBhY3R1YWxseSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcSA9PT0gT0JKX1RZUEUgJiYgcS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxWzFdID09IEZVTkNfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBtb2RpZmllZCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBxWzFdLmNhbGwodGhpcywgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gZ2l2ZW4gdmFsdWUsIGlnbm9yZSByZWdleCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBxWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHFbMV0gPT09IEZVTkNfVFlQRSAmJiAhKHFbMV0uZXhlYyAmJiBxWzFdLnRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiAodXN1YWxseSBzdHJpbmcgbWFwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FuaXRpemUgbWF0Y2ggdXNpbmcgZ2l2ZW4gcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pIDogdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBxWzNdLmNhbGwodGhpcywgbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSkgOiB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcV0gPSBtYXRjaCA/IG1hdGNoIDogdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJNYXBwZXIgPSBmdW5jdGlvbiAoc3RyLCBtYXApIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXBbaV0gPT09IE9CSl9UWVBFICYmIG1hcFtpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzKG1hcFtpXVtqXSwgc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQkMSA6IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhcyhtYXBbaV0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCQxIDogaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdHJpbmcgbWFwXG4gICAgLy8vLy8vLy8vLy8vLy9cblxuICAgIC8vIFNhZmFyaSA8IDMuMFxuICAgIHZhciBvbGRTYWZhcmlNYXAgPSB7XG4gICAgICAgICAgICAnMS4wJyAgIDogJy84JyxcbiAgICAgICAgICAgICcxLjInICAgOiAnLzEnLFxuICAgICAgICAgICAgJzEuMycgICA6ICcvMycsXG4gICAgICAgICAgICAnMi4wJyAgIDogJy80MTInLFxuICAgICAgICAgICAgJzIuMC4yJyA6ICcvNDE2JyxcbiAgICAgICAgICAgICcyLjAuMycgOiAnLzQxNycsXG4gICAgICAgICAgICAnMi4wLjQnIDogJy80MTknLFxuICAgICAgICAgICAgJz8nICAgICA6ICcvJ1xuICAgICAgICB9LFxuICAgICAgICB3aW5kb3dzVmVyc2lvbk1hcCA9IHtcbiAgICAgICAgICAgICdNRScgICAgICAgIDogJzQuOTAnLFxuICAgICAgICAgICAgJ05UIDMuMTEnICAgOiAnTlQzLjUxJyxcbiAgICAgICAgICAgICdOVCA0LjAnICAgIDogJ05UNC4wJyxcbiAgICAgICAgICAgICcyMDAwJyAgICAgIDogJ05UIDUuMCcsXG4gICAgICAgICAgICAnWFAnICAgICAgICA6IFsnTlQgNS4xJywgJ05UIDUuMiddLFxuICAgICAgICAgICAgJ1Zpc3RhJyAgICAgOiAnTlQgNi4wJyxcbiAgICAgICAgICAgICc3JyAgICAgICAgIDogJ05UIDYuMScsXG4gICAgICAgICAgICAnOCcgICAgICAgICA6ICdOVCA2LjInLFxuICAgICAgICAgICAgJzguMScgICAgICAgOiAnTlQgNi4zJyxcbiAgICAgICAgICAgICcxMCcgICAgICAgIDogWydOVCA2LjQnLCAnTlQgMTAuMCddLFxuICAgICAgICAgICAgJ1JUJyAgICAgICAgOiAnQVJNJ1xuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIFJlZ2V4IG1hcFxuICAgIC8vLy8vLy8vLy8vLy9cblxuICAgIHZhciByZWdleGVzID0ge1xuXG4gICAgICAgIGJyb3dzZXIgOiBbW1xuXG4gICAgICAgICAgICAvXFxiKD86Y3Jtb3xjcmlvcylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQvaU9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdDaHJvbWUnXV0sIFtcbiAgICAgICAgICAgIC9lZGcoPzplfGlvc3xhKT9cXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEVkZ2VcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0VkZ2UnXV0sIFtcblxuICAgICAgICAgICAgLy8gUHJlc3RvIGJhc2VkXG4gICAgICAgICAgICAvKG9wZXJhIG1pbmkpXFwvKFstXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1pbmlcbiAgICAgICAgICAgIC8ob3BlcmEgW21vYmlsZXRhYl17Myw2fSlcXGIuK3ZlcnNpb25cXC8oWy1cXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1vYmkvVGFibGV0XG4gICAgICAgICAgICAvKG9wZXJhKSg/Oi4rdmVyc2lvblxcL3xbXFwvIF0rKShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvb3Bpb3NbXFwvIF0rKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIG1pbmkgb24gaXBob25lID49IDguMFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBPUEVSQSsnIE1pbmknXV0sIFtcbiAgICAgICAgICAgIC9cXGJvcHJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFdlYmtpdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBPUEVSQV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1peGVkXG4gICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgLyhsdW5hc2NhcGV8bWF4dGhvbnxuZXRmcm9udHxqYXNtaW5lfGJsYXplcilbXFwvIF0/KFtcXHdcXC5dKikvaSwgICAgICAvLyBMdW5hc2NhcGUvTWF4dGhvbi9OZXRmcm9udC9KYXNtaW5lL0JsYXplclxuICAgICAgICAgICAgLy8gVHJpZGVudCBiYXNlZFxuICAgICAgICAgICAgLyhhdmFudCB8aWVtb2JpbGV8c2xpbSkoPzpicm93c2VyKT9bXFwvIF0/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAvLyBBdmFudC9JRU1vYmlsZS9TbGltQnJvd3NlclxuICAgICAgICAgICAgLyhiYT9pZHVicm93c2VyKVtcXC8gXT8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWlkdSBCcm93c2VyXG4gICAgICAgICAgICAvKD86bXN8XFwoKShpZSkgKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICAgICAgICAgIC8vIFdlYmtpdC9LSFRNTCBiYXNlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvY2svUm9ja01lbHQvTWlkb3JpL0VwaXBoYW55L1NpbGsvU2t5ZmlyZS9Cb2x0L0lyb24vSXJpZGl1bS9QaGFudG9tSlMvQm93c2VyL1F1cFppbGxhL0ZhbGtvblxuICAgICAgICAgICAgLyhmbG9ja3xyb2NrbWVsdHxtaWRvcml8ZXBpcGhhbnl8c2lsa3xza3lmaXJlfG92aWJyb3dzZXJ8Ym9sdHxpcm9ufHZpdmFsZGl8aXJpZGl1bXxwaGFudG9tanN8Ym93c2VyfHF1YXJrfHF1cHppbGxhfGZhbGtvbnxyZWtvbnF8cHVmZmlufGJyYXZlfHdoYWxlfHFxYnJvd3NlcmxpdGV8cXF8ZHVja2R1Y2tnbylcXC8oWy1cXHdcXC5dKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVrb25xL1B1ZmZpbi9CcmF2ZS9XaGFsZS9RUUJyb3dzZXJMaXRlL1FRLCBha2EgU2hvdVFcbiAgICAgICAgICAgIC8od2VpYm8pX18oW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWlib1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKD86XFxidWM/ID9icm93c2VyfCg/Omp1Yy4rKXVjd2ViKVtcXC8gXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAvLyBVQ0Jyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1VDJytCUk9XU0VSXV0sIFtcbiAgICAgICAgICAgIC9taWNyb20uK1xcYnFiY29yZVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdCBEZXNrdG9wIGZvciBXaW5kb3dzIEJ1aWx0LWluIEJyb3dzZXJcbiAgICAgICAgICAgIC9cXGJxYmNvcmVcXC8oW1xcd1xcLl0rKS4rbWljcm9tL2lcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1dlQ2hhdChXaW4pIERlc2t0b3AnXV0sIFtcbiAgICAgICAgICAgIC9taWNyb21lc3NlbmdlclxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2VDaGF0XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdXZUNoYXQnXV0sIFtcbiAgICAgICAgICAgIC9rb25xdWVyb3JcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS29ucXVlcm9yXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdLb25xdWVyb3InXV0sIFtcbiAgICAgICAgICAgIC90cmlkZW50Litydls6IF0oW1xcd1xcLl17MSw5fSlcXGIuK2xpa2UgZ2Vja28vaSAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUxMVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnSUUnXV0sIFtcbiAgICAgICAgICAgIC95YWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWWFuZGV4XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdZYW5kZXgnXV0sIFtcbiAgICAgICAgICAgIC8oYXZhc3R8YXZnKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhc3QvQVZHIFNlY3VyZSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxIFNlY3VyZSAnK0JST1dTRVJdLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL1xcYmZvY3VzXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBGb2N1c1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YKycgRm9jdXMnXV0sIFtcbiAgICAgICAgICAgIC9cXGJvcHRcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFRvdWNoXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgVG91Y2gnXV0sIFtcbiAgICAgICAgICAgIC9jb2NfY29jXFx3K1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvYyBDb2MgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQ29jIENvYyddXSwgW1xuICAgICAgICAgICAgL2RvbGZpblxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2xwaGluXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdEb2xwaGluJ11dLCBbXG4gICAgICAgICAgICAvY29hc3RcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIENvYXN0XG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIE9QRVJBKycgQ29hc3QnXV0sIFtcbiAgICAgICAgICAgIC9taXVpYnJvd3NlclxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNSVVJICcrQlJPV1NFUl1dLCBbXG4gICAgICAgICAgICAvZnhpb3NcXC8oWy1cXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZm9yIGlPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YXV0sIFtcbiAgICAgICAgICAgIC9cXGJxaWh1fChxaT9obz9vP3wzNjApYnJvd3Nlci9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDM2MFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnMzYwICcrQlJPV1NFUl1dLCBbXG4gICAgICAgICAgICAvKG9jdWx1c3xzYW1zdW5nfHNhaWxmaXNofGh1YXdlaSlicm93c2VyXFwvKFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvKC4rKS8sICckMSAnK0JST1dTRVJdLCBWRVJTSU9OXSwgWyAgICAgICAgICAgICAgICAgICAgICAvLyBPY3VsdXMvU2Ftc3VuZy9TYWlsZmlzaC9IdWF3ZWkgQnJvd3NlclxuICAgICAgICAgICAgLyhjb21vZG9fZHJhZ29uKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21vZG8gRHJhZ29uXG4gICAgICAgICAgICBdLCBbW05BTUUsIC9fL2csICcgJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKGVsZWN0cm9uKVxcLyhbXFx3XFwuXSspIHNhZmFyaS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZWN0cm9uLWJhc2VkIEFwcFxuICAgICAgICAgICAgLyh0ZXNsYSkoPzogcXRjYXJicm93c2VyfFxcLygyMFxcZFxcZFxcLlstXFx3XFwuXSspKS9pLCAgICAgICAgICAgICAgICAgICAvLyBUZXNsYVxuICAgICAgICAgICAgL20/KHFxYnJvd3NlcnxiYWlkdWJveGFwcHwyMzQ1RXhwbG9yZXIpW1xcLyBdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAvLyBRUUJyb3dzZXIvQmFpZHUgQXBwLzIzNDUgQnJvd3NlclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKG1ldGFzcilbXFwvIF0/KFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvdUdvdUJyb3dzZXJcbiAgICAgICAgICAgIC8obGJicm93c2VyKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGllQmFvIEJyb3dzZXJcbiAgICAgICAgICAgIC9cXFsobGlua2VkaW4pYXBwXFxdL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5rZWRJbiBBcHAgZm9yIGlPUyAmIEFuZHJvaWRcbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAvLyBXZWJWaWV3XG4gICAgICAgICAgICAvKCg/OmZiYW5cXC9mYmlvc3xmYl9pYWJcXC9mYjRhKSg/IS4rZmJhdil8O2ZiYXZcXC8oW1xcd1xcLl0rKTspL2kgICAgICAgLy8gRmFjZWJvb2sgQXBwIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICBdLCBbW05BTUUsIEZBQ0VCT09LXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9zYWZhcmkgKGxpbmUpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBBcHAgZm9yIGlPU1xuICAgICAgICAgICAgL1xcYihsaW5lKVxcLyhbXFx3XFwuXSspXFwvaWFiL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgQXBwIGZvciBBbmRyb2lkXG4gICAgICAgICAgICAvKGNocm9taXVtfGluc3RhZ3JhbSlbXFwvIF0oWy1cXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9taXVtL0luc3RhZ3JhbVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvXFxiZ3NhXFwvKFtcXHdcXC5dKykgLipzYWZhcmlcXC8vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIFNlYXJjaCBBcHBsaWFuY2Ugb24gaU9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdHU0EnXV0sIFtcblxuICAgICAgICAgICAgL2hlYWRsZXNzY2hyb21lKD86XFwvKFtcXHdcXC5dKyl8ICkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgSGVhZGxlc3NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgQ0hST01FKycgSGVhZGxlc3MnXV0sIFtcblxuICAgICAgICAgICAgLyB3dlxcKS4rKGNocm9tZSlcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIFdlYlZpZXdcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgQ0hST01FKycgV2ViVmlldyddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvZHJvaWQuKyB2ZXJzaW9uXFwvKFtcXHdcXC5dKylcXGIuKyg/Om1vYmlsZSBzYWZhcml8c2FmYXJpKS9pICAgICAgICAgICAvLyBBbmRyb2lkIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0FuZHJvaWQgJytCUk9XU0VSXV0sIFtcblxuICAgICAgICAgICAgLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9ID9icm93c2VyKVxcL3Y/KFtcXHdcXC5dKykvaSAgICAgICAvLyBDaHJvbWUvT21uaVdlYi9Bcm9yYS9UaXplbi9Ob2tpYVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC92ZXJzaW9uXFwvKFtcXHdcXC5cXCxdKykgLiptb2JpbGVcXC9cXHcrIChzYWZhcmkpL2kgICAgICAgICAgICAgICAgICAgICAgLy8gTW9iaWxlIFNhZmFyaVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnTW9iaWxlIFNhZmFyaSddXSwgW1xuICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcdyhcXC58XFwsKV0rKSAuKihtb2JpbGUgP3NhZmFyaXxzYWZhcmkpL2kgICAgICAgICAgICAgICAgLy8gU2FmYXJpICYgU2FmYXJpIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdLCBbXG4gICAgICAgICAgICAvd2Via2l0Lis/KG1vYmlsZSA/c2FmYXJpfHNhZmFyaSkoXFwvW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDMuMFxuICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBzdHJNYXBwZXIsIG9sZFNhZmFyaU1hcF1dLCBbXG5cbiAgICAgICAgICAgIC8od2Via2l0fGtodG1sKVxcLyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvLyBHZWNrbyBiYXNlZFxuICAgICAgICAgICAgLyhuYXZpZ2F0b3J8bmV0c2NhcGVcXGQ/KVxcLyhbLVxcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0c2NhcGVcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ05ldHNjYXBlJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvbW9iaWxlIHZyOyBydjooW1xcd1xcLl0rKVxcKS4rZmlyZWZveC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggUmVhbGl0eVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBGSVJFRk9YKycgUmVhbGl0eSddXSwgW1xuICAgICAgICAgICAgL2VraW9oZi4rKGZsb3cpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbG93XG4gICAgICAgICAgICAvKHN3aWZ0Zm94KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aWZ0Zm94XG4gICAgICAgICAgICAvKGljZWRyYWdvbnxpY2V3ZWFzZWx8Y2FtaW5vfGNoaW1lcmF8ZmVubmVjfG1hZW1vIGJyb3dzZXJ8bWluaW1vfGNvbmtlcm9yfGtsYXIpW1xcLyBdPyhbXFx3XFwuXFwrXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEljZURyYWdvbi9JY2V3ZWFzZWwvQ2FtaW5vL0NoaW1lcmEvRmVubmVjL01hZW1vL01pbmltby9Db25rZXJvci9LbGFyXG4gICAgICAgICAgICAvKHNlYW1vbmtleXxrLW1lbGVvbnxpY2VjYXR8aWNlYXBlfGZpcmViaXJkfHBob2VuaXh8cGFsZW1vb258YmFzaWxpc2t8d2F0ZXJmb3gpXFwvKFstXFx3XFwuXSspJC9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94L1NlYU1vbmtleS9LLU1lbGVvbi9JY2VDYXQvSWNlQXBlL0ZpcmViaXJkL1Bob2VuaXhcbiAgICAgICAgICAgIC8oZmlyZWZveClcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgRmlyZWZveC1iYXNlZFxuICAgICAgICAgICAgLyhtb3ppbGxhKVxcLyhbXFx3XFwuXSspIC4rcnZcXDouK2dlY2tvXFwvXFxkKy9pLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ppbGxhXG5cbiAgICAgICAgICAgIC8vIE90aGVyXG4gICAgICAgICAgICAvKHBvbGFyaXN8bHlueHxkaWxsb3xpY2FifGRvcmlzfGFtYXlhfHczbXxuZXRzdXJmfHNsZWlwbmlyfG9iaWdvfG1vc2FpY3woPzpnb3xpY2V8dXApW1xcLiBdP2Jyb3dzZXIpWy1cXC8gXT92PyhbXFx3XFwuXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvbGFyaXMvTHlueC9EaWxsby9pQ2FiL0RvcmlzL0FtYXlhL3czbS9OZXRTdXJmL1NsZWlwbmlyL09iaWdvL01vc2FpYy9Hby9JQ0UvVVAuQnJvd3NlclxuICAgICAgICAgICAgLyhsaW5rcykgXFwoKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5rc1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8oY29iYWx0KVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29iYWx0XG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIC9tYXN0ZXIufGx0cy4vLCBcIlwiXV1cbiAgICAgICAgXSxcblxuICAgICAgICBjcHUgOiBbW1xuXG4gICAgICAgICAgICAvKD86KGFtZHx4KD86KD86ODZ8NjQpWy1fXSk/fHdvd3x3aW4pNjQpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAvLyBBTUQ2NCAoeDY0KVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhbWQ2NCddXSwgW1xuXG4gICAgICAgICAgICAvKGlhMzIoPz07KSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzIgKHF1aWNrdGltZSlcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCBsb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8oKD86aVszNDZdfHgpODYpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzIgKHg4NilcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnaWEzMiddXSwgW1xuXG4gICAgICAgICAgICAvXFxiKGFhcmNoNjR8YXJtKHY/OGU/bD98Xz82NCkpXFxiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBUk02NFxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhcm02NCddXSwgW1xuXG4gICAgICAgICAgICAvXFxiKGFybSg/OnZbNjddKT9odD9uP1tmbF1wPylcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVJNSEZcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtaGYnXV0sIFtcblxuICAgICAgICAgICAgLy8gUG9ja2V0UEMgbWlzdGFrZW5seSBpZGVudGlmaWVkIGFzIFBvd2VyUENcbiAgICAgICAgICAgIC93aW5kb3dzIChjZXxtb2JpbGUpOyBwcGM7L2lcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtJ11dLCBbXG5cbiAgICAgICAgICAgIC8oKD86cHBjfHBvd2VycGMpKD86NjQpPykoPzogbWFjfDt8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvd2VyUENcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAvb3dlci8sIEVNUFRZLCBsb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8oc3VuNFxcdylbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTUEFSQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdzcGFyYyddXSwgW1xuXG4gICAgICAgICAgICAvKCg/OmF2cjMyfGlhNjQoPz07KSl8NjhrKD89XFwpKXxcXGJhcm0oPz12KD86WzEtN118WzUtN10xKWw/fDt8ZWFiaSl8KD89YXRtZWwgKWF2cnwoPzppcml4fG1pcHN8c3BhcmMpKD86NjQpP1xcYnxwYS1yaXNjKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBNjQsIDY4SywgQVJNLzY0LCBBVlIvMzIsIElSSVgvNjQsIE1JUFMvNjQsIFNQQVJDLzY0LCBQQS1SSVNDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgbG93ZXJpemVdXVxuICAgICAgICBdLFxuXG4gICAgICAgIGRldmljZSA6IFtbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBNT0JJTEVTICYgVEFCTEVUU1xuICAgICAgICAgICAgLy8gT3JkZXJlZCBieSBwb3B1bGFyaXR5XG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC8vIFNhbXN1bmdcbiAgICAgICAgICAgIC9cXGIoc2NoLWlbODldMFxcZHxzaHctbTM4MHN8c20tW3B0eF1cXHd7Miw0fXxndC1bcG5dXFxkezIsNH18c2doLXQ4WzU2XTl8bmV4dXMgMTApL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU0FNU1VOR10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYigoPzpzW2NncF1ofGd0fHNtKS1cXHcrfGdhbGF4eSBuZXh1cykvaSxcbiAgICAgICAgICAgIC9zYW1zdW5nWy0gXShbLVxcd10rKS9pLFxuICAgICAgICAgICAgL3NlYy0oc2doXFx3KykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTQU1TVU5HXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEFwcGxlXG4gICAgICAgICAgICAvXFwoKGlwKD86aG9uZXxvZClbXFx3IF0qKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBvZC9pUGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVBQTEVdLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXCgoaXBhZCk7Wy1cXHdcXCksOyBdK2FwcGxlL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBhZFxuICAgICAgICAgICAgL2FwcGxlY29yZW1lZGlhXFwvW1xcd1xcLl0rIFxcKChpcGFkKS9pLFxuICAgICAgICAgICAgL1xcYihpcGFkKVxcZFxcZD8sXFxkXFxkP1s7XFxdXS4raW9zL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVBQTEVdLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8obWFjaW50b3NoKTsvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBUFBMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEh1YXdlaVxuICAgICAgICAgICAgL1xcYigoPzphZ1tyc11bMjNdP3xiYWgyP3xzaHQ/fGJ0diktYT9bbHddXFxkezJ9KVxcYig/IS4rZFxcL3MpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgSFVBV0VJXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKD86aHVhd2VpfGhvbm9yKShbLVxcdyBdKylbO1xcKV0vaSxcbiAgICAgICAgICAgIC9cXGIobmV4dXMgNnB8XFx3ezIsNH1lPy1bYXR1XT9bbG5dW1xcZHhdWzAxMjM1OWNdW2Fkbl0/KVxcYig/IS4rZFxcL3MpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgSFVBV0VJXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIFhpYW9taVxuICAgICAgICAgICAgL1xcYihwb2NvW1xcdyBdKykoPzogYnVpfFxcKSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBYaWFvbWkgUE9DT1xuICAgICAgICAgICAgL1xcYjsgKFxcdyspIGJ1aWxkXFwvaG1cXDEvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIEhvbmdtaSAnbnVtZXJpYycgbW9kZWxzXG4gICAgICAgICAgICAvXFxiKGhtWy1fIF0/bm90ZT9bXyBdPyg/OlxcZFxcdyk/KSBidWkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWlcbiAgICAgICAgICAgIC9cXGIocmVkbWlbXFwtXyBdPyg/Om5vdGV8ayk/W1xcd18gXSspKD86IGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBSZWRtaVxuICAgICAgICAgICAgL1xcYihtaVstXyBdPyg/OmFcXGR8b25lfG9uZVtfIF1wbHVzfG5vdGUgbHRlfG1heHxjYyk/W18gXT8oPzpcXGQ/XFx3PylbXyBdPyg/OnBsdXN8c2V8bGl0ZSk/KSg/OiBidWl8XFwpKS9pIC8vIFhpYW9taSBNaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgWElBT01JXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKG1pWy1fIF0/KD86cGFkKSg/OltcXHdfIF0rKSkoPzogYnVpfFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pIFBhZCB0YWJsZXRzXG4gICAgICAgICAgICBdLFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsIFhJQU9NSV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvLyBPUFBPXG4gICAgICAgICAgICAvOyAoXFx3KykgYnVpLisgb3Bwby9pLFxuICAgICAgICAgICAgL1xcYihjcGhbMTJdXFxkezN9fHAoPzphZnxjW2FsXXxkXFx3fGVbYXJdKVttdF1cXGQwfHg5MDA3fGExMDFvcClcXGIvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnT1BQTyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gVml2b1xuICAgICAgICAgICAgL3Zpdm8gKFxcdyspKD86IGJ1aXxcXCkpL2ksXG4gICAgICAgICAgICAvXFxiKHZbMTJdXFxkezN9XFx3P1thdF0pKD86IGJ1aXw7KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdWaXZvJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBSZWFsbWVcbiAgICAgICAgICAgIC9cXGIocm14WzEyXVxcZHszfSkoPzogYnVpfDt8XFwpKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSZWFsbWUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1vdG9yb2xhXG4gICAgICAgICAgICAvXFxiKG1pbGVzdG9uZXxkcm9pZCg/OlsyLTR4XXwgKD86YmlvbmljfHgyfHByb3xyYXpyKSk/Oj8oIDRnKT8pXFxiW1xcdyBdK2J1aWxkXFwvL2ksXG4gICAgICAgICAgICAvXFxibW90KD86b3JvbGEpP1stIF0oXFx3KikvaSxcbiAgICAgICAgICAgIC8oKD86bW90b1tcXHdcXChcXCkgXSt8eHRcXGR7Myw0fXxuZXh1cyA2KSg/PSBidWl8XFwpKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBNT1RPUk9MQV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihtejYwXFxkfHhvb21bMiBdezAsMn0pIGJ1aWxkXFwvL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTU9UT1JPTEFdLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLy8gTEdcbiAgICAgICAgICAgIC8oKD89bGcpP1t2bF1rXFwtP1xcZHszfSkgYnVpfCAzXFwuWy1cXHc7IF17MTB9bGc/LShbMDZjdjldezMsNH0pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTEddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8obG0oPzotP2YxMDBbbnZdP3wtW1xcd1xcLl0rKSg/PSBidWl8XFwpKXxuZXh1cyBbNDVdKS9pLFxuICAgICAgICAgICAgL1xcYmxnWy1lO1xcLyBdKygoPyFicm93c2VyfG5ldGNhc3R8YW5kcm9pZCB0dilcXHcrKS9pLFxuICAgICAgICAgICAgL1xcYmxnLT8oW1xcZFxcd10rKSBidWkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBMR10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBMZW5vdm9cbiAgICAgICAgICAgIC8oaWRlYXRhYlstXFx3IF0rKS9pLFxuICAgICAgICAgICAgL2xlbm92byA/KHNbNTZdMDAwWy1cXHddK3x0YWIoPzpbXFx3IF0rKXx5dFstXFxkXFx3XXs2fXx0YlstXFxkXFx3XXs2fSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTGVub3ZvJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvLyBOb2tpYVxuICAgICAgICAgICAgLyg/Om1hZW1vfG5va2lhKS4qKG45MDB8bHVtaWEgXFxkKykvaSxcbiAgICAgICAgICAgIC9ub2tpYVstXyBdPyhbLVxcd1xcLl0qKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXy9nLCAnICddLCBbVkVORE9SLCAnTm9raWEnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEdvb2dsZVxuICAgICAgICAgICAgLyhwaXhlbCBjKVxcYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIFBpeGVsIENcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgR09PR0xFXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKHBpeGVsW1xcZGF4bCBdezAsNn0pKD86IGJ1aXxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIFBpeGVsXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEdPT0dMRV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBTb255XG4gICAgICAgICAgICAvZHJvaWQuKyAoYT9cXGRbMC0yXXsyfXNvfFtjLWddXFxkezR9fHNvWy1nbF1cXHcrfHhxLWFcXHdbNC03XVsxMl0pKD89IGJ1aXxcXCkuK2Nocm9tZVxcLyg/IVsxLTZdezAsMX1cXGRcXC4pKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNPTlldLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9zb255IHRhYmxldCBbcHNdL2ksXG4gICAgICAgICAgICAvXFxiKD86c29ueSk/c2dwXFx3Kyg/OiBidWl8XFwpKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE9uZVBsdXNcbiAgICAgICAgICAgIC8gKGtiMjAwNXxpbjIwWzEyXTV8YmUyMFsxMl1bNTldKVxcYi9pLFxuICAgICAgICAgICAgLyg/Om9uZSk/KD86cGx1cyk/IChhXFxkMFxcZFxcZCkoPzogYnxcXCkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ09uZVBsdXMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEFtYXpvblxuICAgICAgICAgICAgLyhhbGV4YSl3ZWJtL2ksXG4gICAgICAgICAgICAvKGtmW2Etel17Mn13aSkoIGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSB3aXRob3V0IFNpbGtcbiAgICAgICAgICAgIC8oa2ZbYS16XSspKCBidWl8XFwpKS4rc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSBIRFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oKD86c2R8a2YpWzAzNDloaWpvcnN0dXddKykoIGJ1aXxcXCkpLitzaWxrXFwvL2kgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFBob25lXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvKC4rKS9nLCAnRmlyZSBQaG9uZSAkMSddLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQmxhY2tCZXJyeVxuICAgICAgICAgICAgLyhwbGF5Ym9vayk7Wy1cXHdcXCksOyBdKyhyaW0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgUGxheUJvb2tcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKD86YmJbYS1mXXxzdFtodl0pMTAwLVxcZCkvaSxcbiAgICAgICAgICAgIC9cXChiYjEwOyAoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEJMQUNLQkVSUlldLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQXN1c1xuICAgICAgICAgICAgLyg/OlxcYnxhc3VzXykodHJhbnNmb1twcmltZSBdezQsMTB9IFxcdyt8ZWVlcGN8c2xpZGVyIFxcdyt8bmV4dXMgN3xwYWRmb25lfHAwMFtjal0pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVNVU10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyAoeltiZXNdNlswMjddWzAxMl1ba21dW2xzXXx6ZW5mb25lIFxcZFxcdz8pXFxiL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQVNVU10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBIVENcbiAgICAgICAgICAgIC8obmV4dXMgOSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDIE5leHVzIDlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0hUQyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oaHRjKVstO18gXXsxLDJ9KFtcXHcgXSsoPz1cXCl8IGJ1aSl8XFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDXG5cbiAgICAgICAgICAgIC8vIFpURVxuICAgICAgICAgICAgLyh6dGUpWy0gXShbXFx3IF0rPykoPzogYnVpfFxcL3xcXCkpL2ksXG4gICAgICAgICAgICAvKGFsY2F0ZWx8Z2Vla3NwaG9uZXxuZXhpYW58cGFuYXNvbmljfHNvbnkoPyEtYnJhKSlbLV8gXT8oWy1cXHddKikvaSAgICAgICAgIC8vIEFsY2F0ZWwvR2Vla3NQaG9uZS9OZXhpYW4vUGFuYXNvbmljL1NvbnlcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtNT0RFTCwgL18vZywgJyAnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEFjZXJcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoW2FiXVsxLTddLT9bMDE3OGFdXFxkXFxkPykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQWNlciddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLy8gTWVpenVcbiAgICAgICAgICAgIC9kcm9pZC4rOyAobVsxLTVdIG5vdGUpIGJ1aS9pLFxuICAgICAgICAgICAgL1xcYm16LShbLVxcd117Mix9KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNZWl6dSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gU2hhcnBcbiAgICAgICAgICAgIC9cXGIoc2gtP1thbHR2el0/XFxkXFxkW2EtZWttXT8pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU0hBUlBdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gTUlYRURcbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeXxiZW5xfHBhbG0oPz1cXC0pfHNvbnllcmljc3NvbnxhY2VyfGFzdXN8ZGVsbHxtZWl6dXxtb3Rvcm9sYXxwb2x5dHJvbilbLV8gXT8oWy1cXHddKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeS9CZW5RL1BhbG0vU29ueS1Fcmljc3Nvbi9BY2VyL0FzdXMvRGVsbC9NZWl6dS9Nb3Rvcm9sYS9Qb2x5dHJvblxuICAgICAgICAgICAgLyhocCkgKFtcXHcgXStcXHcpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhQIGlQQVFcbiAgICAgICAgICAgIC8oYXN1cyktPyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzdXNcbiAgICAgICAgICAgIC8obWljcm9zb2Z0KTsgKGx1bWlhW1xcdyBdKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBMdW1pYVxuICAgICAgICAgICAgLyhsZW5vdm8pWy1fIF0/KFstXFx3XSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVub3ZvXG4gICAgICAgICAgICAvKGpvbGxhKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvbGxhXG4gICAgICAgICAgICAvKG9wcG8pID8oW1xcdyBdKykgYnVpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPUFBPXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8oYXJjaG9zKSAoZ2FtZXBhZDI/KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJjaG9zXG4gICAgICAgICAgICAvKGhwKS4rKHRvdWNocGFkKD8hLit0YWJsZXQpfHRhYmxldCkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhQIFRvdWNoUGFkXG4gICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgLyhub29rKVtcXHcgXStidWlsZFxcLyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb29rXG4gICAgICAgICAgICAvKGRlbGwpIChzdHJlYVtrcHJcXGQgXSpbXFxka29dKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBTdHJlYWtcbiAgICAgICAgICAgIC8obGVbLSBdK3BhbilbLSBdKyhcXHd7MSw5fSkgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlIFBhbiBUYWJsZXRzXG4gICAgICAgICAgICAvKHRyaW5pdHkpWy0gXSoodFxcZHszfSkgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmluaXR5IFRhYmxldHNcbiAgICAgICAgICAgIC8oZ2lnYXNldClbLSBdKyhxXFx3ezEsOX0pIGJ1aS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpZ2FzZXQgVGFibGV0c1xuICAgICAgICAgICAgLyh2b2RhZm9uZSkgKFtcXHcgXSspKD86XFwpfCBidWkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZvZGFmb25lXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oc3VyZmFjZSBkdW8pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VyZmFjZSBEdW9cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTUlDUk9TT0ZUXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvZHJvaWQgW1xcZFxcLl0rOyAoZnBcXGR1PykoPzogYnxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlycGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0ZhaXJwaG9uZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8odTMwNGFhKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVQmVFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQVQmVCddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGJzaWUtKFxcdyopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaWVtZW5zXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaWVtZW5zJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihyY3RcXHcrKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJDQSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSQ0EnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKHZlbnVlW1xcZCBdezIsN30pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBWZW51ZSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdEZWxsJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihxKD86bXZ8dGEpXFx3KykgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcml6b24gVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdWZXJpem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYig/OmJhcm5lc1smIF0rbm9ibGUgfGJuW3J0XSkoW1xcd1xcKyBdKikgYi9pICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXJuZXMgJiBOb2JsZSBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0Jhcm5lcyAmIE5vYmxlJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYih0bVxcZHszfVxcdyspIGIvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnVWaXNpb24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKGs4OCkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgSyBTZXJpZXMgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKG54XFxkezN9aikgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFIE51YmlhXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKGdlblxcZHszfSkgYi4rNDloL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgR0VOIE1vYmlsZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU3dpc3MnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHp1clxcZHszfSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgWlVSIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU3dpc3MnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKCh6ZWtpKT90Yi4qXFxiKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWmVraSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaZWtpJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihbeXJdXFxkezJ9KSBiL2ksXG4gICAgICAgICAgICAvXFxiKGRyYWdvblstIF0rdG91Y2ggfGR0KShcXHd7NX0pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHJhZ29uIFRvdWNoIFRhYmxldFxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdEcmFnb24gVG91Y2gnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihucy0/XFx3ezAsOX0pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2lnbmlhIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0luc2lnbmlhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYigobnhhfG5leHQpLT9cXHd7MCw5fSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHRCb29rIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ05leHRCb29rJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYih4dHJlbWVcXF8pPyh2KDFbMDQ1XXwyWzAxNV18WzM0NjldMHw3WzA1XSkpIGIvaSAgICAgICAgICAgICAgICAgIC8vIFZvaWNlIFh0cmVtZSBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnVm9pY2UnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihsdnRlbFxcLSk/KHYxWzEyXSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEx2VGVsIFBob25lc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdMdlRlbCddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxiKHBoLTEpIC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWwgUEgtMVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRXNzZW50aWFsJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYih2KDEwMG1kfDcwMG5hfDcwMTF8OTE3ZykuKlxcYikgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVudml6ZW4gVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRW52aXplbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIodHJpb1stXFx3XFwuIF0rKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjaFNwZWVkIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01hY2hTcGVlZCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGJ0dV8oMTQ5MSkgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdG9yIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JvdG9yJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhzaGllbGRbXFx3IF0rKSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnZpZGlhIFNoaWVsZCBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOdmlkaWEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKHNwcmludCkgKFxcdyspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcHJpbnQgUGhvbmVzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKGtpblxcLltvbmV0d117M30pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgS2luXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXFwuL2csICcgJ10sIFtWRU5ET1IsIE1JQ1JPU09GVF0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7IChjYzY2NjY/fGV0NVsxNl18bWNbMjM5XVsyM114P3x2YzhbMDNdeD8pXFwpL2kgICAgICAgICAgICAgLy8gWmVicmFcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgWkVCUkFdLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoZWMzMHxwczIwfHRjWzItOF1cXGRba3hdKVxcKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFpFQlJBXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIENPTlNPTEVTXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC8ob3V5YSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V5YVxuICAgICAgICAgICAgLyhuaW50ZW5kbykgKFt3aWRzM3V0Y2hdKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOaW50ZW5kb1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoc2hpZWxkKSBidWkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnZpZGlhXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOdmlkaWEnXSwgW1RZUEUsIENPTlNPTEVdXSwgW1xuICAgICAgICAgICAgLyhwbGF5c3RhdGlvbiBbMzQ1cG9ydGFibGV2aV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGF5c3RhdGlvblxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIENPTlNPTEVdXSwgW1xuICAgICAgICAgICAgL1xcYih4Ym94KD86IG9uZSk/KD8hOyB4Ym94KSlbXFwpOyBdL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBYYm94XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE1JQ1JPU09GVF0sIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gU01BUlRUVlNcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgL3NtYXJ0LXR2Lisoc2Ftc3VuZykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvaGJidHYuK21hcGxlOyhcXGQrKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXi8sICdTbWFydFRWJ10sIFtWRU5ET1IsIFNBTVNVTkddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvKG51eDsgbmV0Y2FzdC4rc21hcnR0dnxsZyAobmV0Y2FzdFxcLnR2LTIwMVxcZHxhbmRyb2lkIHR2KSkvaSAgICAgICAgLy8gTEcgU21hcnRUVlxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIExHXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgLyhhcHBsZSkgP3R2L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsZSBUVlxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgW01PREVMLCBBUFBMRSsnIFRWJ10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9jcmtleS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIENocm9tZWNhc3RcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIENIUk9NRSsnY2FzdCddLCBbVkVORE9SLCBHT09HTEVdLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuK2FmdChcXHcpKCBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBUVlxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBTUFaT05dLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvXFwoZHR2W1xcKTtdLisoYXF1b3MpL2ksXG4gICAgICAgICAgICAvKGFxdW9zLXR2W1xcdyBdKylcXCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhcnBcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU0hBUlBdLCBbVFlQRSwgU01BUlRUVl1dLFtcbiAgICAgICAgICAgIC8oYnJhdmlhW1xcdyBdKykoIGJ1aXxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgLyhtaXR2LVxcd3s1fSkgYnVpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFhJQU9NSV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9cXGIocm9rdSlbXFxkeF0qW1xcKVxcL10oKD86ZHZwLSk/W1xcZFxcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9rdVxuICAgICAgICAgICAgL2hiYnR2XFwvXFxkK1xcLlxcZCtcXC5cXGQrICtcXChbXFx3IF0qOyAqKFxcd1teO10qKTsoW147XSopL2kgICAgICAgICAgICAgICAvLyBIYmJUViBkZXZpY2VzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgdHJpbV0sIFtNT0RFTCwgdHJpbV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC9cXGIoYW5kcm9pZCB0dnxzbWFydFstIF0/dHZ8b3BlcmEgdHZ8dHY7IHJ2OilcXGIvaSAgICAgICAgICAgICAgICAgICAvLyBTbWFydFRWIGZyb20gVW5pZGVudGlmaWVkIFZlbmRvcnNcbiAgICAgICAgICAgIF0sIFtbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIFdFQVJBQkxFU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvKChwZWJibGUpKWFwcC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlYmJsZVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKGdsYXNzKSBcXGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgR2xhc3NcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgR09PR0xFXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAod3Q2Mz8wezIsM30pXFwpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgWkVCUkFdLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgLyhxdWVzdCggMik/KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPY3VsdXMgUXVlc3RcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgRkFDRUJPT0tdLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBFTUJFRERFRFxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvKHRlc2xhKSg/OiBxdGNhcmJyb3dzZXJ8XFwvWy1cXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlc2xhXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbVFlQRSwgRU1CRURERURdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gTUlYRUQgKEdFTkVSSUMpXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC9kcm9pZCAuKz87IChbXjtdKz8pKD86IGJ1aXxcXCkgYXBwbGV3KS4rPyBtb2JpbGUgc2FmYXJpL2kgICAgICAgICAgIC8vIEFuZHJvaWQgUGhvbmVzIGZyb20gVW5pZGVudGlmaWVkIFZlbmRvcnNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvZHJvaWQgLis/OyAoW147XSs/KSg/OiBidWl8XFwpIGFwcGxldykuKz8oPyEgbW9iaWxlKSBzYWZhcmkvaSAgICAgICAvLyBBbmRyb2lkIFRhYmxldHMgZnJvbSBVbmlkZW50aWZpZWQgVmVuZG9yc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKHRhYmxldHx0YWIpWztcXC9dfGZvY3VzXFwvXFxkKD8hLittb2JpbGUpKS9pICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWRlbnRpZmlhYmxlIFRhYmxldFxuICAgICAgICAgICAgXSwgW1tUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhwaG9uZXxtb2JpbGUoPzpbO1xcL118IFsgXFx3XFwvXFwuXSpzYWZhcmkpfHBkYSg/PS4rd2luZG93cyBjZSkpL2kgICAgLy8gVW5pZGVudGlmaWFibGUgTW9iaWxlXG4gICAgICAgICAgICBdLCBbW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKGFuZHJvaWRbLVxcd1xcLiBdezAsOX0pOy4rYnVpbC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJpYyBBbmRyb2lkIERldmljZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR2VuZXJpYyddXVxuICAgICAgICBdLFxuXG4gICAgICAgIGVuZ2luZSA6IFtbXG5cbiAgICAgICAgICAgIC93aW5kb3dzLisgZWRnZVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFZGdlSFRNTFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBFREdFKydIVE1MJ11dLCBbXG5cbiAgICAgICAgICAgIC93ZWJraXRcXC81MzdcXC4zNi4rY2hyb21lXFwvKD8hMjcpKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGlua1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQmxpbmsnXV0sIFtcblxuICAgICAgICAgICAgLyhwcmVzdG8pXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVzdG9cbiAgICAgICAgICAgIC8od2Via2l0fHRyaWRlbnR8bmV0ZnJvbnR8bmV0c3VyZnxhbWF5YXxseW54fHczbXxnb2FubmEpXFwvKFtcXHdcXC5dKykvaSwgLy8gV2ViS2l0L1RyaWRlbnQvTmV0RnJvbnQvTmV0U3VyZi9BbWF5YS9MeW54L3czbS9Hb2FubmFcbiAgICAgICAgICAgIC9la2lvaChmbG93KVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvd1xuICAgICAgICAgICAgLyhraHRtbHx0YXNtYW58bGlua3MpW1xcLyBdXFwoPyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS0hUTUwvVGFzbWFuL0xpbmtzXG4gICAgICAgICAgICAvKGljYWIpW1xcLyBdKFsyM11cXC5bXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpQ2FiXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3J2XFw6KFtcXHdcXC5dezEsOX0pXFxiLisoZ2Vja28pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja29cbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXVxuICAgICAgICBdLFxuXG4gICAgICAgIG9zIDogW1tcblxuICAgICAgICAgICAgLy8gV2luZG93c1xuICAgICAgICAgICAgL21pY3Jvc29mdCAod2luZG93cykgKHZpc3RhfHhwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIChpVHVuZXMpXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8od2luZG93cykgbnQgNlxcLjI7IChhcm0pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgUlRcbiAgICAgICAgICAgIC8od2luZG93cyAoPzpwaG9uZSg/OiBvcyk/fG1vYmlsZSkpW1xcLyBdPyhbXFxkXFwuXFx3IF0qKS9pLCAgICAgICAgICAgIC8vIFdpbmRvd3MgUGhvbmVcbiAgICAgICAgICAgIC8od2luZG93cylbXFwvIF0/KFtudGNlXFxkXFwuIF0rXFx3KSg/IS4reGJveCkvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBzdHJNYXBwZXIsIHdpbmRvd3NWZXJzaW9uTWFwXV0sIFtcbiAgICAgICAgICAgIC8od2luKD89M3w5fG4pfHdpbiA5eCApKFtudFxcZFxcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsICdXaW5kb3dzJ10sIFtWRVJTSU9OLCBzdHJNYXBwZXIsIHdpbmRvd3NWZXJzaW9uTWFwXV0sIFtcblxuICAgICAgICAgICAgLy8gaU9TL21hY09TXG4gICAgICAgICAgICAvaXBbaG9uZWFkXXsyLDR9XFxiKD86LipvcyAoW1xcd10rKSBsaWtlIG1hY3w7IG9wZXJhKS9pLCAgICAgICAgICAgICAgLy8gaU9TXG4gICAgICAgICAgICAvY2ZuZXR3b3JrXFwvLitkYXJ3aW4vaVxuICAgICAgICAgICAgXSwgW1tWRVJTSU9OLCAvXy9nLCAnLiddLCBbTkFNRSwgJ2lPUyddXSwgW1xuICAgICAgICAgICAgLyhtYWMgb3MgeCkgPyhbXFx3XFwuIF0qKS9pLFxuICAgICAgICAgICAgLyhtYWNpbnRvc2h8bWFjX3Bvd2VycGNcXGIpKD8hLitoYWlrdSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjIE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdNYWMgT1MnXSwgW1ZFUlNJT04sIC9fL2csICcuJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIE1vYmlsZSBPU2VzXG4gICAgICAgICAgICAvZHJvaWQgKFtcXHdcXC5dKylcXGIuKyhhbmRyb2lkWy0gXXg4NnxoYXJtb255b3MpL2kgICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQteDg2L0hhcm1vbnlPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdLCBbICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkL1dlYk9TL1FOWC9CYWRhL1JJTS9NYWVtby9NZWVHby9TYWlsZmlzaCBPU1xuICAgICAgICAgICAgLyhhbmRyb2lkfHdlYm9zfHFueHxiYWRhfHJpbSB0YWJsZXQgb3N8bWFlbW98bWVlZ298c2FpbGZpc2gpWy1cXC8gXT8oW1xcd1xcLl0qKS9pLFxuICAgICAgICAgICAgLyhibGFja2JlcnJ5KVxcdypcXC8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tiZXJyeVxuICAgICAgICAgICAgLyh0aXplbnxrYWlvcylbXFwvIF0oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaXplbi9LYWlPU1xuICAgICAgICAgICAgL1xcKChzZXJpZXM0MCk7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VyaWVzIDQwXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9cXChiYigxMCk7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgQkxBQ0tCRVJSWV1dLCBbXG4gICAgICAgICAgICAvKD86c3ltYmlhbiA/b3N8c3ltYm9zfHM2MCg/PTspfHNlcmllczYwKVstXFwvIF0/KFtcXHdcXC5dKikvaSAgICAgICAgIC8vIFN5bWJpYW5cbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1N5bWJpYW4nXV0sIFtcbiAgICAgICAgICAgIC9tb3ppbGxhXFwvW1xcZFxcLl0rIFxcKCg/Om1vYmlsZXx0YWJsZXR8dHZ8bW9iaWxlOyBbXFx3IF0rKTsgcnY6LisgZ2Vja29cXC8oW1xcd1xcLl0rKS9pIC8vIEZpcmVmb3ggT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgRklSRUZPWCsnIE9TJ11dLCBbXG4gICAgICAgICAgICAvd2ViMHM7LitydCh0dikvaSxcbiAgICAgICAgICAgIC9cXGIoPzpocCk/d29zKD86YnJvd3Nlcik/XFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlYk9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICd3ZWJPUyddXSwgW1xuXG4gICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgL2Nya2V5XFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBDSFJPTUUrJ2Nhc3QnXV0sIFtcbiAgICAgICAgICAgIC8oY3JvcykgW1xcd10rIChbXFx3XFwuXStcXHcpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9taXVtIE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdDaHJvbWl1bSBPUyddLCBWRVJTSU9OXSxbXG5cbiAgICAgICAgICAgIC8vIENvbnNvbGVcbiAgICAgICAgICAgIC8obmludGVuZG98cGxheXN0YXRpb24pIChbd2lkczM0NXBvcnRhYmxldnVjaF0rKS9pLCAgICAgICAgICAgICAgICAgLy8gTmludGVuZG8vUGxheXN0YXRpb25cbiAgICAgICAgICAgIC8oeGJveCk7ICt4Ym94IChbXlxcKTtdKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBYYm94ICgzNjAsIE9uZSwgWCwgUywgU2VyaWVzIFgsIFNlcmllcyBTKVxuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgL1xcYihqb2xpfHBhbG0pXFxiID8oPzpvcyk/XFwvPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvbGkvUGFsbVxuICAgICAgICAgICAgLyhtaW50KVtcXC9cXChcXCkgXT8oXFx3KikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWludFxuICAgICAgICAgICAgLyhtYWdlaWF8dmVjdG9ybGludXgpWzsgXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWdlaWEvVmVjdG9yTGludXhcbiAgICAgICAgICAgIC8oW2t4bG5dP3VidW50dXxkZWJpYW58c3VzZXxvcGVuc3VzZXxnZW50b298YXJjaCg/PSBsaW51eCl8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZCA/aGF0fHplbndhbGt8bGlucHVzfHJhc3BiaWFufHBsYW4gOXxtaW5peHxyaXNjIG9zfGNvbnRpa2l8ZGVlcGlufG1hbmphcm98ZWxlbWVudGFyeSBvc3xzYWJheW9ufGxpbnNwaXJlKSg/OiBnbnVcXC9saW51eCk/KD86IGVudGVycHJpc2UpPyg/OlstIF1saW51eCk/KD86LWdudSk/Wy1cXC8gXT8oPyFjaHJvbXxwYWNrYWdlKShbLVxcd1xcLl0qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVYnVudHUvRGViaWFuL1NVU0UvR2VudG9vL0FyY2gvU2xhY2t3YXJlL0ZlZG9yYS9NYW5kcml2YS9DZW50T1MvUENMaW51eE9TL1JlZEhhdC9aZW53YWxrL0xpbnB1cy9SYXNwYmlhbi9QbGFuOS9NaW5peC9SSVNDT1MvQ29udGlraS9EZWVwaW4vTWFuamFyby9lbGVtZW50YXJ5L1NhYmF5b24vTGluc3BpcmVcbiAgICAgICAgICAgIC8oaHVyZHxsaW51eCkgPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIdXJkL0xpbnV4XG4gICAgICAgICAgICAvKGdudSkgPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR05VXG4gICAgICAgICAgICAvXFxiKFstZnJlbnRvcGNnaHNdezAsNX1ic2R8ZHJhZ29uZmx5KVtcXC8gXT8oPyFhbWR8W2l4MzQ2XXsxLDJ9ODYpKFtcXHdcXC5dKikvaSwgLy8gRnJlZUJTRC9OZXRCU0QvT3BlbkJTRC9QQy1CU0QvR2hvc3RCU0QvRHJhZ29uRmx5XG4gICAgICAgICAgICAvKGhhaWt1KSAoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYWlrdVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHN1bm9zKSA/KFtcXHdcXC5cXGRdKikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1NvbGFyaXMnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oKD86b3Blbik/c29sYXJpcylbLVxcLyBdPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgLyhhaXgpICgoXFxkKSg/PVxcLnxcXCl8IClbXFx3XFwuXSkqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFJWFxuICAgICAgICAgICAgL1xcYihiZW9zfG9zXFwvMnxhbWlnYW9zfG1vcnBob3N8b3BlbnZtc3xmdWNoc2lhfGhwLXV4KS9pLCAgICAgICAgICAgIC8vIEJlT1MvT1MyL0FtaWdhT1MvTW9ycGhPUy9PcGVuVk1TL0Z1Y2hzaWEvSFAtVVhcbiAgICAgICAgICAgIC8odW5peCkgPyhbXFx3XFwuXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVTklYXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cbiAgICAgICAgXVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIENvbnN0cnVjdG9yXG4gICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIFVBUGFyc2VyID0gZnVuY3Rpb24gKHVhLCBleHRlbnNpb25zKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1YSA9PT0gT0JKX1RZUEUpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMgPSB1YTtcbiAgICAgICAgICAgIHVhID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVUFQYXJzZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVBUGFyc2VyKHVhLCBleHRlbnNpb25zKS5nZXRSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdWEgPSB1YSB8fCAoKHR5cGVvZiB3aW5kb3cgIT09IFVOREVGX1RZUEUgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IEVNUFRZKTtcbiAgICAgICAgdmFyIF9yZ3htYXAgPSBleHRlbnNpb25zID8gZXh0ZW5kKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIDogcmVnZXhlcztcblxuICAgICAgICB0aGlzLmdldEJyb3dzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2Jyb3dzZXIgPSB7fTtcbiAgICAgICAgICAgIF9icm93c2VyW05BTUVdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBfYnJvd3NlcltWRVJTSU9OXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2Jyb3dzZXIsIF91YSwgX3JneG1hcC5icm93c2VyKTtcbiAgICAgICAgICAgIF9icm93c2VyLm1ham9yID0gbWFqb3JpemUoX2Jyb3dzZXIudmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gX2Jyb3dzZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9jcHUgPSB7fTtcbiAgICAgICAgICAgIF9jcHVbQVJDSElURUNUVVJFXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2NwdSwgX3VhLCBfcmd4bWFwLmNwdSk7XG4gICAgICAgICAgICByZXR1cm4gX2NwdTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2RldmljZSA9IHt9O1xuICAgICAgICAgICAgX2RldmljZVtWRU5ET1JdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBfZGV2aWNlW01PREVMXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgX2RldmljZVtUWVBFXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2RldmljZSwgX3VhLCBfcmd4bWFwLmRldmljZSk7XG4gICAgICAgICAgICByZXR1cm4gX2RldmljZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2VuZ2luZSA9IHt9O1xuICAgICAgICAgICAgX2VuZ2luZVtOQU1FXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgX2VuZ2luZVtWRVJTSU9OXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgcmd4TWFwcGVyLmNhbGwoX2VuZ2luZSwgX3VhLCBfcmd4bWFwLmVuZ2luZSk7XG4gICAgICAgICAgICByZXR1cm4gX2VuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfb3MgPSB7fTtcbiAgICAgICAgICAgIF9vc1tOQU1FXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgX29zW1ZFUlNJT05dID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfb3MsIF91YSwgX3JneG1hcC5vcyk7XG4gICAgICAgICAgICByZXR1cm4gX29zO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWEgICAgICA6IHRoaXMuZ2V0VUEoKSxcbiAgICAgICAgICAgICAgICBicm93c2VyIDogdGhpcy5nZXRCcm93c2VyKCksXG4gICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICAgICAgb3MgICAgICA6IHRoaXMuZ2V0T1MoKSxcbiAgICAgICAgICAgICAgICBkZXZpY2UgIDogdGhpcy5nZXREZXZpY2UoKSxcbiAgICAgICAgICAgICAgICBjcHUgICAgIDogdGhpcy5nZXRDUFUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdWE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VUEgPSBmdW5jdGlvbiAodWEpIHtcbiAgICAgICAgICAgIF91YSA9ICh0eXBlb2YgdWEgPT09IFNUUl9UWVBFICYmIHVhLmxlbmd0aCA+IFVBX01BWF9MRU5HVEgpID8gdHJpbSh1YSwgVUFfTUFYX0xFTkdUSCkgOiB1YTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFVBKF91YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBVQVBhcnNlci5WRVJTSU9OID0gTElCVkVSU0lPTjtcbiAgICBVQVBhcnNlci5CUk9XU0VSID0gIGVudW1lcml6ZShbTkFNRSwgVkVSU0lPTiwgTUFKT1JdKTtcbiAgICBVQVBhcnNlci5DUFUgPSBlbnVtZXJpemUoW0FSQ0hJVEVDVFVSRV0pO1xuICAgIFVBUGFyc2VyLkRFVklDRSA9IGVudW1lcml6ZShbTU9ERUwsIFZFTkRPUiwgVFlQRSwgQ09OU09MRSwgTU9CSUxFLCBTTUFSVFRWLCBUQUJMRVQsIFdFQVJBQkxFLCBFTUJFRERFRF0pO1xuICAgIFVBUGFyc2VyLkVOR0lORSA9IFVBUGFyc2VyLk9TID0gZW51bWVyaXplKFtOQU1FLCBWRVJTSU9OXSk7XG5cbiAgICAvLy8vLy8vLy8vL1xuICAgIC8vIEV4cG9ydFxuICAgIC8vLy8vLy8vLy9cblxuICAgIC8vIGNoZWNrIGpzIGVudmlyb25tZW50XG4gICAge1xuICAgICAgICAvLyBub2RlanMgZW52XG4gICAgICAgIGlmIChtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5VQVBhcnNlciA9IFVBUGFyc2VyO1xuICAgIH1cblxuICAgIC8vIGpRdWVyeS9aZXB0byBzcGVjaWZpYyAob3B0aW9uYWwpXG4gICAgLy8gTm90ZTpcbiAgICAvLyAgIEluIEFNRCBlbnYgdGhlIGdsb2JhbCBzY29wZSBzaG91bGQgYmUga2VwdCBjbGVhbiwgYnV0IGpRdWVyeSBpcyBhbiBleGNlcHRpb24uXG4gICAgLy8gICBqUXVlcnkgYWx3YXlzIGV4cG9ydHMgdG8gZ2xvYmFsIHNjb3BlLCB1bmxlc3MgalF1ZXJ5Lm5vQ29uZmxpY3QodHJ1ZSkgaXMgdXNlZCxcbiAgICAvLyAgIGFuZCB3ZSBzaG91bGQgY2F0Y2ggdGhhdC5cbiAgICB2YXIgJCA9IHR5cGVvZiB3aW5kb3cgIT09IFVOREVGX1RZUEUgJiYgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvKTtcbiAgICBpZiAoJCAmJiAhJC51YSkge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFVBUGFyc2VyKCk7XG4gICAgICAgICQudWEgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgICQudWEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5nZXRVQSgpO1xuICAgICAgICB9O1xuICAgICAgICAkLnVhLnNldCA9IGZ1bmN0aW9uICh1YSkge1xuICAgICAgICAgICAgcGFyc2VyLnNldFVBKHVhKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICQudWFbcHJvcF0gPSByZXN1bHRbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IGNvbW1vbmpzR2xvYmFsKTtcbn0odWFQYXJzZXIsIHVhUGFyc2VyLmV4cG9ydHMpKTtcblxudmFyIFVBUGFyc2VyID0gdWFQYXJzZXIuZXhwb3J0cztcblxudmFyIG1wNGJveF9hbGwgPSB7fTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4vLyBmaWxlOnNyYy9sb2cuanNcbi8qIFxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTMuIFRlbGVjb20gUGFyaXNUZWNoL1RTSS9NTS9HUEFDIEN5cmlsIENvbmNvbGF0b1xuICogTGljZW5zZTogQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBmaWxlKVxuICovXG52YXIgTG9nID0gKGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG5cdFx0dmFyIExPR19MRVZFTF9FUlJPUiBcdD0gNDtcblx0XHR2YXIgTE9HX0xFVkVMX1dBUk5JTkcgXHQ9IDM7XG5cdFx0dmFyIExPR19MRVZFTF9JTkZPIFx0XHQ9IDI7XG5cdFx0dmFyIExPR19MRVZFTF9ERUJVR1x0XHQ9IDE7XG5cdFx0dmFyIGxvZ19sZXZlbCA9IExPR19MRVZFTF9FUlJPUjtcblx0XHR2YXIgbG9nT2JqZWN0ID0ge1xuXHRcdFx0c2V0TG9nTGV2ZWwgOiBmdW5jdGlvbihsZXZlbCkge1xuXHRcdFx0XHRpZiAobGV2ZWwgPT0gdGhpcy5kZWJ1ZykgbG9nX2xldmVsID0gTE9HX0xFVkVMX0RFQlVHO1xuXHRcdFx0XHRlbHNlIGlmIChsZXZlbCA9PSB0aGlzLmluZm8pIGxvZ19sZXZlbCA9IExPR19MRVZFTF9JTkZPO1xuXHRcdFx0XHRlbHNlIGlmIChsZXZlbCA9PSB0aGlzLndhcm4pIGxvZ19sZXZlbCA9IExPR19MRVZFTF9XQVJOSU5HO1xuXHRcdFx0XHRlbHNlIGlmIChsZXZlbCA9PSB0aGlzLmVycm9yKSBsb2dfbGV2ZWwgPSBMT0dfTEVWRUxfRVJST1I7XG5cdFx0XHRcdGVsc2UgbG9nX2xldmVsID0gTE9HX0xFVkVMX0VSUk9SO1xuXHRcdFx0fSxcblx0XHRcdGRlYnVnIDogZnVuY3Rpb24obW9kdWxlLCBtc2cpIHtcblx0XHRcdFx0aWYgKGNvbnNvbGUuZGVidWcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcgPSBjb25zb2xlLmxvZztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoTE9HX0xFVkVMX0RFQlVHID49IGxvZ19sZXZlbCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoXCJbXCIrTG9nLmdldER1cmF0aW9uU3RyaW5nKG5ldyBEYXRlKCktc3RhcnQsMTAwMCkrXCJdXCIsXCJbXCIrbW9kdWxlK1wiXVwiLG1zZyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsb2cgOiBmdW5jdGlvbihtb2R1bGUsIG1zZykge1xuXHRcdFx0XHR0aGlzLmRlYnVnKG1vZHVsZS5tc2cpO1xuXHRcdFx0fSxcblx0XHRcdGluZm8gOiBmdW5jdGlvbihtb2R1bGUsIG1zZykge1xuXHRcdFx0XHRpZiAoTE9HX0xFVkVMX0lORk8gPj0gbG9nX2xldmVsKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5pbmZvKFwiW1wiK0xvZy5nZXREdXJhdGlvblN0cmluZyhuZXcgRGF0ZSgpLXN0YXJ0LDEwMDApK1wiXVwiLFwiW1wiK21vZHVsZStcIl1cIixtc2cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0d2FybiA6IGZ1bmN0aW9uKG1vZHVsZSwgbXNnKSB7XG5cdFx0XHRcdGlmIChMT0dfTEVWRUxfV0FSTklORyA+PSBsb2dfbGV2ZWwpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJbXCIrTG9nLmdldER1cmF0aW9uU3RyaW5nKG5ldyBEYXRlKCktc3RhcnQsMTAwMCkrXCJdXCIsXCJbXCIrbW9kdWxlK1wiXVwiLG1zZyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRlcnJvciA6IGZ1bmN0aW9uKG1vZHVsZSwgbXNnKSB7XG5cdFx0XHRcdGlmIChMT0dfTEVWRUxfRVJST1IgPj0gbG9nX2xldmVsKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIltcIitMb2cuZ2V0RHVyYXRpb25TdHJpbmcobmV3IERhdGUoKS1zdGFydCwxMDAwKStcIl1cIixcIltcIittb2R1bGUrXCJdXCIsbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGxvZ09iamVjdDtcblx0fSkoKTtcblx0XG4vKiBIZWxwZXIgZnVuY3Rpb24gdG8gcHJpbnQgYSBkdXJhdGlvbiB2YWx1ZSBpbiB0aGUgZm9ybSBIOk1NOlNTLk1TICovXG5Mb2cuZ2V0RHVyYXRpb25TdHJpbmcgPSBmdW5jdGlvbihkdXJhdGlvbiwgX3RpbWVzY2FsZSkge1xuXHR2YXIgbmVnO1xuXHQvKiBIZWxwZXIgZnVuY3Rpb24gdG8gcHJpbnQgYSBudW1iZXIgb24gYSBmaXhlZCBudW1iZXIgb2YgZGlnaXRzICovXG5cdGZ1bmN0aW9uIHBhZChudW1iZXIsIGxlbmd0aCkge1xuXHRcdHZhciBzdHIgPSAnJyArIG51bWJlcjtcblx0XHR2YXIgYSA9IHN0ci5zcGxpdCgnLicpO1x0XHRcblx0XHR3aGlsZSAoYVswXS5sZW5ndGggPCBsZW5ndGgpIHtcblx0XHRcdGFbMF0gPSAnMCcgKyBhWzBdO1xuXHRcdH1cblx0XHRyZXR1cm4gYS5qb2luKCcuJyk7XG5cdH1cblx0aWYgKGR1cmF0aW9uIDwgMCkge1xuXHRcdG5lZyA9IHRydWU7XG5cdFx0ZHVyYXRpb24gPSAtZHVyYXRpb247XG5cdH0gZWxzZSB7XG5cdFx0bmVnID0gZmFsc2U7XHRcblx0fVxuXHR2YXIgdGltZXNjYWxlID0gX3RpbWVzY2FsZSB8fCAxO1xuXHR2YXIgZHVyYXRpb25fc2VjID0gZHVyYXRpb24vdGltZXNjYWxlO1xuXHR2YXIgaG91cnMgPSBNYXRoLmZsb29yKGR1cmF0aW9uX3NlYy8zNjAwKTtcblx0ZHVyYXRpb25fc2VjIC09IGhvdXJzICogMzYwMDtcblx0dmFyIG1pbnV0ZXMgPSBNYXRoLmZsb29yKGR1cmF0aW9uX3NlYy82MCk7XG5cdGR1cmF0aW9uX3NlYyAtPSBtaW51dGVzICogNjA7XHRcdFxuXHR2YXIgbXNlYyA9IGR1cmF0aW9uX3NlYyoxMDAwO1xuXHRkdXJhdGlvbl9zZWMgPSBNYXRoLmZsb29yKGR1cmF0aW9uX3NlYyk7XG5cdG1zZWMgLT0gZHVyYXRpb25fc2VjKjEwMDA7XG5cdG1zZWMgPSBNYXRoLmZsb29yKG1zZWMpO1xuXHRyZXR1cm4gKG5lZyA/IFwiLVwiOiBcIlwiKStob3VycytcIjpcIitwYWQobWludXRlcywyKStcIjpcIitwYWQoZHVyYXRpb25fc2VjLDIpK1wiLlwiK3BhZChtc2VjLDMpO1xufTtcblx0XG4vKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3RyaW5naWZ5IEhUTUw1IFRpbWVSYW5nZXMgb2JqZWN0cyAqL1x0XG5Mb2cucHJpbnRSYW5nZXMgPSBmdW5jdGlvbihyYW5nZXMpIHtcblx0dmFyIGxlbmd0aCA9IHJhbmdlcy5sZW5ndGg7XG5cdGlmIChsZW5ndGggPiAwKSB7XG5cdFx0dmFyIHN0ciA9IFwiXCI7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdCAgaWYgKGkgPiAwKSBzdHIgKz0gXCIsXCI7XG5cdFx0ICBzdHIgKz0gXCJbXCIrTG9nLmdldER1cmF0aW9uU3RyaW5nKHJhbmdlcy5zdGFydChpKSkrIFwiLFwiK0xvZy5nZXREdXJhdGlvblN0cmluZyhyYW5nZXMuZW5kKGkpKStcIl1cIjtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gXCIoZW1wdHkpXCI7XG5cdH1cbn07XG5cbntcblx0ZXhwb3J0cy5Mb2cgPSBMb2c7XG59XG4vLyBmaWxlOnNyYy9zdHJlYW0uanNcbnZhciBNUDRCb3hTdHJlYW0gPSBmdW5jdGlvbihhcnJheUJ1ZmZlcikge1xuICBpZiAoYXJyYXlCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHRoaXMuYnVmZmVyID0gYXJyYXlCdWZmZXI7XG4gICAgdGhpcy5kYXRhdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgKFwiTmVlZHMgYW4gYXJyYXkgYnVmZmVyXCIpO1xuICB9XG4gIHRoaXMucG9zaXRpb24gPSAwO1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgQ29tbW9uIEFQSSBiZXR3ZWVuIE11bHRpQnVmZmVyU3RyZWFtIGFuZCBTaW1wbGVTdHJlYW1cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbn07XG5cbk1QNEJveFN0cmVhbS5wcm90b3R5cGUuZ2V0RW5kUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG59O1xuXG5NUDRCb3hTdHJlYW0ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbn07XG5cbk1QNEJveFN0cmVhbS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgdmFyIG5wb3MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLCBwb3MpKTtcbiAgdGhpcy5wb3NpdGlvbiA9IChpc05hTihucG9zKSB8fCAhaXNGaW5pdGUobnBvcykpID8gMCA6IG5wb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5pc0VvcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0UG9zaXRpb24oKSA+PSB0aGlzLmdldEVuZFBvc2l0aW9uKCk7XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBSZWFkIG1ldGhvZHMsIHNpbWltYXIgdG8gRGF0YVN0cmVhbSBidXQgc2ltcGxlclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5NUDRCb3hTdHJlYW0ucHJvdG90eXBlLnJlYWRBbnlJbnQgPSBmdW5jdGlvbihzaXplLCBzaWduZWQpIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGlmICh0aGlzLnBvc2l0aW9uICsgc2l6ZSA8PSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgc3dpdGNoIChzaXplKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICByZXMgPSB0aGlzLmRhdGF2aWV3LmdldEludDgodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5kYXRhdmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGF0YXZpZXcuZ2V0SW50MTYodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5kYXRhdmlldy5nZXRVaW50MTYodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICB0aHJvdyAoXCJObyBtZXRob2QgZm9yIHJlYWRpbmcgc2lnbmVkIDI0IGJpdHMgdmFsdWVzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbikgPDwgMTY7XG4gICAgICAgICAgcmVzIHw9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbisxKSA8PCA4O1xuICAgICAgICAgIHJlcyB8PSB0aGlzLmRhdGF2aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24rMik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgICByZXMgPSB0aGlzLmRhdGF2aWV3LmdldEludDMyKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGF0YXZpZXcuZ2V0VWludDMyKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgICAgdGhyb3cgKFwiTm8gbWV0aG9kIGZvciByZWFkaW5nIHNpZ25lZCA2NCBiaXRzIHZhbHVlc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSB0aGlzLmRhdGF2aWV3LmdldFVpbnQzMih0aGlzLnBvc2l0aW9uKSA8PCAzMjtcbiAgICAgICAgICByZXMgfD0gdGhpcy5kYXRhdmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbis0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IChcInJlYWRJbnQgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2l6ZTogXCIrc2l6ZSk7XG4gICAgfVxuICAgIHRoaXMucG9zaXRpb24rPSBzaXplO1xuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgKFwiTm90IGVub3VnaCBieXRlcyBpbiBidWZmZXJcIik7XG4gIH1cbn07XG5cbk1QNEJveFN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMSwgZmFsc2UpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMiwgZmFsc2UpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDI0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMywgZmFsc2UpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoNCwgZmFsc2UpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDY0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoOCwgZmFsc2UpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIGlmICh0aGlzLnBvc2l0aW9uICsgbGVuZ3RoIDw9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZFVpbnQ4KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAoXCJOb3QgZW5vdWdoIGJ5dGVzIGluIGJ1ZmZlclwiKTtcbiAgfVxufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJyID0gW107XG4gIHdoaWxlKHRydWUpIHtcbiAgICB2YXIgYiA9IHRoaXMucmVhZFVpbnQ4KCk7XG4gICAgaWYgKGIgIT09IDApIHtcbiAgICAgIGFyci5wdXNoKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTsgXG59O1xuXG5NUDRCb3hTdHJlYW0ucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoMSwgdHJ1ZSk7XG59O1xuXG5NUDRCb3hTdHJlYW0ucHJvdG90eXBlLnJlYWRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZWFkQW55SW50KDIsIHRydWUpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkSW50MzIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEFueUludCg0LCB0cnVlKTtcbn07XG5cbk1QNEJveFN0cmVhbS5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRBbnlJbnQoOCwgZmFsc2UpO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDhBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRoaXMucmVhZFVpbnQ4KCk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbk1QNEJveFN0cmVhbS5wcm90b3R5cGUucmVhZEludDE2QXJyYXkgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgdmFyIGFyciA9IG5ldyBJbnQxNkFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSB0aGlzLnJlYWRJbnQxNigpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5NUDRCb3hTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MTZBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB2YXIgYXJyID0gbmV3IEludDE2QXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRoaXMucmVhZFVpbnQxNigpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5NUDRCb3hTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MzJBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB2YXIgYXJyID0gbmV3IFVpbnQzMkFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuTVA0Qm94U3RyZWFtLnByb3RvdHlwZS5yZWFkSW50MzJBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB2YXIgYXJyID0gbmV3IEludDMyQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRoaXMucmVhZEludDMyKCk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbntcbiAgZXhwb3J0cy5NUDRCb3hTdHJlYW0gPSBNUDRCb3hTdHJlYW07XG59Ly8gZmlsZTpzcmMvRGF0YVN0cmVhbS5qc1xuLyoqXG4gIERhdGFTdHJlYW0gcmVhZHMgc2NhbGFycywgYXJyYXlzIGFuZCBzdHJ1Y3RzIG9mIGRhdGEgZnJvbSBhbiBBcnJheUJ1ZmZlci5cbiAgSXQncyBsaWtlIGEgZmlsZS1saWtlIERhdGFWaWV3IG9uIHN0ZXJvaWRzLlxuXG4gIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIEFycmF5QnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgQHBhcmFtIHs/TnVtYmVyfSBieXRlT2Zmc2V0IE9mZnNldCBmcm9tIGFycmF5QnVmZmVyIGJlZ2lubmluZyBmb3IgdGhlIERhdGFTdHJlYW0uXG4gIEBwYXJhbSB7P0Jvb2xlYW59IGVuZGlhbm5lc3MgRGF0YVN0cmVhbS5CSUdfRU5ESUFOIG9yIERhdGFTdHJlYW0uTElUVExFX0VORElBTiAodGhlIGRlZmF1bHQpLlxuICAqL1xudmFyIERhdGFTdHJlYW0gPSBmdW5jdGlvbihhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgZW5kaWFubmVzcykge1xuICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldCB8fCAwO1xuICBpZiAoYXJyYXlCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHRoaXMuYnVmZmVyID0gYXJyYXlCdWZmZXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFycmF5QnVmZmVyID09IFwib2JqZWN0XCIpIHtcbiAgICB0aGlzLmRhdGFWaWV3ID0gYXJyYXlCdWZmZXI7XG4gICAgaWYgKGJ5dGVPZmZzZXQpIHtcbiAgICAgIHRoaXMuX2J5dGVPZmZzZXQgKz0gYnl0ZU9mZnNldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIgfHwgMCk7XG4gIH1cbiAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gIHRoaXMuZW5kaWFubmVzcyA9IGVuZGlhbm5lc3MgPT0gbnVsbCA/IERhdGFTdHJlYW0uTElUVExFX0VORElBTiA6IGVuZGlhbm5lc3M7XG59O1xuRGF0YVN0cmVhbS5wcm90b3R5cGUgPSB7fTtcblxuRGF0YVN0cmVhbS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucG9zaXRpb247XG59O1xuXG4vKipcbiAgSW50ZXJuYWwgZnVuY3Rpb24gdG8gcmVzaXplIHRoZSBEYXRhU3RyZWFtIGJ1ZmZlciB3aGVuIHJlcXVpcmVkLlxuICBAcGFyYW0ge251bWJlcn0gZXh0cmEgTnVtYmVyIG9mIGJ5dGVzIHRvIGFkZCB0byB0aGUgYnVmZmVyIGFsbG9jYXRpb24uXG4gIEByZXR1cm4ge251bGx9XG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5fcmVhbGxvYyA9IGZ1bmN0aW9uKGV4dHJhKSB7XG4gIGlmICghdGhpcy5fZHluYW1pY1NpemUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlcSA9IHRoaXMuX2J5dGVPZmZzZXQgKyB0aGlzLnBvc2l0aW9uICsgZXh0cmE7XG4gIHZhciBibGVuID0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIGlmIChyZXEgPD0gYmxlbikge1xuICAgIGlmIChyZXEgPiB0aGlzLl9ieXRlTGVuZ3RoKSB7XG4gICAgICB0aGlzLl9ieXRlTGVuZ3RoID0gcmVxO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJsZW4gPCAxKSB7XG4gICAgYmxlbiA9IDE7XG4gIH1cbiAgd2hpbGUgKHJlcSA+IGJsZW4pIHtcbiAgICBibGVuICo9IDI7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihibGVuKTtcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlcik7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShidWYsIDAsIHNyYy5sZW5ndGgpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuYnVmZmVyID0gYnVmO1xuICB0aGlzLl9ieXRlTGVuZ3RoID0gcmVxO1xufTtcblxuLyoqXG4gIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyaW0gdGhlIERhdGFTdHJlYW0gYnVmZmVyIHdoZW4gcmVxdWlyZWQuXG4gIFVzZWQgZm9yIHN0cmlwcGluZyBvdXQgdGhlIGV4dHJhIGJ5dGVzIGZyb20gdGhlIGJhY2tpbmcgYnVmZmVyIHdoZW5cbiAgdGhlIHZpcnR1YWwgYnl0ZUxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGJ1ZmZlciBieXRlTGVuZ3RoIChoYXBwZW5zIGFmdGVyXG4gIGdyb3dpbmcgdGhlIGJ1ZmZlciB3aXRoIHdyaXRlcyBhbmQgbm90IGZpbGxpbmcgdGhlIGV4dHJhIHNwYWNlIGNvbXBsZXRlbHkpLlxuXG4gIEByZXR1cm4ge251bGx9XG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5fdHJpbUFsbG9jID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9ieXRlTGVuZ3RoID09IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5fYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShidWYpO1xuICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCAwLCBkc3QubGVuZ3RoKTtcbiAgZHN0LnNldChzcmMpO1xuICB0aGlzLmJ1ZmZlciA9IGJ1Zjtcbn07XG5cblxuLyoqXG4gIEJpZy1lbmRpYW4gY29uc3QgdG8gdXNlIGFzIGRlZmF1bHQgZW5kaWFubmVzcy5cbiAgQHR5cGUge2Jvb2xlYW59XG4gICovXG5EYXRhU3RyZWFtLkJJR19FTkRJQU4gPSBmYWxzZTtcblxuLyoqXG4gIExpdHRsZS1lbmRpYW4gY29uc3QgdG8gdXNlIGFzIGRlZmF1bHQgZW5kaWFubmVzcy5cbiAgQHR5cGUge2Jvb2xlYW59XG4gICovXG5EYXRhU3RyZWFtLkxJVFRMRV9FTkRJQU4gPSB0cnVlO1xuXG4vKipcbiAgVmlydHVhbCBieXRlIGxlbmd0aCBvZiB0aGUgRGF0YVN0cmVhbSBiYWNraW5nIGJ1ZmZlci5cbiAgVXBkYXRlZCB0byBiZSBtYXggb2Ygb3JpZ2luYWwgYnVmZmVyIHNpemUgYW5kIGxhc3Qgd3JpdHRlbiBzaXplLlxuICBJZiBkeW5hbWljU2l6ZSBpcyBmYWxzZSBpcyBzZXQgdG8gYnVmZmVyIHNpemUuXG4gIEB0eXBlIHtudW1iZXJ9XG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5fYnl0ZUxlbmd0aCA9IDA7XG5cbi8qKlxuICBSZXR1cm5zIHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgRGF0YVN0cmVhbSBvYmplY3QuXG4gIEB0eXBlIHtudW1iZXJ9XG4gICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVN0cmVhbS5wcm90b3R5cGUsICdieXRlTGVuZ3RoJyxcbiAgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoIC0gdGhpcy5fYnl0ZU9mZnNldDtcbiAgfX0pO1xuXG4vKipcbiAgU2V0L2dldCB0aGUgYmFja2luZyBBcnJheUJ1ZmZlciBvZiB0aGUgRGF0YVN0cmVhbSBvYmplY3QuXG4gIFRoZSBzZXR0ZXIgdXBkYXRlcyB0aGUgRGF0YVZpZXcgdG8gcG9pbnQgdG8gdGhlIG5ldyBidWZmZXIuXG4gIEB0eXBlIHtPYmplY3R9XG4gICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVN0cmVhbS5wcm90b3R5cGUsICdidWZmZXInLFxuICB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90cmltQWxsb2MoKTtcbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX2J1ZmZlciA9IHY7XG4gICAgICB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIsIHRoaXMuX2J5dGVPZmZzZXQpO1xuICAgICAgdGhpcy5fYnl0ZUxlbmd0aCA9IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH0gfSk7XG5cbi8qKlxuICBTZXQvZ2V0IHRoZSBieXRlT2Zmc2V0IG9mIHRoZSBEYXRhU3RyZWFtIG9iamVjdC5cbiAgVGhlIHNldHRlciB1cGRhdGVzIHRoZSBEYXRhVmlldyB0byBwb2ludCB0byB0aGUgbmV3IGJ5dGVPZmZzZXQuXG4gIEB0eXBlIHtudW1iZXJ9XG4gICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVN0cmVhbS5wcm90b3R5cGUsICdieXRlT2Zmc2V0JyxcbiAgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J5dGVPZmZzZXQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX2J5dGVPZmZzZXQgPSB2O1xuICAgICAgdGhpcy5fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0KTtcbiAgICAgIHRoaXMuX2J5dGVMZW5ndGggPSB0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9IH0pO1xuXG4vKipcbiAgU2V0L2dldCB0aGUgYmFja2luZyBEYXRhVmlldyBvZiB0aGUgRGF0YVN0cmVhbSBvYmplY3QuXG4gIFRoZSBzZXR0ZXIgdXBkYXRlcyB0aGUgYnVmZmVyIGFuZCBieXRlT2Zmc2V0IHRvIHBvaW50IHRvIHRoZSBEYXRhVmlldyB2YWx1ZXMuXG4gIEB0eXBlIHtPYmplY3R9XG4gICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVN0cmVhbS5wcm90b3R5cGUsICdkYXRhVmlldycsXG4gIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhVmlldztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fYnl0ZU9mZnNldCA9IHYuYnl0ZU9mZnNldDtcbiAgICAgIHRoaXMuX2J1ZmZlciA9IHYuYnVmZmVyO1xuICAgICAgdGhpcy5fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0KTtcbiAgICAgIHRoaXMuX2J5dGVMZW5ndGggPSB0aGlzLl9ieXRlT2Zmc2V0ICsgdi5ieXRlTGVuZ3RoO1xuICAgIH0gfSk7XG5cbi8qKlxuICBTZXRzIHRoZSBEYXRhU3RyZWFtIHJlYWQvd3JpdGUgcG9zaXRpb24gdG8gZ2l2ZW4gcG9zaXRpb24uXG4gIENsYW1wcyBiZXR3ZWVuIDAgYW5kIERhdGFTdHJlYW0gbGVuZ3RoLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gc2VlayB0by5cbiAgQHJldHVybiB7bnVsbH1cbiAgKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbihwb3MpIHtcbiAgdmFyIG5wb3MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmJ5dGVMZW5ndGgsIHBvcykpO1xuICB0aGlzLnBvc2l0aW9uID0gKGlzTmFOKG5wb3MpIHx8ICFpc0Zpbml0ZShucG9zKSkgPyAwIDogbnBvcztcbn07XG5cbi8qKlxuICBSZXR1cm5zIHRydWUgaWYgdGhlIERhdGFTdHJlYW0gc2VlayBwb2ludGVyIGlzIGF0IHRoZSBlbmQgb2YgYnVmZmVyIGFuZFxuICB0aGVyZSdzIG5vIG1vcmUgZGF0YSB0byByZWFkLlxuXG4gIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNlZWsgcG9pbnRlciBpcyBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5pc0VvZiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMucG9zaXRpb24gPj0gdGhpcy5fYnl0ZUxlbmd0aCk7XG59O1xuXG5cbi8qKlxuICBNYXBzIGEgVWludDhBcnJheSBpbnRvIHRoZSBEYXRhU3RyZWFtIGJ1ZmZlci5cblxuICBOaWNlIGZvciBxdWlja2x5IHJlYWRpbmcgaW4gZGF0YS5cblxuICBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBlbGVtZW50cyB0byBtYXAuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byByZWFkLlxuICBAcmV0dXJuIHtPYmplY3R9IFVpbnQ4QXJyYXkgdG8gdGhlIERhdGFTdHJlYW0gYmFja2luZyBidWZmZXIuXG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5tYXBVaW50OEFycmF5ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHRoaXMuX3JlYWxsb2MobGVuZ3RoICogMSk7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLCBsZW5ndGgpO1xuICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAqIDE7XG4gIHJldHVybiBhcnI7XG59O1xuXG5cbi8qKlxuICBSZWFkcyBhbiBJbnQzMkFycmF5IG9mIGRlc2lyZWQgbGVuZ3RoIGFuZCBlbmRpYW5uZXNzIGZyb20gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gbWFwLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIGRhdGEgdG8gcmVhZC5cbiAgQHJldHVybiB7T2JqZWN0fSBUaGUgcmVhZCBJbnQzMkFycmF5LlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkSW50MzJBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCwgZSkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/ICh0aGlzLmJ5dGVMZW5ndGgtdGhpcy5wb3NpdGlvbiAvIDQpIDogbGVuZ3RoO1xuICB2YXIgYXJyID0gbmV3IEludDMyQXJyYXkobGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5tZW1jcHkoYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgqYXJyLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgRGF0YVN0cmVhbS5hcnJheVRvTmF0aXZlKGFyciwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gYXJyLmJ5dGVMZW5ndGg7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAgUmVhZHMgYW4gSW50MTZBcnJheSBvZiBkZXNpcmVkIGxlbmd0aCBhbmQgZW5kaWFubmVzcyBmcm9tIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGVsZW1lbnRzIHRvIG1hcC5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gIEByZXR1cm4ge09iamVjdH0gVGhlIHJlYWQgSW50MTZBcnJheS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZEludDE2QXJyYXkgPSBmdW5jdGlvbihsZW5ndGgsIGUpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyAodGhpcy5ieXRlTGVuZ3RoLXRoaXMucG9zaXRpb24gLyAyKSA6IGxlbmd0aDtcbiAgdmFyIGFyciA9IG5ldyBJbnQxNkFycmF5KGxlbmd0aCk7XG4gIERhdGFTdHJlYW0ubWVtY3B5KGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKmFyci5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIERhdGFTdHJlYW0uYXJyYXlUb05hdGl2ZShhcnIsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IGFyci5ieXRlTGVuZ3RoO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gIFJlYWRzIGFuIEludDhBcnJheSBvZiBkZXNpcmVkIGxlbmd0aCBmcm9tIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGVsZW1lbnRzIHRvIG1hcC5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gIEByZXR1cm4ge09iamVjdH0gVGhlIHJlYWQgSW50OEFycmF5LlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkSW50OEFycmF5ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gKHRoaXMuYnl0ZUxlbmd0aC10aGlzLnBvc2l0aW9uKSA6IGxlbmd0aDtcbiAgdmFyIGFyciA9IG5ldyBJbnQ4QXJyYXkobGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5tZW1jcHkoYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgqYXJyLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgdGhpcy5wb3NpdGlvbiArPSBhcnIuYnl0ZUxlbmd0aDtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICBSZWFkcyBhIFVpbnQzMkFycmF5IG9mIGRlc2lyZWQgbGVuZ3RoIGFuZCBlbmRpYW5uZXNzIGZyb20gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gbWFwLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIGRhdGEgdG8gcmVhZC5cbiAgQHJldHVybiB7T2JqZWN0fSBUaGUgcmVhZCBVaW50MzJBcnJheS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQzMkFycmF5ID0gZnVuY3Rpb24obGVuZ3RoLCBlKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gKHRoaXMuYnl0ZUxlbmd0aC10aGlzLnBvc2l0aW9uIC8gNCkgOiBsZW5ndGg7XG4gIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkobGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5tZW1jcHkoYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgqYXJyLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgRGF0YVN0cmVhbS5hcnJheVRvTmF0aXZlKGFyciwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gYXJyLmJ5dGVMZW5ndGg7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAgUmVhZHMgYSBVaW50MTZBcnJheSBvZiBkZXNpcmVkIGxlbmd0aCBhbmQgZW5kaWFubmVzcyBmcm9tIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGVsZW1lbnRzIHRvIG1hcC5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gIEByZXR1cm4ge09iamVjdH0gVGhlIHJlYWQgVWludDE2QXJyYXkuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MTZBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCwgZSkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/ICh0aGlzLmJ5dGVMZW5ndGgtdGhpcy5wb3NpdGlvbiAvIDIpIDogbGVuZ3RoO1xuICB2YXIgYXJyID0gbmV3IFVpbnQxNkFycmF5KGxlbmd0aCk7XG4gIERhdGFTdHJlYW0ubWVtY3B5KGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKmFyci5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIERhdGFTdHJlYW0uYXJyYXlUb05hdGl2ZShhcnIsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IGFyci5ieXRlTGVuZ3RoO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gIFJlYWRzIGEgVWludDhBcnJheSBvZiBkZXNpcmVkIGxlbmd0aCBmcm9tIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGVsZW1lbnRzIHRvIG1hcC5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gIEByZXR1cm4ge09iamVjdH0gVGhlIHJlYWQgVWludDhBcnJheS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyAodGhpcy5ieXRlTGVuZ3RoLXRoaXMucG9zaXRpb24pIDogbGVuZ3RoO1xuICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5tZW1jcHkoYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgqYXJyLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgdGhpcy5wb3NpdGlvbiArPSBhcnIuYnl0ZUxlbmd0aDtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICBSZWFkcyBhIEZsb2F0NjRBcnJheSBvZiBkZXNpcmVkIGxlbmd0aCBhbmQgZW5kaWFubmVzcyBmcm9tIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGVsZW1lbnRzIHRvIG1hcC5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gIEByZXR1cm4ge09iamVjdH0gVGhlIHJlYWQgRmxvYXQ2NEFycmF5LlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkRmxvYXQ2NEFycmF5ID0gZnVuY3Rpb24obGVuZ3RoLCBlKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gKHRoaXMuYnl0ZUxlbmd0aC10aGlzLnBvc2l0aW9uIC8gOCkgOiBsZW5ndGg7XG4gIHZhciBhcnIgPSBuZXcgRmxvYXQ2NEFycmF5KGxlbmd0aCk7XG4gIERhdGFTdHJlYW0ubWVtY3B5KGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKmFyci5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIERhdGFTdHJlYW0uYXJyYXlUb05hdGl2ZShhcnIsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IGFyci5ieXRlTGVuZ3RoO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gIFJlYWRzIGEgRmxvYXQzMkFycmF5IG9mIGRlc2lyZWQgbGVuZ3RoIGFuZCBlbmRpYW5uZXNzIGZyb20gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gbWFwLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIGRhdGEgdG8gcmVhZC5cbiAgQHJldHVybiB7T2JqZWN0fSBUaGUgcmVhZCBGbG9hdDMyQXJyYXkuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRGbG9hdDMyQXJyYXkgPSBmdW5jdGlvbihsZW5ndGgsIGUpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyAodGhpcy5ieXRlTGVuZ3RoLXRoaXMucG9zaXRpb24gLyA0KSA6IGxlbmd0aDtcbiAgdmFyIGFyciA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5tZW1jcHkoYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgqYXJyLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgRGF0YVN0cmVhbS5hcnJheVRvTmF0aXZlKGFyciwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gYXJyLmJ5dGVMZW5ndGg7XG4gIHJldHVybiBhcnI7XG59O1xuXG5cbi8qKlxuICBSZWFkcyBhIDMyLWJpdCBpbnQgZnJvbSB0aGUgRGF0YVN0cmVhbSB3aXRoIHRoZSBkZXNpcmVkIGVuZGlhbm5lc3MuXG5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBudW1iZXIuXG4gIEByZXR1cm4ge251bWJlcn0gVGhlIHJlYWQgbnVtYmVyLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkSW50MzIgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB2ID0gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MzIodGhpcy5wb3NpdGlvbiwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAgUmVhZHMgYSAxNi1iaXQgaW50IGZyb20gdGhlIERhdGFTdHJlYW0gd2l0aCB0aGUgZGVzaXJlZCBlbmRpYW5uZXNzLlxuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWFkIG51bWJlci5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdiA9IHRoaXMuX2RhdGFWaWV3LmdldEludDE2KHRoaXMucG9zaXRpb24sIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gIFJlYWRzIGFuIDgtYml0IGludCBmcm9tIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEByZXR1cm4ge251bWJlcn0gVGhlIHJlYWQgbnVtYmVyLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiA9IHRoaXMuX2RhdGFWaWV3LmdldEludDgodGhpcy5wb3NpdGlvbik7XG4gIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAgUmVhZHMgYSAzMi1iaXQgdW5zaWduZWQgaW50IGZyb20gdGhlIERhdGFTdHJlYW0gd2l0aCB0aGUgZGVzaXJlZCBlbmRpYW5uZXNzLlxuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWFkIG51bWJlci5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQzMiA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHYgPSB0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAgUmVhZHMgYSAxNi1iaXQgdW5zaWduZWQgaW50IGZyb20gdGhlIERhdGFTdHJlYW0gd2l0aCB0aGUgZGVzaXJlZCBlbmRpYW5uZXNzLlxuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWFkIG51bWJlci5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQxNiA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHYgPSB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAgUmVhZHMgYW4gOC1iaXQgdW5zaWduZWQgaW50IGZyb20gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHJldHVybiB7bnVtYmVyfSBUaGUgcmVhZCBudW1iZXIuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24pO1xuICB0aGlzLnBvc2l0aW9uICs9IDE7XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gIFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gdGhlIERhdGFTdHJlYW0gd2l0aCB0aGUgZGVzaXJlZCBlbmRpYW5uZXNzLlxuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWFkIG51bWJlci5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZEZsb2F0MzIgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB2ID0gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLnBvc2l0aW9uLCBlID09IG51bGwgPyB0aGlzLmVuZGlhbm5lc3MgOiBlKTtcbiAgdGhpcy5wb3NpdGlvbiArPSA0O1xuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICBSZWFkcyBhIDY0LWJpdCBmbG9hdCBmcm9tIHRoZSBEYXRhU3RyZWFtIHdpdGggdGhlIGRlc2lyZWQgZW5kaWFubmVzcy5cblxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIG51bWJlci5cbiAgQHJldHVybiB7bnVtYmVyfSBUaGUgcmVhZCBudW1iZXIuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdiA9IHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQodGhpcy5wb3NpdGlvbiwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gODtcbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAgTmF0aXZlIGVuZGlhbm5lc3MuIEVpdGhlciBEYXRhU3RyZWFtLkJJR19FTkRJQU4gb3IgRGF0YVN0cmVhbS5MSVRUTEVfRU5ESUFOXG4gIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0gZW5kaWFubmVzcy5cblxuICBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuRGF0YVN0cmVhbS5lbmRpYW5uZXNzID0gbmV3IEludDhBcnJheShuZXcgSW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPiAwO1xuXG4vKipcbiAgQ29waWVzIGJ5dGVMZW5ndGggYnl0ZXMgZnJvbSB0aGUgc3JjIGJ1ZmZlciBhdCBzcmNPZmZzZXQgdG8gdGhlXG4gIGRzdCBidWZmZXIgYXQgZHN0T2Zmc2V0LlxuXG4gIEBwYXJhbSB7T2JqZWN0fSBkc3QgRGVzdGluYXRpb24gQXJyYXlCdWZmZXIgdG8gd3JpdGUgdG8uXG4gIEBwYXJhbSB7bnVtYmVyfSBkc3RPZmZzZXQgT2Zmc2V0IHRvIHRoZSBkZXN0aW5hdGlvbiBBcnJheUJ1ZmZlci5cbiAgQHBhcmFtIHtPYmplY3R9IHNyYyBTb3VyY2UgQXJyYXlCdWZmZXIgdG8gcmVhZCBmcm9tLlxuICBAcGFyYW0ge251bWJlcn0gc3JjT2Zmc2V0IE9mZnNldCB0byB0aGUgc291cmNlIEFycmF5QnVmZmVyLlxuICBAcGFyYW0ge251bWJlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gY29weS5cbiAqL1xuRGF0YVN0cmVhbS5tZW1jcHkgPSBmdW5jdGlvbihkc3QsIGRzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFyIGRzdFU4ID0gbmV3IFVpbnQ4QXJyYXkoZHN0LCBkc3RPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICB2YXIgc3JjVTggPSBuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGRzdFU4LnNldChzcmNVOCk7XG59O1xuXG4vKipcbiAgQ29udmVydHMgYXJyYXkgdG8gbmF0aXZlIGVuZGlhbm5lc3MgaW4tcGxhY2UuXG5cbiAgQHBhcmFtIHtPYmplY3R9IGFycmF5IFR5cGVkIGFycmF5IHRvIGNvbnZlcnQuXG4gIEBwYXJhbSB7Ym9vbGVhbn0gYXJyYXlJc0xpdHRsZUVuZGlhbiBUcnVlIGlmIHRoZSBkYXRhIGluIHRoZSBhcnJheSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGl0dGxlLWVuZGlhbi4gU2V0IGZhbHNlIGZvciBiaWctZW5kaWFuLlxuICBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb252ZXJ0ZWQgdHlwZWQgYXJyYXkuXG4gKi9cbkRhdGFTdHJlYW0uYXJyYXlUb05hdGl2ZSA9IGZ1bmN0aW9uKGFycmF5LCBhcnJheUlzTGl0dGxlRW5kaWFuKSB7XG4gIGlmIChhcnJheUlzTGl0dGxlRW5kaWFuID09IHRoaXMuZW5kaWFubmVzcykge1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5mbGlwQXJyYXlFbmRpYW5uZXNzKGFycmF5KTtcbiAgfVxufTtcblxuLyoqXG4gIENvbnZlcnRzIG5hdGl2ZSBlbmRpYW5uZXNzIGFycmF5IHRvIGRlc2lyZWQgZW5kaWFubmVzcyBpbi1wbGFjZS5cblxuICBAcGFyYW0ge09iamVjdH0gYXJyYXkgVHlwZWQgYXJyYXkgdG8gY29udmVydC5cbiAgQHBhcmFtIHtib29sZWFufSBsaXR0bGVFbmRpYW4gVHJ1ZSBpZiB0aGUgY29udmVydGVkIGFycmF5IHNob3VsZCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXR0bGUtZW5kaWFuLiBTZXQgZmFsc2UgZm9yIGJpZy1lbmRpYW4uXG4gIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnZlcnRlZCB0eXBlZCBhcnJheS5cbiAqL1xuRGF0YVN0cmVhbS5uYXRpdmVUb0VuZGlhbiA9IGZ1bmN0aW9uKGFycmF5LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHRoaXMuZW5kaWFubmVzcyA9PSBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZmxpcEFycmF5RW5kaWFubmVzcyhhcnJheSk7XG4gIH1cbn07XG5cbi8qKlxuICBGbGlwcyB0eXBlZCBhcnJheSBlbmRpYW5uZXNzIGluLXBsYWNlLlxuXG4gIEBwYXJhbSB7T2JqZWN0fSBhcnJheSBUeXBlZCBhcnJheSB0byBmbGlwLlxuICBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb252ZXJ0ZWQgdHlwZWQgYXJyYXkuXG4gKi9cbkRhdGFTdHJlYW0uZmxpcEFycmF5RW5kaWFubmVzcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciB1OCA9IG5ldyBVaW50OEFycmF5KGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gIGZvciAodmFyIGk9MDsgaTxhcnJheS5ieXRlTGVuZ3RoOyBpKz1hcnJheS5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgIGZvciAodmFyIGo9aSthcnJheS5CWVRFU19QRVJfRUxFTUVOVC0xLCBrPWk7IGo+azsgai0tLCBrKyspIHtcbiAgICAgIHZhciB0bXAgPSB1OFtrXTtcbiAgICAgIHU4W2tdID0gdThbal07XG4gICAgICB1OFtqXSA9IHRtcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gIFNlZWsgcG9zaXRpb24gd2hlcmUgRGF0YVN0cmVhbSNyZWFkU3RydWN0IHJhbiBpbnRvIGEgcHJvYmxlbS5cbiAgVXNlZnVsIGZvciBkZWJ1Z2dpbmcgc3RydWN0IHBhcnNpbmcuXG5cbiAgQHR5cGUge251bWJlcn1cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUuZmFpbHVyZVBvc2l0aW9uID0gMDtcblxuU3RyaW5nLmZyb21DaGFyQ29kZVVpbnQ4ID0gZnVuY3Rpb24odWludDhhcnIpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50OGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyW2ldID0gdWludDhhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycik7XG59O1xuLyoqXG4gIFJlYWQgYSBzdHJpbmcgb2YgZGVzaXJlZCBsZW5ndGggYW5kIGVuY29kaW5nIGZyb20gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmVhZCBpbiBieXRlcy5cbiAgQHBhcmFtIHs/c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2Rpbmcgb2YgdGhlIHN0cmluZyBkYXRhIGluIHRoZSBEYXRhU3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIEFTQ0lJLlxuICBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZWFkIHN0cmluZy5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nID09IG51bGwgfHwgZW5jb2RpbmcgPT0gXCJBU0NJSVwiKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGVVaW50OC5hcHBseShudWxsLCBbdGhpcy5tYXBVaW50OEFycmF5KGxlbmd0aCA9PSBudWxsID8gdGhpcy5ieXRlTGVuZ3RoLXRoaXMucG9zaXRpb24gOiBsZW5ndGgpXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpKS5kZWNvZGUodGhpcy5tYXBVaW50OEFycmF5KGxlbmd0aCkpO1xuICB9XG59O1xuXG4vKipcbiAgUmVhZCBudWxsLXRlcm1pbmF0ZWQgc3RyaW5nIG9mIGRlc2lyZWQgbGVuZ3RoIGZyb20gdGhlIERhdGFTdHJlYW0uIFRydW5jYXRlc1xuICB0aGUgcmV0dXJuZWQgc3RyaW5nIHNvIHRoYXQgdGhlIG51bGwgYnl0ZSBpcyBub3QgYSBwYXJ0IG9mIGl0LlxuXG4gIEBwYXJhbSB7P251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyB0byByZWFkLlxuICBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZWFkIHN0cmluZy5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZENTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgdmFyIGJsZW4gPSB0aGlzLmJ5dGVMZW5ndGgtdGhpcy5wb3NpdGlvbjtcbiAgdmFyIHU4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbik7XG4gIHZhciBsZW4gPSBibGVuO1xuICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICBsZW4gPSBNYXRoLm1pbihsZW5ndGgsIGJsZW4pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuICYmIHU4W2ldICE9PSAwOyBpKyspOyAvLyBmaW5kIGZpcnN0IHplcm8gYnl0ZVxuICB2YXIgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGVVaW50OC5hcHBseShudWxsLCBbdGhpcy5tYXBVaW50OEFycmF5KGkpXSk7XG4gIGlmIChsZW5ndGggIT0gbnVsbCkge1xuICAgIHRoaXMucG9zaXRpb24gKz0gbGVuLWk7XG4gIH0gZWxzZSBpZiAoaSAhPSBibGVuKSB7XG4gICAgdGhpcy5wb3NpdGlvbiArPSAxOyAvLyB0cmFpbGluZyB6ZXJvIGlmIG5vdCBhdCBlbmQgb2YgYnVmZmVyXG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vKiBcbiAgIFRPRE86IGZpeCBlbmRpYW5uZXNzIGZvciAyNC82NC1iaXQgZmllbGRzXG4gICBUT0RPOiBjaGVjayByYW5nZS9zdXBwb3J0IGZvciA2NC1iaXRzIG51bWJlcnMgaW4gSmF2YVNjcmlwdFxuKi9cbnZhciBNQVhfU0laRSA9IE1hdGgucG93KDIsIDMyKTtcblxuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMucmVhZEludDMyKCkqTUFYX1NJWkUpK3RoaXMucmVhZFVpbnQzMigpO1xufTtcbkRhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5yZWFkVWludDMyKCkqTUFYX1NJWkUpK3RoaXMucmVhZFVpbnQzMigpO1xufTtcblxuRGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMucmVhZFVpbnQzMigpKk1BWF9TSVpFKSt0aGlzLnJlYWRVaW50MzIoKTtcbn07XG5cbkRhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRVaW50MjQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5yZWFkVWludDgoKTw8MTYpKyh0aGlzLnJlYWRVaW50OCgpPDw4KSt0aGlzLnJlYWRVaW50OCgpO1xufTtcblxue1xuICBleHBvcnRzLkRhdGFTdHJlYW0gPSBEYXRhU3RyZWFtOyAgXG59XG4vLyBmaWxlOnNyYy9EYXRhU3RyZWFtLXdyaXRlLmpzXG4vKipcbiAgU2F2ZXMgdGhlIERhdGFTdHJlYW0gY29udGVudHMgdG8gdGhlIGdpdmVuIGZpbGVuYW1lLlxuICBVc2VzIENocm9tZSdzIGFuY2hvciBkb3dubG9hZCBwcm9wZXJ0eSB0byBpbml0aWF0ZSBkb3dubG9hZC5cbiBcbiAgQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIEZpbGVuYW1lIHRvIHNhdmUgYXMuXG4gIEByZXR1cm4ge251bGx9XG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbdGhpcy5idWZmZXJdKTtcbiAgaWYgKHdpbmRvdy5VUkwgJiYgVVJMLmNyZWF0ZU9iamVjdFVSTCkge1xuICAgICAgdmFyIHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAvLyBSZXF1aXJlZCBpbiBGaXJlZm94OlxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgIGEuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcbiAgICAgIGEuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGZpbGVuYW1lKTtcbiAgICAgIC8vIFJlcXVpcmVkIGluIEZpcmVmb3g6XG4gICAgICBhLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19zZWxmJyk7XG4gICAgICBhLmNsaWNrKCk7XG4gICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICB9IGVsc2Uge1xuICAgICAgdGhyb3coXCJEYXRhU3RyZWFtLnNhdmU6IENhbid0IGNyZWF0ZSBvYmplY3QgVVJMLlwiKTtcbiAgfVxufTtcblxuLyoqXG4gIFdoZXRoZXIgdG8gZXh0ZW5kIERhdGFTdHJlYW0gYnVmZmVyIHdoZW4gdHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBpdHMgc2l6ZS5cbiAgSWYgc2V0LCB0aGUgYnVmZmVyIGlzIHJlYWxsb2NhdGVkIHRvIHR3aWNlIGl0cyBjdXJyZW50IHNpemUgdW50aWwgdGhlXG4gIHJlcXVlc3RlZCB3cml0ZSBmaXRzIHRoZSBidWZmZXIuXG4gIEB0eXBlIHtib29sZWFufVxuICAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUuX2R5bmFtaWNTaXplID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU3RyZWFtLnByb3RvdHlwZSwgJ2R5bmFtaWNTaXplJyxcbiAgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2R5bmFtaWNTaXplO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIXYpIHtcbiAgICAgICAgdGhpcy5fdHJpbUFsbG9jKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9keW5hbWljU2l6ZSA9IHY7XG4gICAgfSB9KTtcblxuLyoqXG4gIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyaW0gdGhlIERhdGFTdHJlYW0gYnVmZmVyIHdoZW4gcmVxdWlyZWQuXG4gIFVzZWQgZm9yIHN0cmlwcGluZyBvdXQgdGhlIGZpcnN0IGJ5dGVzIHdoZW4gbm90IG5lZWRlZCBhbnltb3JlLlxuXG4gIEByZXR1cm4ge251bGx9XG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuX2J5dGVMZW5ndGgtb2Zmc2V0KTtcbiAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIG9mZnNldCwgZHN0Lmxlbmd0aCk7XG4gIGRzdC5zZXQoc3JjKTtcbiAgdGhpcy5idWZmZXIgPSBidWY7XG4gIHRoaXMucG9zaXRpb24gLT0gb2Zmc2V0O1xufTtcblxuLyoqXG4gIFdyaXRlcyBhbiBJbnQzMkFycmF5IG9mIHNwZWNpZmllZCBlbmRpYW5uZXNzIHRvIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7T2JqZWN0fSBhcnIgVGhlIGFycmF5IHRvIHdyaXRlLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIGRhdGEgdG8gd3JpdGUuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlSW50MzJBcnJheSA9IGZ1bmN0aW9uKGFyciwgZSkge1xuICB0aGlzLl9yZWFsbG9jKGFyci5sZW5ndGggKiA0KTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIEludDMyQXJyYXkgJiZcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uICUgYXJyLkJZVEVTX1BFUl9FTEVNRU5UID09PSAwKSB7XG4gICAgRGF0YVN0cmVhbS5tZW1jcHkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBhcnIuYnVmZmVyLCAwLFxuICAgICAgICAgICAgICAgICAgICAgIGFyci5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLm1hcEludDMyQXJyYXkoYXJyLmxlbmd0aCwgZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZUludDMyKGFycltpXSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAgV3JpdGVzIGFuIEludDE2QXJyYXkgb2Ygc3BlY2lmaWVkIGVuZGlhbm5lc3MgdG8gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtPYmplY3R9IGFyciBUaGUgYXJyYXkgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byB3cml0ZS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVJbnQxNkFycmF5ID0gZnVuY3Rpb24oYXJyLCBlKSB7XG4gIHRoaXMuX3JlYWxsb2MoYXJyLmxlbmd0aCAqIDIpO1xuICBpZiAoYXJyIGluc3RhbmNlb2YgSW50MTZBcnJheSAmJlxuICAgICAgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24gJSBhcnIuQllURVNfUEVSX0VMRU1FTlQgPT09IDApIHtcbiAgICBEYXRhU3RyZWFtLm1lbWNweSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgYXJyLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMubWFwSW50MTZBcnJheShhcnIubGVuZ3RoLCBlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlSW50MTYoYXJyW2ldLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICBXcml0ZXMgYW4gSW50OEFycmF5IHRvIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7T2JqZWN0fSBhcnIgVGhlIGFycmF5IHRvIHdyaXRlLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUludDhBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICB0aGlzLl9yZWFsbG9jKGFyci5sZW5ndGggKiAxKTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIEludDhBcnJheSAmJlxuICAgICAgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24gJSBhcnIuQllURVNfUEVSX0VMRU1FTlQgPT09IDApIHtcbiAgICBEYXRhU3RyZWFtLm1lbWNweSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgYXJyLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMubWFwSW50OEFycmF5KGFyci5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVJbnQ4KGFycltpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAgV3JpdGVzIGEgVWludDMyQXJyYXkgb2Ygc3BlY2lmaWVkIGVuZGlhbm5lc3MgdG8gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtPYmplY3R9IGFyciBUaGUgYXJyYXkgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byB3cml0ZS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVaW50MzJBcnJheSA9IGZ1bmN0aW9uKGFyciwgZSkge1xuICB0aGlzLl9yZWFsbG9jKGFyci5sZW5ndGggKiA0KTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbiAlIGFyci5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMCkge1xuICAgIERhdGFTdHJlYW0ubWVtY3B5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgICBhcnIuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5tYXBVaW50MzJBcnJheShhcnIubGVuZ3RoLCBlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlVWludDMyKGFycltpXSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAgV3JpdGVzIGEgVWludDE2QXJyYXkgb2Ygc3BlY2lmaWVkIGVuZGlhbm5lc3MgdG8gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtPYmplY3R9IGFyciBUaGUgYXJyYXkgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byB3cml0ZS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVaW50MTZBcnJheSA9IGZ1bmN0aW9uKGFyciwgZSkge1xuICB0aGlzLl9yZWFsbG9jKGFyci5sZW5ndGggKiAyKTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICYmXG4gICAgICB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbiAlIGFyci5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMCkge1xuICAgIERhdGFTdHJlYW0ubWVtY3B5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgYXJyLmJ1ZmZlciwgMCxcbiAgICAgICAgICAgICAgICAgICAgICBhcnIuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5tYXBVaW50MTZBcnJheShhcnIubGVuZ3RoLCBlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlVWludDE2KGFycltpXSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAgV3JpdGVzIGEgVWludDhBcnJheSB0byB0aGUgRGF0YVN0cmVhbS5cblxuICBAcGFyYW0ge09iamVjdH0gYXJyIFRoZSBhcnJheSB0byB3cml0ZS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVaW50OEFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHRoaXMuX3JlYWxsb2MoYXJyLmxlbmd0aCAqIDEpO1xuICBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSAmJlxuICAgICAgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24gJSBhcnIuQllURVNfUEVSX0VMRU1FTlQgPT09IDApIHtcbiAgICBEYXRhU3RyZWFtLm1lbWNweSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgYXJyLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMubWFwVWludDhBcnJheShhcnIubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlVWludDgoYXJyW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICBXcml0ZXMgYSBGbG9hdDY0QXJyYXkgb2Ygc3BlY2lmaWVkIGVuZGlhbm5lc3MgdG8gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtPYmplY3R9IGFyciBUaGUgYXJyYXkgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byB3cml0ZS5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVGbG9hdDY0QXJyYXkgPSBmdW5jdGlvbihhcnIsIGUpIHtcbiAgdGhpcy5fcmVhbGxvYyhhcnIubGVuZ3RoICogOCk7XG4gIGlmIChhcnIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgJiZcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uICUgYXJyLkJZVEVTX1BFUl9FTEVNRU5UID09PSAwKSB7XG4gICAgRGF0YVN0cmVhbS5tZW1jcHkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBhcnIuYnVmZmVyLCAwLFxuICAgICAgICAgICAgICAgICAgICAgIGFyci5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLm1hcEZsb2F0NjRBcnJheShhcnIubGVuZ3RoLCBlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlRmxvYXQ2NChhcnJbaV0sIGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gIFdyaXRlcyBhIEZsb2F0MzJBcnJheSBvZiBzcGVjaWZpZWQgZW5kaWFubmVzcyB0byB0aGUgRGF0YVN0cmVhbS5cblxuICBAcGFyYW0ge09iamVjdH0gYXJyIFRoZSBhcnJheSB0byB3cml0ZS5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHdyaXRlLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUZsb2F0MzJBcnJheSA9IGZ1bmN0aW9uKGFyciwgZSkge1xuICB0aGlzLl9yZWFsbG9jKGFyci5sZW5ndGggKiA0KTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJlxuICAgICAgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24gJSBhcnIuQllURVNfUEVSX0VMRU1FTlQgPT09IDApIHtcbiAgICBEYXRhU3RyZWFtLm1lbWNweSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGFyci5idWZmZXIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgYXJyLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMubWFwRmxvYXQzMkFycmF5KGFyci5sZW5ndGgsIGUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVGbG9hdDMyKGFycltpXSwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICBXcml0ZXMgYSAzMi1iaXQgaW50IHRvIHRoZSBEYXRhU3RyZWFtIHdpdGggdGhlIGRlc2lyZWQgZW5kaWFubmVzcy5cblxuICBAcGFyYW0ge251bWJlcn0gdiBOdW1iZXIgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24odiwgZSkge1xuICB0aGlzLl9yZWFsbG9jKDQpO1xuICB0aGlzLl9kYXRhVmlldy5zZXRJbnQzMih0aGlzLnBvc2l0aW9uLCB2LCBlID09IG51bGwgPyB0aGlzLmVuZGlhbm5lc3MgOiBlKTtcbiAgdGhpcy5wb3NpdGlvbiArPSA0O1xufTtcblxuLyoqXG4gIFdyaXRlcyBhIDE2LWJpdCBpbnQgdG8gdGhlIERhdGFTdHJlYW0gd2l0aCB0aGUgZGVzaXJlZCBlbmRpYW5uZXNzLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSB2IE51bWJlciB0byB3cml0ZS5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBudW1iZXIuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlSW50MTYgPSBmdW5jdGlvbih2LCBlKSB7XG4gIHRoaXMuX3JlYWxsb2MoMik7XG4gIHRoaXMuX2RhdGFWaWV3LnNldEludDE2KHRoaXMucG9zaXRpb24sIHYsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IDI7XG59O1xuXG4vKipcbiAgV3JpdGVzIGFuIDgtYml0IGludCB0byB0aGUgRGF0YVN0cmVhbS5cblxuICBAcGFyYW0ge251bWJlcn0gdiBOdW1iZXIgdG8gd3JpdGUuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5fcmVhbGxvYygxKTtcbiAgdGhpcy5fZGF0YVZpZXcuc2V0SW50OCh0aGlzLnBvc2l0aW9uLCB2KTtcbiAgdGhpcy5wb3NpdGlvbiArPSAxO1xufTtcblxuLyoqXG4gIFdyaXRlcyBhIDMyLWJpdCB1bnNpZ25lZCBpbnQgdG8gdGhlIERhdGFTdHJlYW0gd2l0aCB0aGUgZGVzaXJlZCBlbmRpYW5uZXNzLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSB2IE51bWJlciB0byB3cml0ZS5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBudW1iZXIuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24odiwgZSkge1xuICB0aGlzLl9yZWFsbG9jKDQpO1xuICB0aGlzLl9kYXRhVmlldy5zZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdiwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gNDtcbn07XG5cbi8qKlxuICBXcml0ZXMgYSAxNi1iaXQgdW5zaWduZWQgaW50IHRvIHRoZSBEYXRhU3RyZWFtIHdpdGggdGhlIGRlc2lyZWQgZW5kaWFubmVzcy5cblxuICBAcGFyYW0ge251bWJlcn0gdiBOdW1iZXIgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKHYsIGUpIHtcbiAgdGhpcy5fcmVhbGxvYygyKTtcbiAgdGhpcy5fZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHYsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IDI7XG59O1xuXG4vKipcbiAgV3JpdGVzIGFuIDgtYml0IHVuc2lnbmVkICBpbnQgdG8gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtudW1iZXJ9IHYgTnVtYmVyIHRvIHdyaXRlLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9yZWFsbG9jKDEpO1xuICB0aGlzLl9kYXRhVmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uLCB2KTtcbiAgdGhpcy5wb3NpdGlvbiArPSAxO1xufTtcblxuLyoqXG4gIFdyaXRlcyBhIDMyLWJpdCBmbG9hdCB0byB0aGUgRGF0YVN0cmVhbSB3aXRoIHRoZSBkZXNpcmVkIGVuZGlhbm5lc3MuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IHYgTnVtYmVyIHRvIHdyaXRlLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIG51bWJlci5cbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odiwgZSkge1xuICB0aGlzLl9yZWFsbG9jKDQpO1xuICB0aGlzLl9kYXRhVmlldy5zZXRGbG9hdDMyKHRoaXMucG9zaXRpb24sIHYsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IDQ7XG59O1xuXG4vKipcbiAgV3JpdGVzIGEgNjQtYml0IGZsb2F0IHRvIHRoZSBEYXRhU3RyZWFtIHdpdGggdGhlIGRlc2lyZWQgZW5kaWFubmVzcy5cblxuICBAcGFyYW0ge251bWJlcn0gdiBOdW1iZXIgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgbnVtYmVyLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2LCBlKSB7XG4gIHRoaXMuX3JlYWxsb2MoOCk7XG4gIHRoaXMuX2RhdGFWaWV3LnNldEZsb2F0NjQodGhpcy5wb3NpdGlvbiwgdiwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gODtcbn07XG5cbi8qKlxuICBXcml0ZSBhIFVDUy0yIHN0cmluZyBvZiBkZXNpcmVkIGVuZGlhbm5lc3MgdG8gdGhlIERhdGFTdHJlYW0uIFRoZVxuICBsZW5ndGhPdmVycmlkZSBhcmd1bWVudCBsZXRzIHlvdSBkZWZpbmUgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHdyaXRlLlxuICBJZiB0aGUgc3RyaW5nIGlzIHNob3J0ZXIgdGhhbiBsZW5ndGhPdmVycmlkZSwgdGhlIGV4dHJhIHNwYWNlIGlzIHBhZGRlZCB3aXRoXG4gIHplcm9lcy5cblxuICBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGVuZGlhbm5lc3MgVGhlIGVuZGlhbm5lc3MgdG8gdXNlIGZvciB0aGUgd3JpdHRlbiBzdHJpbmcgZGF0YS5cbiAgQHBhcmFtIHs/bnVtYmVyfSBsZW5ndGhPdmVycmlkZSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gd3JpdGUuXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVUNTMlN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgZW5kaWFubmVzcywgbGVuZ3RoT3ZlcnJpZGUpIHtcbiAgaWYgKGxlbmd0aE92ZXJyaWRlID09IG51bGwpIHtcbiAgICBsZW5ndGhPdmVycmlkZSA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoICYmIGkgPCBsZW5ndGhPdmVycmlkZTsgaSsrKSB7XG4gICAgdGhpcy53cml0ZVVpbnQxNihzdHIuY2hhckNvZGVBdChpKSwgZW5kaWFubmVzcyk7XG4gIH1cbiAgZm9yICg7IGk8bGVuZ3RoT3ZlcnJpZGU7IGkrKykge1xuICAgIHRoaXMud3JpdGVVaW50MTYoMCk7XG4gIH1cbn07XG5cbi8qKlxuICBXcml0ZXMgYSBzdHJpbmcgb2YgZGVzaXJlZCBsZW5ndGggYW5kIGVuY29kaW5nIHRvIHRoZSBEYXRhU3RyZWFtLlxuXG4gIEBwYXJhbSB7c3RyaW5nfSBzIFRoZSBzdHJpbmcgdG8gd3JpdGUuXG4gIEBwYXJhbSB7P3N0cmluZ30gZW5jb2RpbmcgVGhlIGVuY29kaW5nIGZvciB0aGUgd3JpdHRlbiBzdHJpbmcgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBBU0NJSS5cbiAgQHBhcmFtIHs/bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHdyaXRlLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKHMsIGVuY29kaW5nLCBsZW5ndGgpIHtcbiAgdmFyIGkgPSAwO1xuICBpZiAoZW5jb2RpbmcgPT0gbnVsbCB8fCBlbmNvZGluZyA9PSBcIkFTQ0lJXCIpIHtcbiAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihzLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgIGZvciAoaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JpdGVVaW50OChzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGk9MDsgaTxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JpdGVVaW50OChzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLndyaXRlVWludDhBcnJheSgobmV3IFRleHRFbmNvZGVyKGVuY29kaW5nKSkuZW5jb2RlKHMuc3Vic3RyaW5nKDAsIGxlbmd0aCkpKTtcbiAgfVxufTtcblxuLyoqXG4gIFdyaXRlcyBhIG51bGwtdGVybWluYXRlZCBzdHJpbmcgdG8gRGF0YVN0cmVhbSBhbmQgemVyby1wYWRzIGl0IHRvIGxlbmd0aFxuICBieXRlcy4gSWYgbGVuZ3RoIGlzIG5vdCBnaXZlbiwgd3JpdGVzIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgYSB6ZXJvLlxuICBJZiBzdHJpbmcgaXMgbG9uZ2VyIHRoYW4gbGVuZ3RoLCB0aGUgd3JpdHRlbiBwYXJ0IG9mIHRoZSBzdHJpbmcgZG9lcyBub3QgaGF2ZVxuICBhIHRyYWlsaW5nIHplcm8uXG5cbiAgQHBhcmFtIHtzdHJpbmd9IHMgVGhlIHN0cmluZyB0byB3cml0ZS5cbiAgQHBhcmFtIHs/bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHdyaXRlLlxuICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUNTdHJpbmcgPSBmdW5jdGlvbihzLCBsZW5ndGgpIHtcbiAgdmFyIGkgPSAwO1xuICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4ocy5sZW5ndGgsIGxlbmd0aCk7XG4gICAgZm9yIChpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVVaW50OChzLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVVpbnQ4KDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGk9MDsgaTxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlVWludDgocy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gICAgdGhpcy53cml0ZVVpbnQ4KDApO1xuICB9XG59O1xuXG4vKipcbiAgV3JpdGVzIGEgc3RydWN0IHRvIHRoZSBEYXRhU3RyZWFtLiBUYWtlcyBhIHN0cnVjdERlZmluaXRpb24gdGhhdCBnaXZlcyB0aGVcbiAgdHlwZXMgYW5kIGEgc3RydWN0IG9iamVjdCB0aGF0IGdpdmVzIHRoZSB2YWx1ZXMuIFJlZmVyIHRvIHJlYWRTdHJ1Y3QgZm9yIHRoZVxuICBzdHJ1Y3R1cmUgb2Ygc3RydWN0RGVmaW5pdGlvbi5cblxuICBAcGFyYW0ge09iamVjdH0gc3RydWN0RGVmaW5pdGlvbiBUeXBlIGRlZmluaXRpb24gb2YgdGhlIHN0cnVjdC5cbiAgQHBhcmFtIHtPYmplY3R9IHN0cnVjdCBUaGUgc3RydWN0IGRhdGEgb2JqZWN0LlxuICAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVTdHJ1Y3QgPSBmdW5jdGlvbihzdHJ1Y3REZWZpbml0aW9uLCBzdHJ1Y3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJ1Y3REZWZpbml0aW9uLmxlbmd0aDsgaSs9Mikge1xuICAgIHZhciB0ID0gc3RydWN0RGVmaW5pdGlvbltpKzFdO1xuICAgIHRoaXMud3JpdGVUeXBlKHQsIHN0cnVjdFtzdHJ1Y3REZWZpbml0aW9uW2ldXSwgc3RydWN0KTtcbiAgfVxufTtcblxuLyoqXG4gIFdyaXRlcyBvYmplY3QgdiBvZiB0eXBlIHQgdG8gdGhlIERhdGFTdHJlYW0uXG5cbiAgQHBhcmFtIHtPYmplY3R9IHQgVHlwZSBvZiBkYXRhIHRvIHdyaXRlLlxuICBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSBvZiBkYXRhIHRvIHdyaXRlLlxuICBAcGFyYW0ge09iamVjdH0gc3RydWN0IFN0cnVjdCB0byBwYXNzIHRvIHdyaXRlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVHlwZSA9IGZ1bmN0aW9uKHQsIHYsIHN0cnVjdCkge1xuICB2YXIgdHA7XG4gIGlmICh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdCh0aGlzLCB2KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmICEodCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHJldHVybiB0LnNldCh0aGlzLCB2LCBzdHJ1Y3QpO1xuICB9XG4gIHZhciBsZW5ndGhPdmVycmlkZSA9IG51bGw7XG4gIHZhciBjaGFyc2V0ID0gXCJBU0NJSVwiO1xuICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgaWYgKHR5cGVvZih0KSA9PSAnc3RyaW5nJyAmJiAvOi8udGVzdCh0KSkge1xuICAgIHRwID0gdC5zcGxpdChcIjpcIik7XG4gICAgdCA9IHRwWzBdO1xuICAgIGxlbmd0aE92ZXJyaWRlID0gcGFyc2VJbnQodHBbMV0pO1xuICB9XG4gIGlmICh0eXBlb2YgdCA9PSAnc3RyaW5nJyAmJiAvLC8udGVzdCh0KSkge1xuICAgIHRwID0gdC5zcGxpdChcIixcIik7XG4gICAgdCA9IHRwWzBdO1xuICAgIGNoYXJzZXQgPSBwYXJzZUludCh0cFsxXSk7XG4gIH1cblxuICBzd2l0Y2godCkge1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHRoaXMud3JpdGVVaW50OCh2KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgdGhpcy53cml0ZUludDgodik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICB0aGlzLndyaXRlVWludDE2KHYsIHRoaXMuZW5kaWFubmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICB0aGlzLndyaXRlSW50MTYodiwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICB0aGlzLndyaXRlVWludDMyKHYsIHRoaXMuZW5kaWFubmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICB0aGlzLndyaXRlSW50MzIodiwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgdGhpcy53cml0ZUZsb2F0MzIodiwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgdGhpcy53cml0ZUZsb2F0NjQodiwgdGhpcy5lbmRpYW5uZXNzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWludDE2YmUnOlxuICAgICAgdGhpcy53cml0ZVVpbnQxNih2LCBEYXRhU3RyZWFtLkJJR19FTkRJQU4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW50MTZiZSc6XG4gICAgICB0aGlzLndyaXRlSW50MTYodiwgRGF0YVN0cmVhbS5CSUdfRU5ESUFOKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VpbnQzMmJlJzpcbiAgICAgIHRoaXMud3JpdGVVaW50MzIodiwgRGF0YVN0cmVhbS5CSUdfRU5ESUFOKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludDMyYmUnOlxuICAgICAgdGhpcy53cml0ZUludDMyKHYsIERhdGFTdHJlYW0uQklHX0VORElBTik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmbG9hdDMyYmUnOlxuICAgICAgdGhpcy53cml0ZUZsb2F0MzIodiwgRGF0YVN0cmVhbS5CSUdfRU5ESUFOKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zsb2F0NjRiZSc6XG4gICAgICB0aGlzLndyaXRlRmxvYXQ2NCh2LCBEYXRhU3RyZWFtLkJJR19FTkRJQU4pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1aW50MTZsZSc6XG4gICAgICB0aGlzLndyaXRlVWludDE2KHYsIERhdGFTdHJlYW0uTElUVExFX0VORElBTik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnQxNmxlJzpcbiAgICAgIHRoaXMud3JpdGVJbnQxNih2LCBEYXRhU3RyZWFtLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWludDMybGUnOlxuICAgICAgdGhpcy53cml0ZVVpbnQzMih2LCBEYXRhU3RyZWFtLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW50MzJsZSc6XG4gICAgICB0aGlzLndyaXRlSW50MzIodiwgRGF0YVN0cmVhbS5MSVRUTEVfRU5ESUFOKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zsb2F0MzJsZSc6XG4gICAgICB0aGlzLndyaXRlRmxvYXQzMih2LCBEYXRhU3RyZWFtLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmxvYXQ2NGxlJzpcbiAgICAgIHRoaXMud3JpdGVGbG9hdDY0KHYsIERhdGFTdHJlYW0uTElUVExFX0VORElBTik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NzdHJpbmcnOlxuICAgICAgdGhpcy53cml0ZUNTdHJpbmcodiwgbGVuZ3RoT3ZlcnJpZGUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgdGhpcy53cml0ZVN0cmluZyh2LCBjaGFyc2V0LCBsZW5ndGhPdmVycmlkZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3UxNnN0cmluZyc6XG4gICAgICB0aGlzLndyaXRlVUNTMlN0cmluZyh2LCB0aGlzLmVuZGlhbm5lc3MsIGxlbmd0aE92ZXJyaWRlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndTE2c3RyaW5nbGUnOlxuICAgICAgdGhpcy53cml0ZVVDUzJTdHJpbmcodiwgRGF0YVN0cmVhbS5MSVRUTEVfRU5ESUFOLCBsZW5ndGhPdmVycmlkZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3UxNnN0cmluZ2JlJzpcbiAgICAgIHRoaXMud3JpdGVVQ1MyU3RyaW5nKHYsIERhdGFTdHJlYW0uQklHX0VORElBTiwgbGVuZ3RoT3ZlcnJpZGUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHQubGVuZ3RoID09IDMpIHtcbiAgICAgICAgdmFyIHRhID0gdFsxXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndyaXRlVHlwZSh0YSwgdltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndyaXRlU3RydWN0KHQsIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICBpZiAobGVuZ3RoT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XG4gICAgdGhpcy5fcmVhbGxvYyhsZW5ndGhPdmVycmlkZSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvcyArIGxlbmd0aE92ZXJyaWRlO1xuICB9XG59O1xuXG5cbkRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVWludDY0ID0gZnVuY3Rpb24gKHYpIHtcblx0dmFyIGggPSBNYXRoLmZsb29yKHYgLyBNQVhfU0laRSk7XG5cdHRoaXMud3JpdGVVaW50MzIoaCk7XG5cdHRoaXMud3JpdGVVaW50MzIodiAmIDB4RkZGRkZGRkYpO1xufTtcblxuRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVaW50MjQgPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLndyaXRlVWludDgoKHYgJiAweDAwRkYwMDAwKT4+MTYpO1xuXHR0aGlzLndyaXRlVWludDgoKHYgJiAweDAwMDBGRjAwKT4+OCk7XG5cdHRoaXMud3JpdGVVaW50OCgodiAmIDB4MDAwMDAwRkYpKTtcbn07XG5cbkRhdGFTdHJlYW0ucHJvdG90eXBlLmFkanVzdFVpbnQzMiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB2YWx1ZSkge1xuXHR2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcblx0dGhpcy5zZWVrKHBvc2l0aW9uKTtcblx0dGhpcy53cml0ZVVpbnQzMih2YWx1ZSk7XG5cdHRoaXMuc2Vlayhwb3MpO1xufTtcbi8vIGZpbGU6c3JjL0RhdGFTdHJlYW0tbWFwLmpzXG4vKipcbiAgTWFwcyBhbiBJbnQzMkFycmF5IGludG8gdGhlIERhdGFTdHJlYW0gYnVmZmVyLCBzd2l6emxpbmcgaXQgdG8gbmF0aXZlXG4gIGVuZGlhbm5lc3MgaW4tcGxhY2UuIFRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIG5lZWRzIHRvXG4gIGJlIGEgbXVsdGlwbGUgb2YgZWxlbWVudCBzaXplLCBqdXN0IGxpa2Ugd2l0aCB0eXBlZCBhcnJheSB2aWV3cy5cblxuICBOaWNlIGZvciBxdWlja2x5IHJlYWRpbmcgaW4gZGF0YS4gV2FybmluZzogcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGJ1ZmZlclxuICBjb250ZW50cy5cblxuICBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBlbGVtZW50cyB0byBtYXAuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byByZWFkLlxuICBAcmV0dXJuIHtPYmplY3R9IEludDMyQXJyYXkgdG8gdGhlIERhdGFTdHJlYW0gYmFja2luZyBidWZmZXIuXG4gICovXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5tYXBJbnQzMkFycmF5ID0gZnVuY3Rpb24obGVuZ3RoLCBlKSB7XG4gIHRoaXMuX3JlYWxsb2MobGVuZ3RoICogNCk7XG4gIHZhciBhcnIgPSBuZXcgSW50MzJBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLCBsZW5ndGgpO1xuICBEYXRhU3RyZWFtLmFycmF5VG9OYXRpdmUoYXJyLCBlID09IG51bGwgPyB0aGlzLmVuZGlhbm5lc3MgOiBlKTtcbiAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggKiA0O1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gIE1hcHMgYW4gSW50MTZBcnJheSBpbnRvIHRoZSBEYXRhU3RyZWFtIGJ1ZmZlciwgc3dpenpsaW5nIGl0IHRvIG5hdGl2ZVxuICBlbmRpYW5uZXNzIGluLXBsYWNlLiBUaGUgY3VycmVudCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlciBuZWVkcyB0b1xuICBiZSBhIG11bHRpcGxlIG9mIGVsZW1lbnQgc2l6ZSwganVzdCBsaWtlIHdpdGggdHlwZWQgYXJyYXkgdmlld3MuXG5cbiAgTmljZSBmb3IgcXVpY2tseSByZWFkaW5nIGluIGRhdGEuIFdhcm5pbmc6IHBvdGVudGlhbGx5IG1vZGlmaWVzIHRoZSBidWZmZXJcbiAgY29udGVudHMuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gbWFwLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIGRhdGEgdG8gcmVhZC5cbiAgQHJldHVybiB7T2JqZWN0fSBJbnQxNkFycmF5IHRvIHRoZSBEYXRhU3RyZWFtIGJhY2tpbmcgYnVmZmVyLlxuICAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUubWFwSW50MTZBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCwgZSkge1xuICB0aGlzLl9yZWFsbG9jKGxlbmd0aCAqIDIpO1xuICB2YXIgYXJyID0gbmV3IEludDE2QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbiwgbGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5hcnJheVRvTmF0aXZlKGFyciwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoICogMjtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICBNYXBzIGFuIEludDhBcnJheSBpbnRvIHRoZSBEYXRhU3RyZWFtIGJ1ZmZlci5cblxuICBOaWNlIGZvciBxdWlja2x5IHJlYWRpbmcgaW4gZGF0YS5cblxuICBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBlbGVtZW50cyB0byBtYXAuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byByZWFkLlxuICBAcmV0dXJuIHtPYmplY3R9IEludDhBcnJheSB0byB0aGUgRGF0YVN0cmVhbSBiYWNraW5nIGJ1ZmZlci5cbiAgKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLm1hcEludDhBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB0aGlzLl9yZWFsbG9jKGxlbmd0aCAqIDEpO1xuICB2YXIgYXJyID0gbmV3IEludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLCBsZW5ndGgpO1xuICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAqIDE7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAgTWFwcyBhIFVpbnQzMkFycmF5IGludG8gdGhlIERhdGFTdHJlYW0gYnVmZmVyLCBzd2l6emxpbmcgaXQgdG8gbmF0aXZlXG4gIGVuZGlhbm5lc3MgaW4tcGxhY2UuIFRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIG5lZWRzIHRvXG4gIGJlIGEgbXVsdGlwbGUgb2YgZWxlbWVudCBzaXplLCBqdXN0IGxpa2Ugd2l0aCB0eXBlZCBhcnJheSB2aWV3cy5cblxuICBOaWNlIGZvciBxdWlja2x5IHJlYWRpbmcgaW4gZGF0YS4gV2FybmluZzogcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGJ1ZmZlclxuICBjb250ZW50cy5cblxuICBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBlbGVtZW50cyB0byBtYXAuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byByZWFkLlxuICBAcmV0dXJuIHtPYmplY3R9IFVpbnQzMkFycmF5IHRvIHRoZSBEYXRhU3RyZWFtIGJhY2tpbmcgYnVmZmVyLlxuICAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUubWFwVWludDMyQXJyYXkgPSBmdW5jdGlvbihsZW5ndGgsIGUpIHtcbiAgdGhpcy5fcmVhbGxvYyhsZW5ndGggKiA0KTtcbiAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLCBsZW5ndGgpO1xuICBEYXRhU3RyZWFtLmFycmF5VG9OYXRpdmUoYXJyLCBlID09IG51bGwgPyB0aGlzLmVuZGlhbm5lc3MgOiBlKTtcbiAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggKiA0O1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gIE1hcHMgYSBVaW50MTZBcnJheSBpbnRvIHRoZSBEYXRhU3RyZWFtIGJ1ZmZlciwgc3dpenpsaW5nIGl0IHRvIG5hdGl2ZVxuICBlbmRpYW5uZXNzIGluLXBsYWNlLiBUaGUgY3VycmVudCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlciBuZWVkcyB0b1xuICBiZSBhIG11bHRpcGxlIG9mIGVsZW1lbnQgc2l6ZSwganVzdCBsaWtlIHdpdGggdHlwZWQgYXJyYXkgdmlld3MuXG5cbiAgTmljZSBmb3IgcXVpY2tseSByZWFkaW5nIGluIGRhdGEuIFdhcm5pbmc6IHBvdGVudGlhbGx5IG1vZGlmaWVzIHRoZSBidWZmZXJcbiAgY29udGVudHMuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gbWFwLlxuICBAcGFyYW0gez9ib29sZWFufSBlIEVuZGlhbm5lc3Mgb2YgdGhlIGRhdGEgdG8gcmVhZC5cbiAgQHJldHVybiB7T2JqZWN0fSBVaW50MTZBcnJheSB0byB0aGUgRGF0YVN0cmVhbSBiYWNraW5nIGJ1ZmZlci5cbiAgKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLm1hcFVpbnQxNkFycmF5ID0gZnVuY3Rpb24obGVuZ3RoLCBlKSB7XG4gIHRoaXMuX3JlYWxsb2MobGVuZ3RoICogMik7XG4gIHZhciBhcnIgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQrdGhpcy5wb3NpdGlvbiwgbGVuZ3RoKTtcbiAgRGF0YVN0cmVhbS5hcnJheVRvTmF0aXZlKGFyciwgZSA9PSBudWxsID8gdGhpcy5lbmRpYW5uZXNzIDogZSk7XG4gIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoICogMjtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICBNYXBzIGEgRmxvYXQ2NEFycmF5IGludG8gdGhlIERhdGFTdHJlYW0gYnVmZmVyLCBzd2l6emxpbmcgaXQgdG8gbmF0aXZlXG4gIGVuZGlhbm5lc3MgaW4tcGxhY2UuIFRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIG5lZWRzIHRvXG4gIGJlIGEgbXVsdGlwbGUgb2YgZWxlbWVudCBzaXplLCBqdXN0IGxpa2Ugd2l0aCB0eXBlZCBhcnJheSB2aWV3cy5cblxuICBOaWNlIGZvciBxdWlja2x5IHJlYWRpbmcgaW4gZGF0YS4gV2FybmluZzogcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGJ1ZmZlclxuICBjb250ZW50cy5cblxuICBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBlbGVtZW50cyB0byBtYXAuXG4gIEBwYXJhbSB7P2Jvb2xlYW59IGUgRW5kaWFubmVzcyBvZiB0aGUgZGF0YSB0byByZWFkLlxuICBAcmV0dXJuIHtPYmplY3R9IEZsb2F0NjRBcnJheSB0byB0aGUgRGF0YVN0cmVhbSBiYWNraW5nIGJ1ZmZlci5cbiAgKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLm1hcEZsb2F0NjRBcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCwgZSkge1xuICB0aGlzLl9yZWFsbG9jKGxlbmd0aCAqIDgpO1xuICB2YXIgYXJyID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCt0aGlzLnBvc2l0aW9uLCBsZW5ndGgpO1xuICBEYXRhU3RyZWFtLmFycmF5VG9OYXRpdmUoYXJyLCBlID09IG51bGwgPyB0aGlzLmVuZGlhbm5lc3MgOiBlKTtcbiAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggKiA4O1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gIE1hcHMgYSBGbG9hdDMyQXJyYXkgaW50byB0aGUgRGF0YVN0cmVhbSBidWZmZXIsIHN3aXp6bGluZyBpdCB0byBuYXRpdmVcbiAgZW5kaWFubmVzcyBpbi1wbGFjZS4gVGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgbmVlZHMgdG9cbiAgYmUgYSBtdWx0aXBsZSBvZiBlbGVtZW50IHNpemUsIGp1c3QgbGlrZSB3aXRoIHR5cGVkIGFycmF5IHZpZXdzLlxuXG4gIE5pY2UgZm9yIHF1aWNrbHkgcmVhZGluZyBpbiBkYXRhLiBXYXJuaW5nOiBwb3RlbnRpYWxseSBtb2RpZmllcyB0aGUgYnVmZmVyXG4gIGNvbnRlbnRzLlxuXG4gIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGVsZW1lbnRzIHRvIG1hcC5cbiAgQHBhcmFtIHs/Ym9vbGVhbn0gZSBFbmRpYW5uZXNzIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gIEByZXR1cm4ge09iamVjdH0gRmxvYXQzMkFycmF5IHRvIHRoZSBEYXRhU3RyZWFtIGJhY2tpbmcgYnVmZmVyLlxuICAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUubWFwRmxvYXQzMkFycmF5ID0gZnVuY3Rpb24obGVuZ3RoLCBlKSB7XG4gIHRoaXMuX3JlYWxsb2MobGVuZ3RoICogNCk7XG4gIHZhciBhcnIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0K3RoaXMucG9zaXRpb24sIGxlbmd0aCk7XG4gIERhdGFTdHJlYW0uYXJyYXlUb05hdGl2ZShhcnIsIGUgPT0gbnVsbCA/IHRoaXMuZW5kaWFubmVzcyA6IGUpO1xuICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAqIDQ7XG4gIHJldHVybiBhcnI7XG59O1xuLy8gZmlsZTpzcmMvYnVmZmVyLmpzXG4vKipcbiAqIE11bHRpQnVmZmVyU3RyZWFtIGlzIGEgY2xhc3MgdGhhdCBhY3RzIGFzIGEgU2ltcGxlU3RyZWFtIGZvciBwYXJzaW5nIFxuICogSXQgaG9sZHMgc2V2ZXJhbCwgcG9zc2libHkgbm9uLWNvbnRpZ3VvdXMgQXJyYXlCdWZmZXIgb2JqZWN0cywgZWFjaCB3aXRoIGEgZmlsZVN0YXJ0IHByb3BlcnR5IFxuICogY29udGFpbmluZyB0aGUgb2Zmc2V0IGZvciB0aGUgYnVmZmVyIGRhdGEgaW4gYW4gb3JpZ2luYWwvdmlydHVhbCBmaWxlIFxuICpcbiAqIEl0IGluaGVyaXRzIGFsc28gZnJvbSBEYXRhU3RyZWFtIGZvciBhbGwgcmVhZC93cml0ZS9hbGxvYyBvcGVyYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvclxuICovXG52YXIgTXVsdGlCdWZmZXJTdHJlYW0gPSBmdW5jdGlvbihidWZmZXIpIHtcblx0LyogTGlzdCBvZiBBcnJheUJ1ZmZlcnMsIHdpdGggYSBmaWxlU3RhcnQgcHJvcGVydHksIHNvcnRlZCBpbiBmaWxlU3RhcnQgb3JkZXIgYW5kIG5vbiBvdmVybGFwcGluZyAqL1xuXHR0aGlzLmJ1ZmZlcnMgPSBbXTtcdFxuXHR0aGlzLmJ1ZmZlckluZGV4ID0gLTE7XG5cdGlmIChidWZmZXIpIHtcblx0XHR0aGlzLmluc2VydEJ1ZmZlcihidWZmZXIpO1xuXHRcdHRoaXMuYnVmZmVySW5kZXggPSAwO1xuXHR9XG59O1xuTXVsdGlCdWZmZXJTdHJlYW0ucHJvdG90eXBlID0gbmV3IERhdGFTdHJlYW0obmV3IEFycmF5QnVmZmVyKCksIDAsIERhdGFTdHJlYW0uQklHX0VORElBTik7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgTWV0aG9kcyBmb3IgdGhlIG1hbmFnbmVtZW50IG9mIHRoZSBidWZmZXJzIChpbnNlcnRpb24sIHJlbW92YWwsIGNvbmNhdGVuYXRpb24sIC4uLilcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuTXVsdGlCdWZmZXJTdHJlYW0ucHJvdG90eXBlLmluaXRpYWxpemVkID0gZnVuY3Rpb24oKSB7XG5cdHZhciBmaXJzdEJ1ZmZlcjtcblx0aWYgKHRoaXMuYnVmZmVySW5kZXggPiAtMSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPiAwKSB7XG5cdFx0Zmlyc3RCdWZmZXIgPSB0aGlzLmJ1ZmZlcnNbMF07XG5cdFx0aWYgKGZpcnN0QnVmZmVyLmZpbGVTdGFydCA9PT0gMCkge1xuXHRcdFx0dGhpcy5idWZmZXIgPSBmaXJzdEJ1ZmZlcjtcblx0XHRcdHRoaXMuYnVmZmVySW5kZXggPSAwO1xuXHRcdFx0TG9nLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJTdHJlYW0gcmVhZHkgZm9yIHBhcnNpbmdcIik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TG9nLndhcm4oXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlRoZSBmaXJzdCBidWZmZXIgc2hvdWxkIGhhdmUgYSBmaWxlU3RhcnQgb2YgMFwiKTtcblx0XHRcdHRoaXMubG9nQnVmZmVyTGV2ZWwoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0TG9nLndhcm4oXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIk5vIGJ1ZmZlciB0byBzdGFydCBwYXJzaW5nIGZyb21cIik7XG5cdFx0dGhpcy5sb2dCdWZmZXJMZXZlbCgpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVx0XHRcdFxufTtcblxuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb25zIHRvIGNvbmNhdGVuYXRlIHR3byBBcnJheUJ1ZmZlciBvYmplY3RzXG4gKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gYnVmZmVyMSBcbiAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBidWZmZXIyIFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IHRoZSBjb25jYXRlbmF0aW9uIG9mIGJ1ZmZlcjEgYW5kIGJ1ZmZlcjIgaW4gdGhhdCBvcmRlclxuICovXG5BcnJheUJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbihidWZmZXIxLCBidWZmZXIyKSB7XG4gIExvZy5kZWJ1ZyhcIkFycmF5QnVmZmVyXCIsIFwiVHJ5aW5nIHRvIGNyZWF0ZSBhIG5ldyBidWZmZXIgb2Ygc2l6ZTogXCIrKGJ1ZmZlcjEuYnl0ZUxlbmd0aCArIGJ1ZmZlcjIuYnl0ZUxlbmd0aCkpO1xuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XG4gIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0bXAuYnVmZmVyO1xufTtcblxuLyoqXG4gKiBSZWR1Y2VzIHRoZSBzaXplIG9mIGEgZ2l2ZW4gYnVmZmVyLCBidXQgdGFraW5nIHRoZSBwYXJ0IGJldHdlZW4gb2Zmc2V0IGFuZCBvZmZzZXQrbmV3bGVuZ3RoXG4gKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gYnVmZmVyICAgIFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgIG9mZnNldCAgICB0aGUgc3RhcnQgb2YgbmV3IGJ1ZmZlclxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgIG5ld0xlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSBuZXcgYnVmZmVyXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gICAgICAgICAgIHRoZSBuZXcgYnVmZmVyXG4gKi9cbk11bHRpQnVmZmVyU3RyZWFtLnByb3RvdHlwZS5yZWR1Y2VCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgbmV3TGVuZ3RoKSB7XG5cdHZhciBzbWFsbEI7XG5cdHNtYWxsQiA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG5cdHNtYWxsQi5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIG5ld0xlbmd0aCkpO1xuXHRzbWFsbEIuYnVmZmVyLmZpbGVTdGFydCA9IGJ1ZmZlci5maWxlU3RhcnQrb2Zmc2V0O1xuXHRzbWFsbEIuYnVmZmVyLnVzZWRCeXRlcyA9IDA7XG5cdHJldHVybiBzbWFsbEIuYnVmZmVyO1x0XG59O1xuXG4vKipcbiAqIEluc2VydHMgdGhlIG5ldyBidWZmZXIgaW4gdGhlIHNvcnRlZCBsaXN0IG9mIGJ1ZmZlcnMsXG4gKiAgbWFraW5nIHN1cmUsIGl0IGlzIG5vdCBvdmVybGFwcGluZyB3aXRoIGV4aXN0aW5nIG9uZXMgKHBvc3NpYmx5IHJlZHVjaW5nIGl0cyBzaXplKS5cbiAqICBpZiB0aGUgbmV3IGJ1ZmZlciBvdmVycmlkZXMvcmVwbGFjZXMgdGhlIDAtdGggYnVmZmVyIChmb3IgaW5zdGFuY2UgYmVjYXVzZSBpdCBpcyBiaWdnZXIpLCBcbiAqICB1cGRhdGVzIHRoZSBEYXRhU3RyZWFtIGJ1ZmZlciBmb3IgcGFyc2luZyBcbiovXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuaW5zZXJ0QnVmZmVyID0gZnVuY3Rpb24oYWIpIHtcdFxuXHR2YXIgdG9fYWRkID0gdHJ1ZTtcblx0LyogVE9ETzogaW1wcm92ZSBpbnNlcnRpb24gaWYgbWFueSBidWZmZXJzICovXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGIgPSB0aGlzLmJ1ZmZlcnNbaV07XG5cdFx0aWYgKGFiLmZpbGVTdGFydCA8PSBiLmZpbGVTdGFydCkge1xuXHRcdFx0LyogdGhlIGluc2VydGlvbiBwb3NpdGlvbiBpcyBmb3VuZCAqL1xuXHRcdFx0aWYgKGFiLmZpbGVTdGFydCA9PT0gYi5maWxlU3RhcnQpIHtcblx0XHRcdFx0LyogVGhlIG5ldyBidWZmZXIgb3ZlcmxhcHMgd2l0aCBhbiBleGlzdGluZyBidWZmZXIgKi9cblx0XHRcdFx0aWYgKGFiLmJ5dGVMZW5ndGggPiAgYi5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0LyogdGhlIG5ldyBidWZmZXIgaXMgYmlnZ2VyIHRoYW4gdGhlIGV4aXN0aW5nIG9uZVxuXHRcdFx0XHRcdCAgIHJlbW92ZSB0aGUgZXhpc3RpbmcgYnVmZmVyIGFuZCB0cnkgYWdhaW4gdG8gaW5zZXJ0IFxuXHRcdFx0XHRcdCAgIHRoZSBuZXcgYnVmZmVyIHRvIGNoZWNrIG92ZXJsYXAgd2l0aCB0aGUgbmV4dCBvbmVzICovXG5cdFx0XHRcdFx0dGhpcy5idWZmZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRpLS07IFxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIHRoZSBuZXcgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGUgZXhpc3Rpbmcgb25lLCBqdXN0IGRyb3AgaXQgKi9cblx0XHRcdFx0XHRMb2cud2FybihcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiQnVmZmVyIChmaWxlU3RhcnQ6IFwiK2FiLmZpbGVTdGFydCtcIiAtIExlbmd0aDogXCIrYWIuYnl0ZUxlbmd0aCtcIikgYWxyZWFkeSBhcHBlbmRlZCwgaWdub3JpbmdcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIFRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgaXMgbm90IG92ZXJsYXBwaW5nIHdpdGggYW4gZXhpc3RpbmcgYnVmZmVyXG5cdFx0XHRcdCAgIGxldCdzIGNoZWNrIHRoZSBlbmQgb2YgaXQgKi9cblx0XHRcdFx0aWYgKGFiLmZpbGVTdGFydCArIGFiLmJ5dGVMZW5ndGggPD0gYi5maWxlU3RhcnQpIDsgZWxzZSB7XG5cdFx0XHRcdFx0LyogVGhlcmUgaXMgc29tZSBvdmVybGFwLCBjdXQgdGhlIG5ldyBidWZmZXIgc2hvcnQsIGFuZCBhZGQgaXQqL1xuXHRcdFx0XHRcdGFiID0gdGhpcy5yZWR1Y2VCdWZmZXIoYWIsIDAsIGIuZmlsZVN0YXJ0IC0gYWIuZmlsZVN0YXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRMb2cuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIkFwcGVuZGluZyBuZXcgYnVmZmVyIChmaWxlU3RhcnQ6IFwiK2FiLmZpbGVTdGFydCtcIiAtIExlbmd0aDogXCIrYWIuYnl0ZUxlbmd0aCtcIilcIik7XG5cdFx0XHRcdHRoaXMuYnVmZmVycy5zcGxpY2UoaSwgMCwgYWIpO1xuXHRcdFx0XHQvKiBpZiB0aGlzIG5ldyBidWZmZXIgaXMgaW5zZXJ0ZWQgaW4gdGhlIGZpcnN0IHBsYWNlIGluIHRoZSBsaXN0IG9mIHRoZSBidWZmZXIsIFxuXHRcdFx0XHQgICBhbmQgdGhlIERhdGFTdHJlYW0gaXMgaW5pdGlhbGl6ZWQsIG1ha2UgaXQgdGhlIGJ1ZmZlciB1c2VkIGZvciBwYXJzaW5nICovXG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5idWZmZXIgPSBhYjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG9fYWRkID0gZmFsc2U7XG5cdFx0XHRicmVhaztcblx0XHR9IGVsc2UgaWYgKGFiLmZpbGVTdGFydCA8IGIuZmlsZVN0YXJ0ICsgYi5ieXRlTGVuZ3RoKSB7XG5cdFx0XHQvKiB0aGUgbmV3IGJ1ZmZlciBvdmVybGFwcyBpdHMgYmVnaW5uaW5nIHdpdGggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgKi9cblx0XHRcdHZhciBvZmZzZXQgPSBiLmZpbGVTdGFydCArIGIuYnl0ZUxlbmd0aCAtIGFiLmZpbGVTdGFydDtcblx0XHRcdHZhciBuZXdMZW5ndGggPSBhYi5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0aWYgKG5ld0xlbmd0aCA+IDApIHtcblx0XHRcdFx0LyogdGhlIG5ldyBidWZmZXIgaXMgYmlnZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb3ZlcmxhcCwgZHJvcCB0aGUgb3ZlcmxhcHBpbmcgcGFydCBhbmQgdHJ5IGFnYWluIGluc2VydGluZyB0aGUgcmVtYWluaW5nIGJ1ZmZlciAqL1xuXHRcdFx0XHRhYiA9IHRoaXMucmVkdWNlQnVmZmVyKGFiLCBvZmZzZXQsIG5ld0xlbmd0aCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiB0aGUgY29udGVudCBvZiB0aGUgbmV3IGJ1ZmZlciBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gdGhlIGV4aXN0aW5nIGJ1ZmZlciwgZHJvcCBpdCBlbnRpcmVseSAqL1xuXHRcdFx0XHR0b19hZGQgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8qIGlmIHRoZSBidWZmZXIgaGFzIG5vdCBiZWVuIGFkZGVkLCB3ZSBjYW4gYWRkIGl0IGF0IHRoZSBlbmQgKi9cblx0aWYgKHRvX2FkZCkge1xuXHRcdExvZy5kZWJ1ZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiQXBwZW5kaW5nIG5ldyBidWZmZXIgKGZpbGVTdGFydDogXCIrYWIuZmlsZVN0YXJ0K1wiIC0gTGVuZ3RoOiBcIithYi5ieXRlTGVuZ3RoK1wiKVwiKTtcblx0XHR0aGlzLmJ1ZmZlcnMucHVzaChhYik7XG5cdFx0LyogaWYgdGhpcyBuZXcgYnVmZmVyIGlzIGluc2VydGVkIGluIHRoZSBmaXJzdCBwbGFjZSBpbiB0aGUgbGlzdCBvZiB0aGUgYnVmZmVyLCBcblx0XHQgICBhbmQgdGhlIERhdGFTdHJlYW0gaXMgaW5pdGlhbGl6ZWQsIG1ha2UgaXQgdGhlIGJ1ZmZlciB1c2VkIGZvciBwYXJzaW5nICovXG5cdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdHRoaXMuYnVmZmVyID0gYWI7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBzdGF0dXMgb2YgdGhlIGJ1ZmZlcnMgKG51bWJlciBhbmQgdXNlZCBieXRlcylcbiAqIEBwYXJhbSAge09iamVjdH0gaW5mbyBjYWxsYmFjayBtZXRob2QgZm9yIGRpc3BsYXlcbiAqL1xuTXVsdGlCdWZmZXJTdHJlYW0ucHJvdG90eXBlLmxvZ0J1ZmZlckxldmVsID0gZnVuY3Rpb24oaW5mbykge1xuXHR2YXIgaTtcblx0dmFyIGJ1ZmZlcjtcblx0dmFyIHVzZWQsIHRvdGFsO1xuXHR2YXIgcmFuZ2VzID0gW107XG5cdHZhciByYW5nZTtcblx0dmFyIGJ1ZmZlcmVkU3RyaW5nID0gXCJcIjtcblx0dXNlZCA9IDA7XG5cdHRvdGFsID0gMDtcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuXHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1tpXTtcblx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0cmFuZ2UgPSB7fTtcblx0XHRcdHJhbmdlcy5wdXNoKHJhbmdlKTtcblx0XHRcdHJhbmdlLnN0YXJ0ID0gYnVmZmVyLmZpbGVTdGFydDtcblx0XHRcdHJhbmdlLmVuZCA9IGJ1ZmZlci5maWxlU3RhcnQrYnVmZmVyLmJ5dGVMZW5ndGg7XG5cdFx0XHRidWZmZXJlZFN0cmluZyArPSBcIltcIityYW5nZS5zdGFydCtcIi1cIjtcblx0XHR9IGVsc2UgaWYgKHJhbmdlLmVuZCA9PT0gYnVmZmVyLmZpbGVTdGFydCkge1xuXHRcdFx0cmFuZ2UuZW5kID0gYnVmZmVyLmZpbGVTdGFydCtidWZmZXIuYnl0ZUxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFuZ2UgPSB7fTtcblx0XHRcdHJhbmdlLnN0YXJ0ID0gYnVmZmVyLmZpbGVTdGFydDtcblx0XHRcdGJ1ZmZlcmVkU3RyaW5nICs9IChyYW5nZXNbcmFuZ2VzLmxlbmd0aC0xXS5lbmQtMSkrXCJdLCBbXCIrcmFuZ2Uuc3RhcnQrXCItXCI7XG5cdFx0XHRyYW5nZS5lbmQgPSBidWZmZXIuZmlsZVN0YXJ0K2J1ZmZlci5ieXRlTGVuZ3RoO1xuXHRcdFx0cmFuZ2VzLnB1c2gocmFuZ2UpO1xuXHRcdH1cblx0XHR1c2VkICs9IGJ1ZmZlci51c2VkQnl0ZXM7XG5cdFx0dG90YWwgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cdH1cblx0aWYgKHJhbmdlcy5sZW5ndGggPiAwKSB7XG5cdFx0YnVmZmVyZWRTdHJpbmcgKz0gKHJhbmdlLmVuZC0xKStcIl1cIjtcblx0fVxuXHR2YXIgbG9nID0gKGluZm8gPyBMb2cuaW5mbyA6IExvZy5kZWJ1Zyk7XG5cdGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0bG9nKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJObyBtb3JlIGJ1ZmZlciBpbiBtZW1vcnlcIik7XG5cdH0gZWxzZSB7XG5cdFx0bG9nKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJcIit0aGlzLmJ1ZmZlcnMubGVuZ3RoK1wiIHN0b3JlZCBidWZmZXIocykgKFwiK3VzZWQrXCIvXCIrdG90YWwrXCIgYnl0ZXMpLCBjb250aW51b3VzIHJhbmdlczogXCIrYnVmZmVyZWRTdHJpbmcpO1xuXHR9XG59O1xuXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuY2xlYW5CdWZmZXJzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaTtcblx0dmFyIGJ1ZmZlcjtcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuXHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1tpXTtcblx0XHRpZiAoYnVmZmVyLnVzZWRCeXRlcyA9PT0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdExvZy5kZWJ1ZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiUmVtb3ZpbmcgYnVmZmVyICNcIitpKTtcblx0XHRcdHRoaXMuYnVmZmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRpLS07XG5cdFx0fVxuXHR9XG59O1xuXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUubWVyZ2VOZXh0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cdHZhciBuZXh0X2J1ZmZlcjtcblx0aWYgKHRoaXMuYnVmZmVySW5kZXgrMSA8IHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcblx0XHRuZXh0X2J1ZmZlciA9IHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4KzFdO1xuXHRcdGlmIChuZXh0X2J1ZmZlci5maWxlU3RhcnQgPT09IHRoaXMuYnVmZmVyLmZpbGVTdGFydCArIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHRcdFx0dmFyIG9sZFVzZWRCeXRlcyA9IHRoaXMuYnVmZmVyLnVzZWRCeXRlcztcblx0XHRcdHZhciBvbGRGaWxlU3RhcnQgPSB0aGlzLmJ1ZmZlci5maWxlU3RhcnQ7XG5cdFx0XHR0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJJbmRleF0gPSBBcnJheUJ1ZmZlci5jb25jYXQodGhpcy5idWZmZXIsIG5leHRfYnVmZmVyKTtcblx0XHRcdHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXhdO1xuXHRcdFx0dGhpcy5idWZmZXJzLnNwbGljZSh0aGlzLmJ1ZmZlckluZGV4KzEsIDEpO1xuXHRcdFx0dGhpcy5idWZmZXIudXNlZEJ5dGVzID0gb2xkVXNlZEJ5dGVzOyAvKiBUT0RPOiBzaG91bGQgaXQgYmUgKz0gPyAqL1xuXHRcdFx0dGhpcy5idWZmZXIuZmlsZVN0YXJ0ID0gb2xkRmlsZVN0YXJ0O1xuXHRcdFx0TG9nLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkNvbmNhdGVuYXRpbmcgYnVmZmVyIGZvciBib3ggcGFyc2luZyAobGVuZ3RoOiBcIitvbGRMZW5ndGgrXCItPlwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgrXCIpXCIpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIFNlZWstcmVsYXRlZCBmdW5jdGlvbnNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEZpbmRzIHRoZSBidWZmZXIgdGhhdCBob2xkcyB0aGUgZ2l2ZW4gZmlsZSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9vbGVhbn0gZnJvbVN0YXJ0ICAgIGluZGljYXRlcyBpZiB0aGUgc2VhcmNoIHNob3VsZCBzdGFydCBmcm9tIHRoZSBjdXJyZW50IGJ1ZmZlciAoZmFsc2UpIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGZyb20gdGhlIGZpcnN0IGJ1ZmZlciAodHJ1ZSlcbiAqIEBwYXJhbSAge051bWJlcn0gIGZpbGVQb3NpdGlvbiBwb3NpdGlvbiBpbiB0aGUgZmlsZSB0byBzZWVrIHRvXG4gKiBAcGFyYW0gIHtCb29sZWFufSBtYXJrQXNVc2VkICAgaW5kaWNhdGVzIGlmIHRoZSBieXRlcyBpbiBiZXR3ZWVuIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCB0aGUgc2VlayBwb3NpdGlvbiBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgYmUgbWFya2VkIGFzIHVzZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGhvbGRpbmcgdGhlIHNlZWtlZCBmaWxlIHBvc2l0aW9uLCAtMSBpZiBub3QgZm91bmQuXG4gKi9cbk11bHRpQnVmZmVyU3RyZWFtLnByb3RvdHlwZS5maW5kUG9zaXRpb24gPSBmdW5jdGlvbihmcm9tU3RhcnQsIGZpbGVQb3NpdGlvbiwgbWFya0FzVXNlZCkge1xuXHR2YXIgaTtcblx0dmFyIGFidWZmZXIgPSBudWxsO1xuXHR2YXIgaW5kZXggPSAtMTtcblxuXHQvKiBmaW5kIHRoZSBidWZmZXIgd2l0aCB0aGUgbGFyZ2VzdCBwb3NpdGlvbiBzbWFsbGVyIHRoYW4gdGhlIGdpdmVuIHBvc2l0aW9uICovXG5cdGlmIChmcm9tU3RhcnQgPT09IHRydWUpIHtcblx0ICAgLyogdGhlIHJlcG9zaXRpb24gY2FuIGJlIGluIHRoZSBwYXN0LCB3ZSBuZWVkIHRvIGNoZWNrIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdCBvZiBidWZmZXJzICovXG5cdFx0aSA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0aSA9IHRoaXMuYnVmZmVySW5kZXg7XG5cdH1cblxuXHR3aGlsZSAoaSA8IHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcblx0XHRhYnVmZmVyID0gdGhpcy5idWZmZXJzW2ldO1xuXHRcdGlmIChhYnVmZmVyLmZpbGVTdGFydCA8PSBmaWxlUG9zaXRpb24pIHtcblx0XHRcdGluZGV4ID0gaTtcblx0XHRcdGlmIChtYXJrQXNVc2VkKSB7XG5cdFx0XHRcdGlmIChhYnVmZmVyLmZpbGVTdGFydCArIGFidWZmZXIuYnl0ZUxlbmd0aCA8PSBmaWxlUG9zaXRpb24pIHtcblx0XHRcdFx0XHRhYnVmZmVyLnVzZWRCeXRlcyA9IGFidWZmZXIuYnl0ZUxlbmd0aDtcdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFidWZmZXIudXNlZEJ5dGVzID0gZmlsZVBvc2l0aW9uIC0gYWJ1ZmZlci5maWxlU3RhcnQ7XG5cdFx0XHRcdH1cdFx0XG5cdFx0XHRcdHRoaXMubG9nQnVmZmVyTGV2ZWwoKTtcdFxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aSsrO1xuXHR9XG5cblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdGFidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbaW5kZXhdO1xuXHRcdGlmIChhYnVmZmVyLmZpbGVTdGFydCArIGFidWZmZXIuYnl0ZUxlbmd0aCA+PSBmaWxlUG9zaXRpb24pIHtcdFx0XHRcblx0XHRcdExvZy5kZWJ1ZyhcIk11bHRpQnVmZmVyU3RyZWFtXCIsIFwiRm91bmQgcG9zaXRpb24gaW4gZXhpc3RpbmcgYnVmZmVyICNcIitpbmRleCk7XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBsYXJnZXN0IGZpbGUgcG9zaXRpb24gY29udGFpbmVkIGluIGEgYnVmZmVyIG9yIGluIHRoZSBuZXh0IGJ1ZmZlcnMgaWYgdGhleSBhcmUgY29udGlndW91cyAobm8gZ2FwKVxuICogc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIGluZGV4IG9yIGZyb20gdGhlIGN1cnJlbnQgYnVmZmVyIGlmIHRoZSBpbmRleCBpcyBub3QgZ2l2ZW5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlucHV0aW5kZXggSW5kZXggb2YgdGhlIGJ1ZmZlciB0byBzdGFydCBmcm9tXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgVGhlIGxhcmdlc3QgZmlsZSBwb3NpdGlvbiBmb3VuZCBpbiB0aGUgYnVmZmVyc1xuICovXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuZmluZEVuZENvbnRpZ3VvdXNCdWYgPSBmdW5jdGlvbihpbnB1dGluZGV4KSB7XG5cdHZhciBpO1xuXHR2YXIgY3VycmVudEJ1Zjtcblx0dmFyIG5leHRCdWY7XG5cdHZhciBpbmRleCA9IChpbnB1dGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbnB1dGluZGV4IDogdGhpcy5idWZmZXJJbmRleCk7XG5cdGN1cnJlbnRCdWYgPSB0aGlzLmJ1ZmZlcnNbaW5kZXhdO1xuXHQvKiBmaW5kIHRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgZGF0YSAqL1xuXHRpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA+IGluZGV4KzEpIHtcblx0XHRmb3IgKGkgPSBpbmRleCsxOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRuZXh0QnVmID0gdGhpcy5idWZmZXJzW2ldO1xuXHRcdFx0aWYgKG5leHRCdWYuZmlsZVN0YXJ0ID09PSBjdXJyZW50QnVmLmZpbGVTdGFydCArIGN1cnJlbnRCdWYuYnl0ZUxlbmd0aCkge1xuXHRcdFx0XHRjdXJyZW50QnVmID0gbmV4dEJ1Zjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvKiByZXR1cm4gdGhlIHBvc2l0aW9uIG9mIGxhc3QgYnl0ZSBpbiB0aGUgZmlsZSB0aGF0IHdlIGhhdmUgKi9cblx0cmV0dXJuIGN1cnJlbnRCdWYuZmlsZVN0YXJ0ICsgY3VycmVudEJ1Zi5ieXRlTGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXJnZXN0IGZpbGUgcG9zaXRpb24gY29udGFpbmVkIGluIHRoZSBidWZmZXJzLCBsYXJnZXIgdGhhbiB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gcG9zIHRoZSBmaWxlIHBvc2l0aW9uIHRvIHN0YXJ0IGZyb21cbiAqIEByZXR1cm4ge051bWJlcn0gICAgIHRoZSBsYXJnZXN0IHBvc2l0aW9uIGluIHRoZSBjdXJyZW50IGJ1ZmZlciBvciBpbiB0aGUgYnVmZmVyIGFuZCB0aGUgbmV4dCBjb250aWd1b3VzIFxuICogICAgICAgICAgICAgICAgICAgICAgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIGdpdmVuIHBvc2l0aW9uXG4gKi9cbk11bHRpQnVmZmVyU3RyZWFtLnByb3RvdHlwZS5nZXRFbmRGaWxlUG9zaXRpb25BZnRlciA9IGZ1bmN0aW9uKHBvcykge1xuXHR2YXIgaW5kZXggPSB0aGlzLmZpbmRQb3NpdGlvbih0cnVlLCBwb3MsIGZhbHNlKTtcblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdHJldHVybiB0aGlzLmZpbmRFbmRDb250aWd1b3VzQnVmKGluZGV4KTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gcG9zO1xuXHR9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBHYXJiYWdlIGNvbGxlY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIE1hcmtzIGEgZ2l2ZW4gbnVtYmVyIG9mIGJ5dGVzIGFzIHVzZWQgaW4gdGhlIGN1cnJlbnQgYnVmZmVyIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBuYkJ5dGVzIFxuICovXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuYWRkVXNlZEJ5dGVzID0gZnVuY3Rpb24obmJCeXRlcykge1xuXHR0aGlzLmJ1ZmZlci51c2VkQnl0ZXMgKz0gbmJCeXRlcztcblx0dGhpcy5sb2dCdWZmZXJMZXZlbCgpO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgZW50aXJlIGN1cnJlbnQgYnVmZmVyIGFzIHVzZWQsIHJlYWR5IGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqL1xuTXVsdGlCdWZmZXJTdHJlYW0ucHJvdG90eXBlLnNldEFsbFVzZWRCeXRlcyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmJ1ZmZlci51c2VkQnl0ZXMgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHR0aGlzLmxvZ0J1ZmZlckxldmVsKCk7XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBDb21tb24gQVBJIGJldHdlZW4gTXVsdGlCdWZmZXJTdHJlYW0gYW5kIFNpbXBsZVN0cmVhbVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogVHJpZXMgdG8gc2VlayB0byBhIGdpdmVuIGZpbGUgcG9zaXRpb25cbiAqIGlmIHBvc3NpYmxlLCByZXBvc2l0aW9ucyB0aGUgcGFyc2luZyBmcm9tIHRoZXJlIGFuZCByZXR1cm5zIHRydWUgXG4gKiBpZiBub3QgcG9zc2libGUsIGRvZXMgbm90IGNoYW5nZSBhbnl0aGluZyBhbmQgcmV0dXJucyBmYWxzZSBcbiAqIEBwYXJhbSAge051bWJlcn0gIGZpbGVQb3NpdGlvbiBwb3NpdGlvbiBpbiB0aGUgZmlsZSB0byBzZWVrIHRvXG4gKiBAcGFyYW0gIHtCb29sZWFufSBmcm9tU3RhcnQgICAgaW5kaWNhdGVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIHN0YXJ0IGZyb20gdGhlIGN1cnJlbnQgYnVmZmVyIChmYWxzZSkgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgZnJvbSB0aGUgZmlyc3QgYnVmZmVyICh0cnVlKVxuICogQHBhcmFtICB7Qm9vbGVhbn0gbWFya0FzVXNlZCAgIGluZGljYXRlcyBpZiB0aGUgYnl0ZXMgaW4gYmV0d2VlbiB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgdGhlIHNlZWsgcG9zaXRpb24gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIG1hcmtlZCBhcyB1c2VkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICB0cnVlIGlmIHRoZSBzZWVrIHN1Y2NlZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbk11bHRpQnVmZmVyU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24oZmlsZVBvc2l0aW9uLCBmcm9tU3RhcnQsIG1hcmtBc1VzZWQpIHtcblx0dmFyIGluZGV4O1xuXHRpbmRleCA9IHRoaXMuZmluZFBvc2l0aW9uKGZyb21TdGFydCwgZmlsZVBvc2l0aW9uLCBtYXJrQXNVc2VkKTtcblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXJzW2luZGV4XTtcblx0XHR0aGlzLmJ1ZmZlckluZGV4ID0gaW5kZXg7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IGZpbGVQb3NpdGlvbiAtIHRoaXMuYnVmZmVyLmZpbGVTdGFydDtcblx0XHRMb2cuZGVidWcoXCJNdWx0aUJ1ZmZlclN0cmVhbVwiLCBcIlJlcG9zaXRpb25pbmcgcGFyc2VyIGF0IGJ1ZmZlciBwb3NpdGlvbjogXCIrdGhpcy5wb3NpdGlvbik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gZWxzZSB7XG5cdFx0TG9nLmRlYnVnKFwiTXVsdGlCdWZmZXJTdHJlYW1cIiwgXCJQb3NpdGlvbiBcIitmaWxlUG9zaXRpb24rXCIgbm90IGZvdW5kIGluIGJ1ZmZlcmVkIGRhdGFcIik7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGZpbGVcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHBvc2l0aW9uIGluIHRoZSBmaWxlXG4gKi9cbk11bHRpQnVmZmVyU3RyZWFtLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5idWZmZXJJbmRleCA9PT0gLTEgfHwgdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVySW5kZXhdID09PSBudWxsKSB7XG5cdFx0dGhyb3cgXCJFcnJvciBhY2Nlc3NpbmcgcG9zaXRpb24gaW4gdGhlIE11bHRpQnVmZmVyU3RyZWFtXCI7XG5cdH1cblx0cmV0dXJuIHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4XS5maWxlU3RhcnQrdGhpcy5wb3NpdGlvbjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGJ1ZmZlclxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGJ1ZmZlclxuICovXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmJ5dGVMZW5ndGg7XG59O1xuXG5NdWx0aUJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuZ2V0RW5kUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuYnVmZmVySW5kZXggPT09IC0xIHx8IHRoaXMuYnVmZmVyc1t0aGlzLmJ1ZmZlckluZGV4XSA9PT0gbnVsbCkge1xuXHRcdHRocm93IFwiRXJyb3IgYWNjZXNzaW5nIHBvc2l0aW9uIGluIHRoZSBNdWx0aUJ1ZmZlclN0cmVhbVwiO1xuXHR9XG5cdHJldHVybiB0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJJbmRleF0uZmlsZVN0YXJ0K3RoaXMuYnl0ZUxlbmd0aDtcbn07XG5cbntcblx0ZXhwb3J0cy5NdWx0aUJ1ZmZlclN0cmVhbSA9IE11bHRpQnVmZmVyU3RyZWFtO1xufS8vIGZpbGU6c3JjL2Rlc2NyaXB0b3IuanNcbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMy4gVGVsZWNvbSBQYXJpc1RlY2gvVFNJL01NL0dQQUMgQ3lyaWwgQ29uY29sYXRvXG4gKiBMaWNlbnNlOiBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGZpbGUpXG4gKi9cbnZhciBNUEVHNERlc2NyaXB0b3JQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBFU19EZXNjclRhZyBcdFx0XHQ9IDB4MDM7XG5cdHZhciBEZWNvZGVyQ29uZmlnRGVzY3JUYWcgXHQ9IDB4MDQ7XG5cdHZhciBEZWNTcGVjaWZpY0luZm9UYWcgXHRcdD0gMHgwNTtcblx0dmFyIFNMQ29uZmlnRGVzY3JUYWcgXHRcdD0gMHgwNjtcblxuXHR2YXIgZGVzY1RhZ1RvTmFtZSA9IFtdO1xuXHRkZXNjVGFnVG9OYW1lW0VTX0Rlc2NyVGFnXSBcdFx0XHRcdD0gXCJFU19EZXNjcmlwdG9yXCI7XG5cdGRlc2NUYWdUb05hbWVbRGVjb2RlckNvbmZpZ0Rlc2NyVGFnXSBcdD0gXCJEZWNvZGVyQ29uZmlnRGVzY3JpcHRvclwiO1xuXHRkZXNjVGFnVG9OYW1lW0RlY1NwZWNpZmljSW5mb1RhZ10gXHRcdD0gXCJEZWNvZGVyU3BlY2lmaWNJbmZvXCI7XG5cdGRlc2NUYWdUb05hbWVbU0xDb25maWdEZXNjclRhZ10gXHRcdD0gXCJTTENvbmZpZ0Rlc2NyaXB0b3JcIjtcblxuXHR0aGlzLmdldERlc2NyaXB0b3JOYW1lID0gZnVuY3Rpb24odGFnKSB7XG5cdFx0cmV0dXJuIGRlc2NUYWdUb05hbWVbdGFnXTtcblx0fTtcblxuXHR2YXIgdGhhdCA9IHRoaXM7XG5cdHZhciBjbGFzc2VzID0ge307XG5cblx0dGhpcy5wYXJzZU9uZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG5cdFx0dmFyIHNpemUgPSAwO1xuXHRcdHZhciB0YWc7XG5cdFx0dmFyIGRlc2M7XG5cdFx0dmFyIGJ5dGVSZWFkO1xuXHRcdHRhZyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHRieXRlUmVhZCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR3aGlsZSAoYnl0ZVJlYWQgJiAweDgwKSB7XG5cdFx0XHRzaXplID0gKGJ5dGVSZWFkICYgMHg3Rik8PDc7XG5cdFx0XHRieXRlUmVhZCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR9XG5cdFx0c2l6ZSArPSBieXRlUmVhZCAmIDB4N0Y7XG5cdFx0TG9nLmRlYnVnKFwiTVBFRzREZXNjcmlwdG9yUGFyc2VyXCIsIFwiRm91bmQgXCIrKGRlc2NUYWdUb05hbWVbdGFnXSB8fCBcIkRlc2NyaXB0b3IgXCIrdGFnKStcIiwgc2l6ZSBcIitzaXplK1wiIGF0IHBvc2l0aW9uIFwiK3N0cmVhbS5nZXRQb3NpdGlvbigpKTtcblx0XHRpZiAoZGVzY1RhZ1RvTmFtZVt0YWddKSB7XG5cdFx0XHRkZXNjID0gbmV3IGNsYXNzZXNbZGVzY1RhZ1RvTmFtZVt0YWddXShzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzYyA9IG5ldyBjbGFzc2VzLkRlc2NyaXB0b3Ioc2l6ZSk7XG5cdFx0fVxuXHRcdGRlc2MucGFyc2Uoc3RyZWFtKTtcblx0XHRyZXR1cm4gZGVzYztcblx0fTtcblxuXHRjbGFzc2VzLkRlc2NyaXB0b3IgPSBmdW5jdGlvbihfdGFnLCBfc2l6ZSkge1xuXHRcdHRoaXMudGFnID0gX3RhZztcblx0XHR0aGlzLnNpemUgPSBfc2l6ZTtcblx0XHR0aGlzLmRlc2NzID0gW107XG5cdH07XG5cblx0Y2xhc3Nlcy5EZXNjcmlwdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0XHR0aGlzLmRhdGEgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcblx0fTtcblxuXHRjbGFzc2VzLkRlc2NyaXB0b3IucHJvdG90eXBlLmZpbmREZXNjcmlwdG9yID0gZnVuY3Rpb24gKHRhZykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kZXNjcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuZGVzY3NbaV0udGFnID09IHRhZykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kZXNjc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0Y2xhc3Nlcy5EZXNjcmlwdG9yLnByb3RvdHlwZS5wYXJzZVJlbWFpbmluZ0Rlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuXHRcdHZhciBzdGFydCA9IHN0cmVhbS5wb3NpdGlvbjtcblx0XHR3aGlsZSAoc3RyZWFtLnBvc2l0aW9uIDwgc3RhcnQrdGhpcy5zaXplKSB7XG5cdFx0XHR2YXIgZGVzYyA9IHRoYXQucGFyc2VPbmVEZXNjcmlwdG9yKHN0cmVhbSk7XG5cdFx0XHR0aGlzLmRlc2NzLnB1c2goZGVzYyk7XG5cdFx0fVxuXHR9O1xuXG5cdGNsYXNzZXMuRVNfRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChzaXplKSB7XG5cdFx0Y2xhc3Nlcy5EZXNjcmlwdG9yLmNhbGwodGhpcywgRVNfRGVzY3JUYWcsIHNpemUpO1xuXHR9O1xuXG5cdGNsYXNzZXMuRVNfRGVzY3JpcHRvci5wcm90b3R5cGUgPSBuZXcgY2xhc3Nlcy5EZXNjcmlwdG9yKCk7XG5cblx0Y2xhc3Nlcy5FU19EZXNjcmlwdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRcdHRoaXMuRVNfSUQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdHRoaXMuZmxhZ3MgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0dGhpcy5zaXplIC09IDM7XG5cdFx0aWYgKHRoaXMuZmxhZ3MgJiAweDgwKSB7XG5cdFx0XHR0aGlzLmRlcGVuZHNPbl9FU19JRCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0XHR0aGlzLnNpemUgLT0gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5kZXBlbmRzT25fRVNfSUQgPSAwO1xuXHRcdH1cblx0XHRpZiAodGhpcy5mbGFncyAmIDB4NDApIHtcblx0XHRcdHZhciBsID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdFx0dGhpcy5VUkwgPSBzdHJlYW0ucmVhZFN0cmluZyhsKTtcblx0XHRcdHRoaXMuc2l6ZSAtPSBsKzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuVVJMID0gXCJcIjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZmxhZ3MgJiAweDIwKSB7XG5cdFx0XHR0aGlzLk9DUl9FU19JRCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0XHR0aGlzLnNpemUgLT0gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5PQ1JfRVNfSUQgPSAwO1xuXHRcdH1cblx0XHR0aGlzLnBhcnNlUmVtYWluaW5nRGVzY3JpcHRvcnMoc3RyZWFtKTtcblx0fTtcblxuXHRjbGFzc2VzLkVTX0Rlc2NyaXB0b3IucHJvdG90eXBlLmdldE9USSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRcdHZhciBkY2QgPSB0aGlzLmZpbmREZXNjcmlwdG9yKERlY29kZXJDb25maWdEZXNjclRhZyk7XG5cdFx0aWYgKGRjZCkge1xuXHRcdFx0cmV0dXJuIGRjZC5vdGk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fTtcblxuXHRjbGFzc2VzLkVTX0Rlc2NyaXB0b3IucHJvdG90eXBlLmdldEF1ZGlvQ29uZmlnID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdFx0dmFyIGRjZCA9IHRoaXMuZmluZERlc2NyaXB0b3IoRGVjb2RlckNvbmZpZ0Rlc2NyVGFnKTtcblx0XHRpZiAoIWRjZCkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIGRzaSA9IGRjZC5maW5kRGVzY3JpcHRvcihEZWNTcGVjaWZpY0luZm9UYWcpO1xuXHRcdGlmIChkc2kgJiYgZHNpLmRhdGEpIHtcblx0XHRcdHZhciBhdWRpb09iamVjdFR5cGUgPSAoZHNpLmRhdGFbMF0mIDB4RjgpID4+IDM7XG5cdFx0XHRpZiAoYXVkaW9PYmplY3RUeXBlID09PSAzMSAmJiBkc2kuZGF0YS5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRhdWRpb09iamVjdFR5cGUgPSAzMiArICgoZHNpLmRhdGFbMF0gJiAweDcpIDw8IDMpICsgKChkc2kuZGF0YVsxXSAmIDB4RTApID4+IDUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF1ZGlvT2JqZWN0VHlwZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdGNsYXNzZXMuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHRcdGNsYXNzZXMuRGVzY3JpcHRvci5jYWxsKHRoaXMsIERlY29kZXJDb25maWdEZXNjclRhZywgc2l6ZSk7XG5cdH07XG5cdGNsYXNzZXMuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IucHJvdG90eXBlID0gbmV3IGNsYXNzZXMuRGVzY3JpcHRvcigpO1xuXG5cdGNsYXNzZXMuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdFx0dGhpcy5vdGkgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0dGhpcy5zdHJlYW1UeXBlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMuYnVmZmVyU2l6ZSA9IHN0cmVhbS5yZWFkVWludDI0KCk7XG5cdFx0dGhpcy5tYXhCaXRyYXRlID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLmF2Z0JpdHJhdGUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuc2l6ZSAtPSAxMztcblx0XHR0aGlzLnBhcnNlUmVtYWluaW5nRGVzY3JpcHRvcnMoc3RyZWFtKTtcblx0fTtcblxuXHRjbGFzc2VzLkRlY29kZXJTcGVjaWZpY0luZm8gPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHRcdGNsYXNzZXMuRGVzY3JpcHRvci5jYWxsKHRoaXMsIERlY1NwZWNpZmljSW5mb1RhZywgc2l6ZSk7XG5cdH07XG5cdGNsYXNzZXMuRGVjb2RlclNwZWNpZmljSW5mby5wcm90b3R5cGUgPSBuZXcgY2xhc3Nlcy5EZXNjcmlwdG9yKCk7XG5cblx0Y2xhc3Nlcy5TTENvbmZpZ0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHRcdGNsYXNzZXMuRGVzY3JpcHRvci5jYWxsKHRoaXMsIFNMQ29uZmlnRGVzY3JUYWcsIHNpemUpO1xuXHR9O1xuXHRjbGFzc2VzLlNMQ29uZmlnRGVzY3JpcHRvci5wcm90b3R5cGUgPSBuZXcgY2xhc3Nlcy5EZXNjcmlwdG9yKCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG57XG5cdGV4cG9ydHMuTVBFRzREZXNjcmlwdG9yUGFyc2VyID0gTVBFRzREZXNjcmlwdG9yUGFyc2VyO1xufS8vIGZpbGU6c3JjL2JveC5qc1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzLiBUZWxlY29tIFBhcmlzVGVjaC9UU0kvTU0vR1BBQyBDeXJpbCBDb25jb2xhdG9cbiAqIExpY2Vuc2U6IEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgZmlsZSlcbiAqL1xudmFyIEJveFBhcnNlciA9IHtcblx0RVJSX0lOVkFMSURfREFUQSA6IC0xLFxuXHRFUlJfTk9UX0VOT1VHSF9EQVRBIDogMCxcblx0T0sgOiAxLFxuXG5cdC8vIEJveGVzIHRvIGJlIGNyZWF0ZWQgd2l0aCBkZWZhdWx0IHBhcnNpbmdcblx0QkFTSUNfQk9YRVM6IFsgXCJtZGF0XCIsIFwiaWRhdFwiLCBcImZyZWVcIiwgXCJza2lwXCIsIFwibWVjb1wiLCBcInN0cmtcIiBdLFxuXHRGVUxMX0JPWEVTOiBbIFwiaG1oZFwiLCBcIm5taGRcIiwgXCJpb2RzXCIsIFwieG1sIFwiLCBcImJ4bWxcIiwgXCJpcHJvXCIsIFwibWVyZVwiIF0sXG5cdENPTlRBSU5FUl9CT1hFUzogW1xuXHRcdFsgXCJtb292XCIsIFsgXCJ0cmFrXCIsIFwicHNzaFwiIF0gXSxcblx0XHRbIFwidHJha1wiIF0sXG5cdFx0WyBcImVkdHNcIiBdLFxuXHRcdFsgXCJtZGlhXCIgXSxcblx0XHRbIFwibWluZlwiIF0sXG5cdFx0WyBcImRpbmZcIiBdLFxuXHRcdFsgXCJzdGJsXCIsIFsgXCJzZ3BkXCIsIFwic2JncFwiIF0gXSxcblx0XHRbIFwibXZleFwiLCBbIFwidHJleFwiIF0gXSxcblx0XHRbIFwibW9vZlwiLCBbIFwidHJhZlwiIF0gXSxcblx0XHRbIFwidHJhZlwiLCBbIFwidHJ1blwiLCBcInNncGRcIiwgXCJzYmdwXCIgXSBdLFxuXHRcdFsgXCJ2dHRjXCIgXSxcblx0XHRbIFwidHJlZlwiIF0sXG5cdFx0WyBcImlyZWZcIiBdLFxuXHRcdFsgXCJtZnJhXCIsIFsgXCJ0ZnJhXCIgXSBdLFxuXHRcdFsgXCJtZWNvXCIgXSxcblx0XHRbIFwiaG50aVwiIF0sXG5cdFx0WyBcImhpbmZcIiBdLFxuXHRcdFsgXCJzdHJrXCIgXSxcblx0XHRbIFwic3RyZFwiIF0sXG5cdFx0WyBcInNpbmZcIiBdLFxuXHRcdFsgXCJyaW5mXCIgXSxcblx0XHRbIFwic2NoaVwiIF0sXG5cdFx0WyBcInRyZ3JcIiBdLFxuXHRcdFsgXCJ1ZHRhXCIsIFtcImtpbmRcIl0gXSxcblx0XHRbIFwiaXBycFwiLCBbXCJpcG1hXCJdIF0sXG5cdFx0WyBcImlwY29cIl1cblx0XSxcblx0Ly8gQm94ZXMgZWZmZWN0aXZlbHkgY3JlYXRlZFxuXHRib3hDb2RlcyA6IFtdLFxuXHRmdWxsQm94Q29kZXMgOiBbXSxcblx0Y29udGFpbmVyQm94Q29kZXMgOiBbXSxcblx0c2FtcGxlRW50cnlDb2RlcyA6IHt9LFxuXHRzYW1wbGVHcm91cEVudHJ5Q29kZXM6IFtdLFxuXHR0cmFja0dyb3VwVHlwZXM6IFtdLFxuXHRVVUlEQm94ZXM6IHt9LFxuXHRVVUlEczogW10sXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdEJveFBhcnNlci5GdWxsQm94LnByb3RvdHlwZSA9IG5ldyBCb3hQYXJzZXIuQm94KCk7XG5cdFx0Qm94UGFyc2VyLkNvbnRhaW5lckJveC5wcm90b3R5cGUgPSBuZXcgQm94UGFyc2VyLkJveCgpO1xuXHRcdEJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUgPSBuZXcgQm94UGFyc2VyLkJveCgpO1xuXHRcdEJveFBhcnNlci5UcmFja0dyb3VwVHlwZUJveC5wcm90b3R5cGUgPSBuZXcgQm94UGFyc2VyLkZ1bGxCb3goKTtcblxuXHRcdC8qIGNyZWF0aW5nIGNvbnN0cnVjdG9ycyBmb3Igc2ltcGxlIGJveGVzICovXG5cdFx0Qm94UGFyc2VyLkJBU0lDX0JPWEVTLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0Qm94UGFyc2VyLmNyZWF0ZUJveEN0b3IodHlwZSk7XG5cdFx0fSk7XG5cdFx0Qm94UGFyc2VyLkZVTExfQk9YRVMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRCb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IodHlwZSk7XG5cdFx0fSk7XG5cdFx0Qm94UGFyc2VyLkNPTlRBSU5FUl9CT1hFUy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGVzKSB7XG5cdFx0XHRCb3hQYXJzZXIuY3JlYXRlQ29udGFpbmVyQm94Q3Rvcih0eXBlc1swXSwgbnVsbCwgdHlwZXNbMV0pO1xuXHRcdH0pO1xuXHR9LFxuXHRCb3g6IGZ1bmN0aW9uKF90eXBlLCBfc2l6ZSwgX3V1aWQpIHtcblx0XHR0aGlzLnR5cGUgPSBfdHlwZTtcblx0XHR0aGlzLnNpemUgPSBfc2l6ZTtcblx0XHR0aGlzLnV1aWQgPSBfdXVpZDtcblx0fSxcblx0RnVsbEJveDogZnVuY3Rpb24odHlwZSwgc2l6ZSwgdXVpZCkge1xuXHRcdEJveFBhcnNlci5Cb3guY2FsbCh0aGlzLCB0eXBlLCBzaXplLCB1dWlkKTtcblx0XHR0aGlzLmZsYWdzID0gMDtcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXHR9LFxuXHRDb250YWluZXJCb3g6IGZ1bmN0aW9uKHR5cGUsIHNpemUsIHV1aWQpIHtcblx0XHRCb3hQYXJzZXIuQm94LmNhbGwodGhpcywgdHlwZSwgc2l6ZSwgdXVpZCk7XG5cdFx0dGhpcy5ib3hlcyA9IFtdO1xuXHR9LFxuXHRTYW1wbGVFbnRyeTogZnVuY3Rpb24odHlwZSwgc2l6ZSwgaGRyX3NpemUsIHN0YXJ0KSB7XG5cdFx0Qm94UGFyc2VyLkNvbnRhaW5lckJveC5jYWxsKHRoaXMsIHR5cGUsIHNpemUpO1xuXHRcdHRoaXMuaGRyX3NpemUgPSBoZHJfc2l6ZTtcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdH0sXG5cdFNhbXBsZUdyb3VwRW50cnk6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR0aGlzLmdyb3VwaW5nX3R5cGUgPSB0eXBlO1xuXHR9LFxuXHRUcmFja0dyb3VwVHlwZUJveDogZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuXHRcdEJveFBhcnNlci5GdWxsQm94LmNhbGwodGhpcywgdHlwZSwgc2l6ZSk7XG5cdH0sXG5cdGNyZWF0ZUJveEN0b3I6IGZ1bmN0aW9uKHR5cGUsIHBhcnNlTWV0aG9kKXtcblx0XHRCb3hQYXJzZXIuYm94Q29kZXMucHVzaCh0eXBlKTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIkJveFwiXSA9IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRcdEJveFBhcnNlci5Cb3guY2FsbCh0aGlzLCB0eXBlLCBzaXplKTtcblx0XHR9O1xuXHRcdEJveFBhcnNlclt0eXBlK1wiQm94XCJdLnByb3RvdHlwZSA9IG5ldyBCb3hQYXJzZXIuQm94KCk7XG5cdFx0aWYgKHBhcnNlTWV0aG9kKSBCb3hQYXJzZXJbdHlwZStcIkJveFwiXS5wcm90b3R5cGUucGFyc2UgPSBwYXJzZU1ldGhvZDtcblx0fSxcblx0Y3JlYXRlRnVsbEJveEN0b3I6IGZ1bmN0aW9uKHR5cGUsIHBhcnNlTWV0aG9kKSB7XG5cdFx0Ly9Cb3hQYXJzZXIuZnVsbEJveENvZGVzLnB1c2godHlwZSk7XG5cdFx0Qm94UGFyc2VyW3R5cGUrXCJCb3hcIl0gPSBmdW5jdGlvbihzaXplKSB7XG5cdFx0XHRCb3hQYXJzZXIuRnVsbEJveC5jYWxsKHRoaXMsIHR5cGUsIHNpemUpO1xuXHRcdH07XG5cdFx0Qm94UGFyc2VyW3R5cGUrXCJCb3hcIl0ucHJvdG90eXBlID0gbmV3IEJveFBhcnNlci5GdWxsQm94KCk7XG5cdFx0Qm94UGFyc2VyW3R5cGUrXCJCb3hcIl0ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdFx0XHR0aGlzLnBhcnNlRnVsbEhlYWRlcihzdHJlYW0pO1xuXHRcdFx0aWYgKHBhcnNlTWV0aG9kKSB7XG5cdFx0XHRcdHBhcnNlTWV0aG9kLmNhbGwodGhpcywgc3RyZWFtKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXHRhZGRTdWJCb3hBcnJheXM6IGZ1bmN0aW9uKHN1YkJveE5hbWVzKSB7XG5cdFx0aWYgKHN1YkJveE5hbWVzKSB7XG5cdFx0XHR0aGlzLnN1YkJveE5hbWVzID0gc3ViQm94TmFtZXM7XG5cdFx0XHR2YXIgbmJTdWJCb3hlcyA9IHN1YkJveE5hbWVzLmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGsgPSAwOyBrPG5iU3ViQm94ZXM7IGsrKykge1xuXHRcdFx0XHR0aGlzW3N1YkJveE5hbWVzW2tdK1wic1wiXSA9IFtdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0Y3JlYXRlQ29udGFpbmVyQm94Q3RvcjogZnVuY3Rpb24odHlwZSwgcGFyc2VNZXRob2QsIHN1YkJveE5hbWVzKSB7XG5cdFx0Ly9Cb3hQYXJzZXIuY29udGFpbmVyQm94Q29kZXMucHVzaCh0eXBlKTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIkJveFwiXSA9IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRcdEJveFBhcnNlci5Db250YWluZXJCb3guY2FsbCh0aGlzLCB0eXBlLCBzaXplKTtcblx0XHRcdEJveFBhcnNlci5hZGRTdWJCb3hBcnJheXMuY2FsbCh0aGlzLCBzdWJCb3hOYW1lcyk7XG5cdFx0fTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIkJveFwiXS5wcm90b3R5cGUgPSBuZXcgQm94UGFyc2VyLkNvbnRhaW5lckJveCgpO1xuXHRcdGlmIChwYXJzZU1ldGhvZCkgQm94UGFyc2VyW3R5cGUrXCJCb3hcIl0ucHJvdG90eXBlLnBhcnNlID0gcGFyc2VNZXRob2Q7XG5cdH0sXG5cdGNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yOiBmdW5jdGlvbihtZWRpYVR5cGUsIHBhcnNlTWV0aG9kLCBzdWJCb3hOYW1lcykge1xuXHRcdEJveFBhcnNlci5zYW1wbGVFbnRyeUNvZGVzW21lZGlhVHlwZV0gPSBbXTtcblx0XHRCb3hQYXJzZXJbbWVkaWFUeXBlK1wiU2FtcGxlRW50cnlcIl0gPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG5cdFx0XHRCb3hQYXJzZXIuU2FtcGxlRW50cnkuY2FsbCh0aGlzLCB0eXBlLCBzaXplKTtcblx0XHRcdEJveFBhcnNlci5hZGRTdWJCb3hBcnJheXMuY2FsbCh0aGlzLCBzdWJCb3hOYW1lcyk7XG5cdFx0fTtcblx0XHRCb3hQYXJzZXJbbWVkaWFUeXBlK1wiU2FtcGxlRW50cnlcIl0ucHJvdG90eXBlID0gbmV3IEJveFBhcnNlci5TYW1wbGVFbnRyeSgpO1xuXHRcdGlmIChwYXJzZU1ldGhvZCkgQm94UGFyc2VyW21lZGlhVHlwZStcIlNhbXBsZUVudHJ5XCJdLnByb3RvdHlwZSAucGFyc2UgPSBwYXJzZU1ldGhvZDtcblx0fSxcblx0Y3JlYXRlU2FtcGxlRW50cnlDdG9yOiBmdW5jdGlvbihtZWRpYVR5cGUsIHR5cGUsIHBhcnNlTWV0aG9kLCBzdWJCb3hOYW1lcykge1xuXHRcdEJveFBhcnNlci5zYW1wbGVFbnRyeUNvZGVzW21lZGlhVHlwZV0ucHVzaCh0eXBlKTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIlNhbXBsZUVudHJ5XCJdID0gZnVuY3Rpb24oc2l6ZSkge1xuXHRcdFx0Qm94UGFyc2VyW21lZGlhVHlwZStcIlNhbXBsZUVudHJ5XCJdLmNhbGwodGhpcywgdHlwZSwgc2l6ZSk7XG5cdFx0XHRCb3hQYXJzZXIuYWRkU3ViQm94QXJyYXlzLmNhbGwodGhpcywgc3ViQm94TmFtZXMpO1xuXHRcdH07XG5cdFx0Qm94UGFyc2VyW3R5cGUrXCJTYW1wbGVFbnRyeVwiXS5wcm90b3R5cGUgPSBuZXcgQm94UGFyc2VyW21lZGlhVHlwZStcIlNhbXBsZUVudHJ5XCJdKCk7XG5cdFx0aWYgKHBhcnNlTWV0aG9kKSBCb3hQYXJzZXJbdHlwZStcIlNhbXBsZUVudHJ5XCJdLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlTWV0aG9kO1xuXHR9LFxuXHRjcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3I6IGZ1bmN0aW9uKG1lZGlhVHlwZSwgdHlwZSwgcGFyc2VNZXRob2QpIHtcblx0XHRCb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yLmNhbGwodGhpcywgbWVkaWFUeXBlLCB0eXBlLCBwYXJzZU1ldGhvZCwgW1wic2luZlwiXSk7XG5cdH0sXG5cdGNyZWF0ZVNhbXBsZUdyb3VwQ3RvcjogZnVuY3Rpb24odHlwZSwgcGFyc2VNZXRob2QpIHtcblx0XHQvL0JveFBhcnNlci5zYW1wbGVHcm91cEVudHJ5Q29kZXMucHVzaCh0eXBlKTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIlNhbXBsZUdyb3VwRW50cnlcIl0gPSBmdW5jdGlvbihzaXplKSB7XG5cdFx0XHRCb3hQYXJzZXIuU2FtcGxlR3JvdXBFbnRyeS5jYWxsKHRoaXMsIHR5cGUsIHNpemUpO1xuXHRcdH07XG5cdFx0Qm94UGFyc2VyW3R5cGUrXCJTYW1wbGVHcm91cEVudHJ5XCJdLnByb3RvdHlwZSA9IG5ldyBCb3hQYXJzZXIuU2FtcGxlR3JvdXBFbnRyeSgpO1xuXHRcdGlmIChwYXJzZU1ldGhvZCkgQm94UGFyc2VyW3R5cGUrXCJTYW1wbGVHcm91cEVudHJ5XCJdLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlTWV0aG9kO1xuXHR9LFxuXHRjcmVhdGVUcmFja0dyb3VwQ3RvcjogZnVuY3Rpb24odHlwZSwgcGFyc2VNZXRob2QpIHtcblx0XHQvL0JveFBhcnNlci50cmFja0dyb3VwVHlwZXMucHVzaCh0eXBlKTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIlRyYWNrR3JvdXBUeXBlQm94XCJdID0gZnVuY3Rpb24oc2l6ZSkge1xuXHRcdFx0Qm94UGFyc2VyLlRyYWNrR3JvdXBUeXBlQm94LmNhbGwodGhpcywgdHlwZSwgc2l6ZSk7XG5cdFx0fTtcblx0XHRCb3hQYXJzZXJbdHlwZStcIlRyYWNrR3JvdXBUeXBlQm94XCJdLnByb3RvdHlwZSA9IG5ldyBCb3hQYXJzZXIuVHJhY2tHcm91cFR5cGVCb3goKTtcblx0XHRpZiAocGFyc2VNZXRob2QpIEJveFBhcnNlclt0eXBlK1wiVHJhY2tHcm91cFR5cGVCb3hcIl0ucHJvdG90eXBlLnBhcnNlID0gcGFyc2VNZXRob2Q7XG5cdH0sXG5cdGNyZWF0ZVVVSURCb3g6IGZ1bmN0aW9uKHV1aWQsIGlzRnVsbEJveCwgaXNDb250YWluZXJCb3gsIHBhcnNlTWV0aG9kKSB7XG5cdFx0Qm94UGFyc2VyLlVVSURzLnB1c2godXVpZCk7XG5cdFx0Qm94UGFyc2VyLlVVSURCb3hlc1t1dWlkXSA9IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRcdGlmIChpc0Z1bGxCb3gpIHtcblx0XHRcdFx0Qm94UGFyc2VyLkZ1bGxCb3guY2FsbCh0aGlzLCBcInV1aWRcIiwgc2l6ZSwgdXVpZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaXNDb250YWluZXJCb3gpIHtcblx0XHRcdFx0XHRCb3hQYXJzZXIuQ29udGFpbmVyQm94LmNhbGwodGhpcywgXCJ1dWlkXCIsIHNpemUsIHV1aWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdEJveFBhcnNlci5Cb3guY2FsbCh0aGlzLCBcInV1aWRcIiwgc2l6ZSwgdXVpZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdEJveFBhcnNlci5VVUlEQm94ZXNbdXVpZF0ucHJvdG90eXBlID0gKGlzRnVsbEJveCA/IG5ldyBCb3hQYXJzZXIuRnVsbEJveCgpIDogKGlzQ29udGFpbmVyQm94ID8gbmV3IEJveFBhcnNlci5Db250YWluZXJCb3goKSA6IG5ldyBCb3hQYXJzZXIuQm94KCkpKTtcblx0XHRpZiAocGFyc2VNZXRob2QpIHtcblx0XHRcdGlmIChpc0Z1bGxCb3gpIHtcblx0XHRcdFx0Qm94UGFyc2VyLlVVSURCb3hlc1t1dWlkXS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0XHRcdFx0XHR0aGlzLnBhcnNlRnVsbEhlYWRlcihzdHJlYW0pO1xuXHRcdFx0XHRcdGlmIChwYXJzZU1ldGhvZCkge1xuXHRcdFx0XHRcdFx0cGFyc2VNZXRob2QuY2FsbCh0aGlzLCBzdHJlYW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEJveFBhcnNlci5VVUlEQm94ZXNbdXVpZF0ucHJvdG90eXBlLnBhcnNlID0gcGFyc2VNZXRob2Q7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5Cb3hQYXJzZXIuaW5pdGlhbGl6ZSgpO1xuXG5Cb3hQYXJzZXIuVEtIRF9GTEFHX0VOQUJMRUQgICAgPSAweDAwMDAwMTtcbkJveFBhcnNlci5US0hEX0ZMQUdfSU5fTU9WSUUgICA9IDB4MDAwMDAyO1xuQm94UGFyc2VyLlRLSERfRkxBR19JTl9QUkVWSUVXID0gMHgwMDAwMDQ7XG5cbkJveFBhcnNlci5URkhEX0ZMQUdfQkFTRV9EQVRBX09GRlNFVFx0PSAweDAxO1xuQm94UGFyc2VyLlRGSERfRkxBR19TQU1QTEVfREVTQ1x0XHRcdD0gMHgwMjtcbkJveFBhcnNlci5URkhEX0ZMQUdfU0FNUExFX0RVUlx0XHRcdD0gMHgwODtcbkJveFBhcnNlci5URkhEX0ZMQUdfU0FNUExFX1NJWkVcdFx0XHQ9IDB4MTA7XG5Cb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9GTEFHU1x0XHQ9IDB4MjA7XG5Cb3hQYXJzZXIuVEZIRF9GTEFHX0RVUl9FTVBUWVx0XHRcdD0gMHgxMDAwMDtcbkJveFBhcnNlci5URkhEX0ZMQUdfREVGQVVMVF9CQVNFX0lTX01PT0Y9IDB4MjAwMDA7XG5cbkJveFBhcnNlci5UUlVOX0ZMQUdTX0RBVEFfT0ZGU0VUPSAweDAxO1xuQm94UGFyc2VyLlRSVU5fRkxBR1NfRklSU1RfRkxBR1x0PSAweDA0O1xuQm94UGFyc2VyLlRSVU5fRkxBR1NfRFVSQVRJT05cdD0gMHgxMDA7XG5Cb3hQYXJzZXIuVFJVTl9GTEFHU19TSVpFXHRcdD0gMHgyMDA7XG5Cb3hQYXJzZXIuVFJVTl9GTEFHU19GTEFHU1x0XHQ9IDB4NDAwO1xuQm94UGFyc2VyLlRSVU5fRkxBR1NfQ1RTX09GRlNFVFx0PSAweDgwMDtcblxuQm94UGFyc2VyLkJveC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSkge1xuXHRyZXR1cm4gdGhpcy5hZGRCb3gobmV3IEJveFBhcnNlcltuYW1lK1wiQm94XCJdKCkpO1xufTtcblxuQm94UGFyc2VyLkJveC5wcm90b3R5cGUuYWRkQm94ID0gZnVuY3Rpb24oYm94KSB7XG5cdHRoaXMuYm94ZXMucHVzaChib3gpO1xuXHRpZiAodGhpc1tib3gudHlwZStcInNcIl0pIHtcblx0XHR0aGlzW2JveC50eXBlK1wic1wiXS5wdXNoKGJveCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpc1tib3gudHlwZV0gPSBib3g7XG5cdH1cblx0cmV0dXJuIGJveDtcbn07XG5cbkJveFBhcnNlci5Cb3gucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG5cdHRoaXNbcHJvcF0gPSB2YWx1ZTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5Cb3hQYXJzZXIuQm94LnByb3RvdHlwZS5hZGRFbnRyeSA9IGZ1bmN0aW9uKHZhbHVlLCBfcHJvcCkge1xuXHR2YXIgcHJvcCA9IF9wcm9wIHx8IFwiZW50cmllc1wiO1xuXHRpZiAoIXRoaXNbcHJvcF0pIHtcblx0XHR0aGlzW3Byb3BdID0gW107XG5cdH1cblx0dGhpc1twcm9wXS5wdXNoKHZhbHVlKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG57XG5cdGV4cG9ydHMuQm94UGFyc2VyID0gQm94UGFyc2VyO1xufVxuLy8gZmlsZTpzcmMvYm94LXBhcnNlLmpzXG4vKiBcbiAqIENvcHlyaWdodCAoYykgVGVsZWNvbSBQYXJpc1RlY2gvVFNJL01NL0dQQUMgQ3lyaWwgQ29uY29sYXRvXG4gKiBMaWNlbnNlOiBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGZpbGUpXG4gKi9cbkJveFBhcnNlci5wYXJzZVVVSUQgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIEJveFBhcnNlci5wYXJzZUhleDE2KHN0cmVhbSk7XG59O1xuXG5Cb3hQYXJzZXIucGFyc2VIZXgxNiA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgaGV4MTYgPSBcIlwiO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8MTY7IGkrKykge1xuXHRcdHZhciBoZXggPSBzdHJlYW0ucmVhZFVpbnQ4KCkudG9TdHJpbmcoMTYpO1xuXHRcdGhleDE2ICs9IChoZXgubGVuZ3RoID09PSAxID8gXCIwXCIraGV4IDogaGV4KTtcblx0fVxuXHRyZXR1cm4gaGV4MTY7XG59O1xuXG5Cb3hQYXJzZXIucGFyc2VPbmVCb3ggPSBmdW5jdGlvbihzdHJlYW0sIGhlYWRlck9ubHksIHBhcmVudFNpemUpIHtcblx0dmFyIGJveDtcblx0dmFyIHN0YXJ0ID0gc3RyZWFtLmdldFBvc2l0aW9uKCk7XG5cdHZhciBoZHJfc2l6ZSA9IDA7XG5cdHZhciBkaWZmO1xuXHR2YXIgdXVpZDtcblx0aWYgKHN0cmVhbS5nZXRFbmRQb3NpdGlvbigpIC0gc3RhcnQgPCA4KSB7XG5cdFx0TG9nLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiTm90IGVub3VnaCBkYXRhIGluIHN0cmVhbSB0byBwYXJzZSB0aGUgdHlwZSBhbmQgc2l6ZSBvZiB0aGUgYm94XCIpO1xuXHRcdHJldHVybiB7IGNvZGU6IEJveFBhcnNlci5FUlJfTk9UX0VOT1VHSF9EQVRBIH07XG5cdH1cblx0aWYgKHBhcmVudFNpemUgJiYgcGFyZW50U2l6ZSA8IDgpIHtcblx0XHRMb2cuZGVidWcoXCJCb3hQYXJzZXJcIiwgXCJOb3QgZW5vdWdoIGJ5dGVzIGxlZnQgaW4gdGhlIHBhcmVudCBib3ggdG8gcGFyc2UgYSBuZXcgYm94XCIpO1xuXHRcdHJldHVybiB7IGNvZGU6IEJveFBhcnNlci5FUlJfTk9UX0VOT1VHSF9EQVRBIH07XG5cdH1cblx0dmFyIHNpemUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR2YXIgdHlwZSA9IHN0cmVhbS5yZWFkU3RyaW5nKDQpO1xuXHR2YXIgYm94X3R5cGUgPSB0eXBlO1xuXHRMb2cuZGVidWcoXCJCb3hQYXJzZXJcIiwgXCJGb3VuZCBib3ggb2YgdHlwZSAnXCIrdHlwZStcIicgYW5kIHNpemUgXCIrc2l6ZStcIiBhdCBwb3NpdGlvbiBcIitzdGFydCk7XG5cdGhkcl9zaXplID0gODtcblx0aWYgKHR5cGUgPT0gXCJ1dWlkXCIpIHtcblx0XHRpZiAoKHN0cmVhbS5nZXRFbmRQb3NpdGlvbigpIC0gc3RyZWFtLmdldFBvc2l0aW9uKCkgPCAxNikgfHwgKHBhcmVudFNpemUgLWhkcl9zaXplIDwgMTYpKSB7XG5cdFx0XHRzdHJlYW0uc2VlayhzdGFydCk7XG5cdFx0XHRMb2cuZGVidWcoXCJCb3hQYXJzZXJcIiwgXCJOb3QgZW5vdWdoIGJ5dGVzIGxlZnQgaW4gdGhlIHBhcmVudCBib3ggdG8gcGFyc2UgYSBVVUlEIGJveFwiKTtcblx0XHRcdHJldHVybiB7IGNvZGU6IEJveFBhcnNlci5FUlJfTk9UX0VOT1VHSF9EQVRBIH07XG5cdFx0fVxuXHRcdHV1aWQgPSBCb3hQYXJzZXIucGFyc2VVVUlEKHN0cmVhbSk7XG5cdFx0aGRyX3NpemUgKz0gMTY7XG5cdFx0Ym94X3R5cGUgPSB1dWlkO1xuXHR9XG5cdGlmIChzaXplID09IDEpIHtcblx0XHRpZiAoKHN0cmVhbS5nZXRFbmRQb3NpdGlvbigpIC0gc3RyZWFtLmdldFBvc2l0aW9uKCkgPCA4KSB8fCAocGFyZW50U2l6ZSAmJiAocGFyZW50U2l6ZSAtIGhkcl9zaXplKSA8IDgpKSB7XG5cdFx0XHRzdHJlYW0uc2VlayhzdGFydCk7XG5cdFx0XHRMb2cud2FybihcIkJveFBhcnNlclwiLCBcIk5vdCBlbm91Z2ggZGF0YSBpbiBzdHJlYW0gdG8gcGFyc2UgdGhlIGV4dGVuZGVkIHNpemUgb2YgdGhlIFxcXCJcIit0eXBlK1wiXFxcIiBib3hcIik7XG5cdFx0XHRyZXR1cm4geyBjb2RlOiBCb3hQYXJzZXIuRVJSX05PVF9FTk9VR0hfREFUQSB9O1xuXHRcdH1cblx0XHRzaXplID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHRoZHJfc2l6ZSArPSA4O1xuXHR9IGVsc2UgaWYgKHNpemUgPT09IDApIHtcblx0XHQvKiBib3ggZXh0ZW5kcyB0aWxsIHRoZSBlbmQgb2YgZmlsZSBvciBpbnZhbGlkIGZpbGUgKi9cblx0XHRpZiAocGFyZW50U2l6ZSkge1xuXHRcdFx0c2l6ZSA9IHBhcmVudFNpemU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIGJveCBleHRlbmRzIHRpbGwgdGhlIGVuZCBvZiBmaWxlICovXG5cdFx0XHRpZiAodHlwZSAhPT0gXCJtZGF0XCIpIHtcblx0XHRcdFx0TG9nLmVycm9yKFwiQm94UGFyc2VyXCIsIFwiVW5saW1pdGVkIGJveCBzaXplIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGU6ICdcIit0eXBlK1wiJ1wiKTtcblx0XHRcdFx0Ym94ID0gbmV3IEJveFBhcnNlci5Cb3godHlwZSwgc2l6ZSk7XG5cdFx0XHRcdHJldHVybiB7IGNvZGU6IEJveFBhcnNlci5PSywgYm94OiBib3gsIHNpemU6IGJveC5zaXplIH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChzaXplIDwgaGRyX3NpemUpIHtcblx0XHRMb2cuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJCb3ggb2YgdHlwZSBcIit0eXBlK1wiIGhhcyBhbiBpbnZhbGlkIHNpemUgXCIrc2l6ZStcIiAodG9vIHNtYWxsIHRvIGJlIGEgYm94KVwiKTtcblx0XHRyZXR1cm4geyBjb2RlOiBCb3hQYXJzZXIuRVJSX05PVF9FTk9VR0hfREFUQSwgdHlwZTogdHlwZSwgc2l6ZTogc2l6ZSwgaGRyX3NpemU6IGhkcl9zaXplLCBzdGFydDogc3RhcnQgfTtcblx0fVxuXHRpZiAocGFyZW50U2l6ZSAmJiBzaXplID4gcGFyZW50U2l6ZSkge1xuXHRcdExvZy5lcnJvcihcIkJveFBhcnNlclwiLCBcIkJveCBvZiB0eXBlICdcIit0eXBlK1wiJyBoYXMgYSBzaXplIFwiK3NpemUrXCIgZ3JlYXRlciB0aGFuIGl0cyBjb250YWluZXIgc2l6ZSBcIitwYXJlbnRTaXplKTtcblx0XHRyZXR1cm4geyBjb2RlOiBCb3hQYXJzZXIuRVJSX05PVF9FTk9VR0hfREFUQSwgdHlwZTogdHlwZSwgc2l6ZTogc2l6ZSwgaGRyX3NpemU6IGhkcl9zaXplLCBzdGFydDogc3RhcnQgfTtcblx0fVxuXHRpZiAoc3RhcnQgKyBzaXplID4gc3RyZWFtLmdldEVuZFBvc2l0aW9uKCkpIHtcblx0XHRzdHJlYW0uc2VlayhzdGFydCk7XG5cdFx0TG9nLmluZm8oXCJCb3hQYXJzZXJcIiwgXCJOb3QgZW5vdWdoIGRhdGEgaW4gc3RyZWFtIHRvIHBhcnNlIHRoZSBlbnRpcmUgJ1wiK3R5cGUrXCInIGJveFwiKTtcblx0XHRyZXR1cm4geyBjb2RlOiBCb3hQYXJzZXIuRVJSX05PVF9FTk9VR0hfREFUQSwgdHlwZTogdHlwZSwgc2l6ZTogc2l6ZSwgaGRyX3NpemU6IGhkcl9zaXplLCBzdGFydDogc3RhcnQgfTtcblx0fVxuXHRpZiAoaGVhZGVyT25seSkge1xuXHRcdHJldHVybiB7IGNvZGU6IEJveFBhcnNlci5PSywgdHlwZTogdHlwZSwgc2l6ZTogc2l6ZSwgaGRyX3NpemU6IGhkcl9zaXplLCBzdGFydDogc3RhcnQgfTtcblx0fSBlbHNlIHtcblx0XHRpZiAoQm94UGFyc2VyW3R5cGUrXCJCb3hcIl0pIHtcblx0XHRcdGJveCA9IG5ldyBCb3hQYXJzZXJbdHlwZStcIkJveFwiXShzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGUgIT09IFwidXVpZFwiKSB7XG5cdFx0XHRcdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiVW5rbm93biBib3ggdHlwZTogJ1wiK3R5cGUrXCInXCIpO1xuXHRcdFx0XHRib3ggPSBuZXcgQm94UGFyc2VyLkJveCh0eXBlLCBzaXplKTtcblx0XHRcdFx0Ym94Lmhhc191bnBhcnNlZF9kYXRhID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChCb3hQYXJzZXIuVVVJREJveGVzW3V1aWRdKSB7XG5cdFx0XHRcdFx0Ym94ID0gbmV3IEJveFBhcnNlci5VVUlEQm94ZXNbdXVpZF0oc2l6ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0TG9nLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJVbmtub3duIHV1aWQgdHlwZTogJ1wiK3V1aWQrXCInXCIpO1xuXHRcdFx0XHRcdGJveCA9IG5ldyBCb3hQYXJzZXIuQm94KHR5cGUsIHNpemUpO1xuXHRcdFx0XHRcdGJveC51dWlkID0gdXVpZDtcblx0XHRcdFx0XHRib3guaGFzX3VucGFyc2VkX2RhdGEgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGJveC5oZHJfc2l6ZSA9IGhkcl9zaXplO1xuXHQvKiByZWNvcmRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBib3ggaW4gdGhlIGlucHV0IHN0cmVhbSAqL1xuXHRib3guc3RhcnQgPSBzdGFydDtcblx0aWYgKGJveC53cml0ZSA9PT0gQm94UGFyc2VyLkJveC5wcm90b3R5cGUud3JpdGUgJiYgYm94LnR5cGUgIT09IFwibWRhdFwiKSB7XG5cdFx0TG9nLmluZm8oXCJCb3hQYXJzZXJcIiwgXCInXCIrYm94X3R5cGUrXCInIGJveCB3cml0aW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIGtlZXBpbmcgdW5wYXJzZWQgZGF0YSBpbiBtZW1vcnkgZm9yIGxhdGVyIHdyaXRlXCIpO1xuXHRcdGJveC5wYXJzZURhdGFBbmRSZXdpbmQoc3RyZWFtKTtcblx0fVxuXHRib3gucGFyc2Uoc3RyZWFtKTtcblx0ZGlmZiA9IHN0cmVhbS5nZXRQb3NpdGlvbigpIC0gKGJveC5zdGFydCtib3guc2l6ZSk7XG5cdGlmIChkaWZmIDwgMCkge1xuXHRcdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiUGFyc2luZyBvZiBib3ggJ1wiK2JveF90eXBlK1wiJyBkaWQgbm90IHJlYWQgdGhlIGVudGlyZSBpbmRpY2F0ZWQgYm94IGRhdGEgc2l6ZSAobWlzc2luZyBcIisoLWRpZmYpK1wiIGJ5dGVzKSwgc2Vla2luZyBmb3J3YXJkXCIpO1xuXHRcdHN0cmVhbS5zZWVrKGJveC5zdGFydCtib3guc2l6ZSk7XG5cdH0gZWxzZSBpZiAoZGlmZiA+IDApIHtcblx0XHRMb2cuZXJyb3IoXCJCb3hQYXJzZXJcIiwgXCJQYXJzaW5nIG9mIGJveCAnXCIrYm94X3R5cGUrXCInIHJlYWQgXCIrZGlmZitcIiBtb3JlIGJ5dGVzIHRoYW4gdGhlIGluZGljYXRlZCBib3ggZGF0YSBzaXplLCBzZWVraW5nIGJhY2t3YXJkc1wiKTtcblx0XHRzdHJlYW0uc2Vlayhib3guc3RhcnQrYm94LnNpemUpO1xuXHR9XG5cdHJldHVybiB7IGNvZGU6IEJveFBhcnNlci5PSywgYm94OiBib3gsIHNpemU6IGJveC5zaXplIH07XG59O1xuXG5Cb3hQYXJzZXIuQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRpZiAodGhpcy50eXBlICE9IFwibWRhdFwiKSB7XG5cdFx0dGhpcy5kYXRhID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplKTtcblx0fSBlbHNlIHtcblx0XHRpZiAodGhpcy5zaXplID09PSAwKSB7XG5cdFx0XHRzdHJlYW0uc2VlayhzdHJlYW0uZ2V0RW5kUG9zaXRpb24oKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0cmVhbS5zZWVrKHRoaXMuc3RhcnQrdGhpcy5zaXplKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qIFVzZWQgdG8gcGFyc2UgYSBib3ggd2l0aG91dCBjb25zdW1pbmcgaXRzIGRhdGEsIHRvIGFsbG93IGRldGFpbGxlZCBwYXJzaW5nXG4gICBVc2VmdWwgZm9yIGJveGVzIGZvciB3aGljaCBhIHdyaXRlIG1ldGhvZCBpcyBub3QgeWV0IGltcGxlbWVudGVkICovXG5Cb3hQYXJzZXIuQm94LnByb3RvdHlwZS5wYXJzZURhdGFBbmRSZXdpbmQgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5kYXRhID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplKTtcblx0Ly8gcmV3aW5kaW5nXG5cdHN0cmVhbS5wb3NpdGlvbiAtPSB0aGlzLnNpemUtdGhpcy5oZHJfc2l6ZTtcbn07XG5cbkJveFBhcnNlci5GdWxsQm94LnByb3RvdHlwZS5wYXJzZURhdGFBbmRSZXdpbmQgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5wYXJzZUZ1bGxIZWFkZXIoc3RyZWFtKTtcblx0dGhpcy5kYXRhID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplKTtcblx0Ly8gcmVzdG9yZSB0aGUgaGVhZGVyIHNpemUgYXMgaWYgdGhlIGZ1bGwgaGVhZGVyIGhhZCBub3QgYmVlbiBwYXJzZWRcblx0dGhpcy5oZHJfc2l6ZSAtPSA0O1xuXHQvLyByZXdpbmRpbmdcblx0c3RyZWFtLnBvc2l0aW9uIC09IHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplO1xufTtcblxuQm94UGFyc2VyLkZ1bGxCb3gucHJvdG90eXBlLnBhcnNlRnVsbEhlYWRlciA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0dGhpcy52ZXJzaW9uID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLmZsYWdzID0gc3RyZWFtLnJlYWRVaW50MjQoKTtcblx0dGhpcy5oZHJfc2l6ZSArPSA0O1xufTtcblxuQm94UGFyc2VyLkZ1bGxCb3gucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlRnVsbEhlYWRlcihzdHJlYW0pO1xuXHR0aGlzLmRhdGEgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplLXRoaXMuaGRyX3NpemUpO1xufTtcblxuQm94UGFyc2VyLkNvbnRhaW5lckJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHJldDtcblx0dmFyIGJveDtcblx0d2hpbGUgKHN0cmVhbS5nZXRQb3NpdGlvbigpIDwgdGhpcy5zdGFydCt0aGlzLnNpemUpIHtcblx0XHRyZXQgPSBCb3hQYXJzZXIucGFyc2VPbmVCb3goc3RyZWFtLCBmYWxzZSwgdGhpcy5zaXplIC0gKHN0cmVhbS5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpO1xuXHRcdGlmIChyZXQuY29kZSA9PT0gQm94UGFyc2VyLk9LKSB7XG5cdFx0XHRib3ggPSByZXQuYm94O1xuXHRcdFx0Lyogc3RvcmUgdGhlIGJveCBpbiB0aGUgJ2JveGVzJyBhcnJheSB0byBwcmVzZXJ2ZSBib3ggb3JkZXIgKGZvciBvZmZzZXQpIGJ1dCBhbHNvIHN0b3JlIGJveCBpbiBhIHByb3BlcnR5IGZvciBtb3JlIGRpcmVjdCBhY2Nlc3MgKi9cblx0XHRcdHRoaXMuYm94ZXMucHVzaChib3gpO1xuXHRcdFx0aWYgKHRoaXMuc3ViQm94TmFtZXMgJiYgdGhpcy5zdWJCb3hOYW1lcy5pbmRleE9mKGJveC50eXBlKSAhPSAtMSkge1xuXHRcdFx0XHR0aGlzW3RoaXMuc3ViQm94TmFtZXNbdGhpcy5zdWJCb3hOYW1lcy5pbmRleE9mKGJveC50eXBlKV0rXCJzXCJdLnB1c2goYm94KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBib3hfdHlwZSA9IGJveC50eXBlICE9PSBcInV1aWRcIiA/IGJveC50eXBlIDogYm94LnV1aWQ7XG5cdFx0XHRcdGlmICh0aGlzW2JveF90eXBlXSkge1xuXHRcdFx0XHRcdExvZy53YXJuKFwiQm94IG9mIHR5cGUgXCIrYm94X3R5cGUrXCIgYWxyZWFkeSBzdG9yZWQgaW4gZmllbGQgb2YgdGhpcyB0eXBlXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXNbYm94X3R5cGVdID0gYm94O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cbn07XG5cbkJveFBhcnNlci5Cb3gucHJvdG90eXBlLnBhcnNlTGFuZ3VhZ2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5sYW5ndWFnZSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHZhciBjaGFycyA9IFtdO1xuXHRjaGFyc1swXSA9ICh0aGlzLmxhbmd1YWdlPj4xMCkmMHgxRjtcblx0Y2hhcnNbMV0gPSAodGhpcy5sYW5ndWFnZT4+NSkmMHgxRjtcblx0Y2hhcnNbMl0gPSAodGhpcy5sYW5ndWFnZSkmMHgxRjtcblx0dGhpcy5sYW5ndWFnZVN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcnNbMF0rMHg2MCwgY2hhcnNbMV0rMHg2MCwgY2hhcnNbMl0rMHg2MCk7XG59O1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWVudHJpZXMvc2FtcGxlZW50cnkuanNcbkJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9WSVNVQUwgXHRcdD0gXCJWaXN1YWxcIjtcbkJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9BVURJTyBcdFx0PSBcIkF1ZGlvXCI7XG5Cb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfSElOVCBcdFx0PSBcIkhpbnRcIjtcbkJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSBcdD0gXCJNZXRhZGF0YVwiO1xuQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFIFx0PSBcIlN1YnRpdGxlXCI7XG5Cb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfU1lTVEVNIFx0XHQ9IFwiU3lzdGVtXCI7XG5Cb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfVEVYVCBcdFx0PSBcIlRleHRcIjtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5wYXJzZUhlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoNik7XG5cdHRoaXMuZGF0YV9yZWZlcmVuY2VfaW5kZXggPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR0aGlzLmhkcl9zaXplICs9IDg7XG59O1xuXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucGFyc2VIZWFkZXIoc3RyZWFtKTtcblx0dGhpcy5kYXRhID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5wYXJzZURhdGFBbmRSZXdpbmQgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5wYXJzZUhlYWRlcihzdHJlYW0pO1xuXHR0aGlzLmRhdGEgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSk7XG5cdC8vIHJlc3RvcmUgdGhlIGhlYWRlciBzaXplIGFzIGlmIHRoZSBzYW1wbGUgZW50cnkgaGVhZGVyIGhhZCBub3QgYmVlbiBwYXJzZWRcblx0dGhpcy5oZHJfc2l6ZSAtPSA4O1xuXHQvLyByZXdpbmRpbmdcblx0c3RyZWFtLnBvc2l0aW9uIC09IHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplO1xufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5wYXJzZUZvb3RlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRCb3hQYXJzZXIuQ29udGFpbmVyQm94LnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHN0cmVhbSk7XG59O1xuXG4vLyBCYXNlIFNhbXBsZUVudHJ5IHR5cGVzIHdpdGggZGVmYXVsdCBwYXJzaW5nXG5Cb3hQYXJzZXIuY3JlYXRlTWVkaWFTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX0hJTlQpO1xuQm94UGFyc2VyLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSk7XG5Cb3hQYXJzZXIuY3JlYXRlTWVkaWFTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFKTtcbkJveFBhcnNlci5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfU1lTVEVNKTtcbkJveFBhcnNlci5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfVEVYVCk7XG5cbi8vQmFzZSBTYW1wbGVFbnRyeSB0eXBlcyBmb3IgQXVkaW8gYW5kIFZpZGVvIHdpdGggc3BlY2lmaWMgcGFyc2luZ1xuQm94UGFyc2VyLmNyZWF0ZU1lZGlhU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9WSVNVQUwsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgY29tcHJlc3Nvcm5hbWVfbGVuZ3RoO1xuXHR0aGlzLnBhcnNlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHN0cmVhbS5yZWFkVWludDMyQXJyYXkoMyk7XG5cdHRoaXMud2lkdGggPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR0aGlzLmhlaWdodCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHRoaXMuaG9yaXpyZXNvbHV0aW9uID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy52ZXJ0cmVzb2x1dGlvbiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuZnJhbWVfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRjb21wcmVzc29ybmFtZV9sZW5ndGggPSBNYXRoLm1pbigzMSwgc3RyZWFtLnJlYWRVaW50OCgpKTtcblx0dGhpcy5jb21wcmVzc29ybmFtZSA9IHN0cmVhbS5yZWFkU3RyaW5nKGNvbXByZXNzb3JuYW1lX2xlbmd0aCk7XG5cdGlmIChjb21wcmVzc29ybmFtZV9sZW5ndGggPCAzMSkge1xuXHRcdHN0cmVhbS5yZWFkU3RyaW5nKDMxIC0gY29tcHJlc3Nvcm5hbWVfbGVuZ3RoKTtcblx0fVxuXHR0aGlzLmRlcHRoID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0c3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5wYXJzZUZvb3RlcihzdHJlYW0pO1xufSk7XG5cbkJveFBhcnNlci5jcmVhdGVNZWRpYVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfQVVESU8sIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS5yZWFkVWludDMyQXJyYXkoMik7XG5cdHRoaXMuY2hhbm5lbF9jb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHRoaXMuc2FtcGxlc2l6ZSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHRoaXMuc2FtcGxlcmF0ZSA9IChzdHJlYW0ucmVhZFVpbnQzMigpLygxPDwxNikpO1xuXHR0aGlzLnBhcnNlRm9vdGVyKHN0cmVhbSk7XG59KTtcblxuLy8gU2FtcGxlIGVudHJpZXMgaW5oZXJpdGluZyBmcm9tIEF1ZGlvIGFuZCBWaWRlb1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2YzFcIik7XG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9WSVNVQUwsIFwiYXZjMlwiKTtcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJhdmMzXCIpO1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImF2YzRcIik7XG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9WSVNVQUwsIFwiYXYwMVwiKTtcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1ZJU1VBTCwgXCJodmMxXCIpO1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcImhldjFcIik7XG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgXHRcIm1wNGFcIik7XG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgXHRcImFjLTNcIik7XG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9BVURJTywgXHRcImVjLTNcIik7XG5cbi8vIEVuY3J5cHRlZCBzYW1wbGUgZW50cmllc1xuQm94UGFyc2VyLmNyZWF0ZUVuY3J5cHRlZFNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfVklTVUFMLCBcdFwiZW5jdlwiKTtcbkJveFBhcnNlci5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX0FVRElPLCBcdFwiZW5jYVwiKTtcbkJveFBhcnNlci5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFLCBcdFwiZW5jdVwiKTtcbkJveFBhcnNlci5jcmVhdGVFbmNyeXB0ZWRTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1NZU1RFTSwgXHRcImVuY3NcIik7XG5Cb3hQYXJzZXIuY3JlYXRlRW5jcnlwdGVkU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9URVhULCBcdFx0XCJlbmN0XCIpO1xuQm94UGFyc2VyLmNyZWF0ZUVuY3J5cHRlZFNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfTUVUQURBVEEsIFx0XCJlbmNtXCIpO1xuXG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvYTFseC5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJhMWx4XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgbGFyZ2Vfc2l6ZSA9IHN0cmVhbS5yZWFkVWludDgoKSAmIDE7XG5cdHZhciBGaWVsZExlbmd0aCA9ICgobGFyZ2Vfc2l6ZSAmIDEpICsgMSkgKiAxNjtcblx0dGhpcy5sYXllcl9zaXplID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0aWYgKEZpZWxkTGVuZ3RoID09IDE2KSB7XG5cdFx0XHR0aGlzLmxheWVyX3NpemVbaV0gPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxheWVyX3NpemVbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdH1cblx0fVxufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9hMW9wLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImExb3BcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMub3BfaW5kZXggPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG59KTsvLyBmaWxlOnNyYy9wYXJzaW5nL2F1eEMuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcImF1eENcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuYXV4X3R5cGUgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0dmFyIGF1eF9zdWJ0eXBlX2xlbmd0aCA9IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSAodGhpcy5hdXhfdHlwZS5sZW5ndGggKyAxKTtcblx0dGhpcy5hdXhfc3VidHlwZSA9IHN0cmVhbS5yZWFkVWludDhBcnJheShhdXhfc3VidHlwZV9sZW5ndGgpO1xufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9hdjFDLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImF2MUNcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciB0bXAgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdGlmICgodG1wID4+IDcpICYgMHgxICE9PSAxKSB7XG5cdFx0TG9nLmVycm9yKFwiYXYxQyBtYXJrZXIgcHJvYmxlbVwiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0dGhpcy52ZXJzaW9uID0gdG1wICYgMHg3Rjtcblx0aWYgKHRoaXMudmVyc2lvbiAhPT0gMSkge1xuXHRcdExvZy5lcnJvcihcImF2MUMgdmVyc2lvbiBcIit0aGlzLnZlcnNpb24rXCIgbm90IHN1cHBvcnRlZFwiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0dG1wID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLnNlcV9wcm9maWxlID0gKHRtcCA+PiA1KSAmIDB4Nztcblx0dGhpcy5zZXFfbGV2ZWxfaWR4XzAgPSB0bXAgJiAweDFGO1xuXHR0bXAgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuc2VxX3RpZXJfMCA9ICh0bXAgPj4gNykgJiAweDE7XG5cdHRoaXMuaGlnaF9iaXRkZXB0aCA9ICh0bXAgPj4gNikgJiAweDE7XG5cdHRoaXMudHdlbHZlX2JpdCA9ICh0bXAgPj4gNSkgJiAweDE7XG5cdHRoaXMubW9ub2Nocm9tZSA9ICh0bXAgPj4gNCkgJiAweDE7XG5cdHRoaXMuY2hyb21hX3N1YnNhbXBsaW5nX3ggPSAodG1wID4+IDMpICYgMHgxO1xuXHR0aGlzLmNocm9tYV9zdWJzYW1wbGluZ195ID0gKHRtcCA+PiAyKSAmIDB4MTtcblx0dGhpcy5jaHJvbWFfc2FtcGxlX3Bvc2l0aW9uID0gKHRtcCAmIDB4Myk7XG5cdHRtcCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5yZXNlcnZlZF8xID0gKHRtcCA+PiA1KSAmIDB4Nztcblx0aWYgKHRoaXMucmVzZXJ2ZWRfMSAhPT0gMCkge1xuXHRcdExvZy5lcnJvcihcImF2MUMgcmVzZXJ2ZWRfMSBwYXJzaW5nIHByb2JsZW1cIik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHRoaXMuaW5pdGlhbF9wcmVzZW50YXRpb25fZGVsYXlfcHJlc2VudCA9ICh0bXAgPj4gNCkgJiAweDE7XG5cdGlmICh0aGlzLmluaXRpYWxfcHJlc2VudGF0aW9uX2RlbGF5X3ByZXNlbnQgPT09IDEpIHtcblx0XHR0aGlzLmluaXRpYWxfcHJlc2VudGF0aW9uX2RlbGF5X21pbnVzX29uZSA9ICh0bXAgJiAweEYpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMucmVzZXJ2ZWRfMiA9ICh0bXAgJiAweEYpO1xuXHRcdGlmICh0aGlzLnJlc2VydmVkXzIgIT09IDApIHtcblx0XHRcdExvZy5lcnJvcihcImF2MUMgcmVzZXJ2ZWRfMiBwYXJzaW5nIHByb2JsZW1cIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0dmFyIGNvbmZpZ09CVXNfbGVuZ3RoID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIDQ7XG5cdHRoaXMuY29uZmlnT0JVcyA9IHN0cmVhbS5yZWFkVWludDhBcnJheShjb25maWdPQlVzX2xlbmd0aCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9hdmNDLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImF2Y0NcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR2YXIgdG9wYXJzZTtcblx0dGhpcy5jb25maWd1cmF0aW9uVmVyc2lvbiA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5BVkNQcm9maWxlSW5kaWNhdGlvbiA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5wcm9maWxlX2NvbXBhdGliaWxpdHkgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuQVZDTGV2ZWxJbmRpY2F0aW9uID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLmxlbmd0aFNpemVNaW51c09uZSA9IChzdHJlYW0ucmVhZFVpbnQ4KCkgJiAweDMpO1xuXHR0aGlzLm5iX1NQU19uYWx1cyA9IChzdHJlYW0ucmVhZFVpbnQ4KCkgJiAweDFGKTtcblx0dG9wYXJzZSA9IHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSA2O1xuXHR0aGlzLlNQUyA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5uYl9TUFNfbmFsdXM7IGkrKykge1xuXHRcdHRoaXMuU1BTW2ldID0ge307XG5cdFx0dGhpcy5TUFNbaV0ubGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHR0aGlzLlNQU1tpXS5uYWx1ID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuU1BTW2ldLmxlbmd0aCk7XG5cdFx0dG9wYXJzZSAtPSAyK3RoaXMuU1BTW2ldLmxlbmd0aDtcblx0fVxuXHR0aGlzLm5iX1BQU19uYWx1cyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dG9wYXJzZS0tO1xuXHR0aGlzLlBQUyA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5uYl9QUFNfbmFsdXM7IGkrKykge1xuXHRcdHRoaXMuUFBTW2ldID0ge307XG5cdFx0dGhpcy5QUFNbaV0ubGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHR0aGlzLlBQU1tpXS5uYWx1ID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuUFBTW2ldLmxlbmd0aCk7XG5cdFx0dG9wYXJzZSAtPSAyK3RoaXMuUFBTW2ldLmxlbmd0aDtcblx0fVxuXHRpZiAodG9wYXJzZT4wKSB7XG5cdFx0dGhpcy5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkodG9wYXJzZSk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2J0cnQuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwiYnRydFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5idWZmZXJTaXplREIgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLm1heEJpdHJhdGUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmF2Z0JpdHJhdGUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvY2xhcC5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJjbGFwXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmNsZWFuQXBlcnR1cmVXaWR0aE4gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmNsZWFuQXBlcnR1cmVXaWR0aEQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmNsZWFuQXBlcnR1cmVIZWlnaHROID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5jbGVhbkFwZXJ0dXJlSGVpZ2h0RCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuaG9yaXpPZmZOID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5ob3Jpek9mZkQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnZlcnRPZmZOID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy52ZXJ0T2ZmRCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTsvLyBmaWxlOnNyYy9wYXJzaW5nL2NsbGkuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwiY2xsaVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5tYXhfY29udGVudF9saWdodF9sZXZlbCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5tYXhfcGljX2F2ZXJhZ2VfbGlnaHRfbGV2ZWwgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvY282NC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiY282NFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGVudHJ5X2NvdW50O1xuXHR2YXIgaTtcblx0ZW50cnlfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmNodW5rX29mZnNldHMgPSBbXTtcblx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMCkge1xuXHRcdGZvcihpPTA7IGk8ZW50cnlfY291bnQ7IGkrKykge1xuXHRcdFx0dGhpcy5jaHVua19vZmZzZXRzLnB1c2goc3RyZWFtLnJlYWRVaW50NjQoKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9Db0xMLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJDb0xMXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLm1heENMTCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5tYXhGQUxMID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2NvbHIuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwiY29sclwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5jb2xvdXJfdHlwZSA9IHN0cmVhbS5yZWFkU3RyaW5nKDQpO1xuXHRpZiAodGhpcy5jb2xvdXJfdHlwZSA9PT0gJ25jbHgnKSB7XG5cdFx0dGhpcy5jb2xvdXJfcHJpbWFyaWVzID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHR0aGlzLnRyYW5zZmVyX2NoYXJhY3RlcmlzdGljcyA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0dGhpcy5tYXRyaXhfY29lZmZpY2llbnRzID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHR2YXIgdG1wID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMuZnVsbF9yYW5nZV9mbGFnID0gdG1wID4+IDc7XG5cdH0gZWxzZSBpZiAodGhpcy5jb2xvdXJfdHlwZSA9PT0gJ3JJQ0MnKSB7XG5cdFx0dGhpcy5JQ0NfcHJvZmlsZSA9IHN0cmVhbS5yZWFkVWludDhBcnJheSh0aGlzLnNpemUgLSA0KTtcblx0fSBlbHNlIGlmICh0aGlzLmNvbG91cl90eXBlID09PSAncHJvZicpIHtcblx0XHR0aGlzLklDQ19wcm9maWxlID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuc2l6ZSAtIDQpO1xuXHR9XG59KTsvLyBmaWxlOnNyYy9wYXJzaW5nL2NwcnQuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcImNwcnRcIiwgZnVuY3Rpb24gKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlTGFuZ3VhZ2Uoc3RyZWFtKTtcblx0dGhpcy5ub3RpY2UgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2NzbGcuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcImNzbGdcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHR0aGlzLmNvbXBvc2l0aW9uVG9EVFNTaGlmdCA9IHN0cmVhbS5yZWFkSW50MzIoKTsgLyogc2lnbmVkICovXG5cdFx0dGhpcy5sZWFzdERlY29kZVRvRGlzcGxheURlbHRhID0gc3RyZWFtLnJlYWRJbnQzMigpOyAvKiBzaWduZWQgKi9cblx0XHR0aGlzLmdyZWF0ZXN0RGVjb2RlVG9EaXNwbGF5RGVsdGEgPSBzdHJlYW0ucmVhZEludDMyKCk7IC8qIHNpZ25lZCAqL1xuXHRcdHRoaXMuY29tcG9zaXRpb25TdGFydFRpbWUgPSBzdHJlYW0ucmVhZEludDMyKCk7IC8qIHNpZ25lZCAqL1xuXHRcdHRoaXMuY29tcG9zaXRpb25FbmRUaW1lID0gc3RyZWFtLnJlYWRJbnQzMigpOyAvKiBzaWduZWQgKi9cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvY3R0cy5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiY3R0c1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGVudHJ5X2NvdW50O1xuXHR2YXIgaTtcblx0ZW50cnlfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnNhbXBsZV9jb3VudHMgPSBbXTtcblx0dGhpcy5zYW1wbGVfb2Zmc2V0cyA9IFtdO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0Zm9yKGk9MDsgaTxlbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnNhbXBsZV9jb3VudHMucHVzaChzdHJlYW0ucmVhZFVpbnQzMigpKTtcblx0XHRcdC8qIHNvbWUgZmlsZXMgYXJlIGJ1Z2d5IGFuZCBkZWNsYXJlIHZlcnNpb249MCB3aGlsZSB1c2luZyBzaWduZWQgb2Zmc2V0cy5cblx0XHRcdCAgIFRoZSBsaWtlbHlob29kIG9mIHVzaW5nIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBpbiBhIDMyLWJpdHMgdGltZSBvZmZzZXQgaXMgdmVyeSBsb3csXG5cdFx0XHQgICBzbyB1c2luZyBzaWduZWQgdmFsdWUgaGVyZSBhcyB3ZWxsICovXG5cdFx0XHQgICB2YXIgdmFsdWUgPSBzdHJlYW0ucmVhZEludDMyKCk7XG5cdFx0XHQgICBpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHQgICBcdFx0TG9nLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJjdHRzIGJveCB1c2VzIG5lZ2F0aXZlIHZhbHVlcyB3aXRob3V0IHVzaW5nIHZlcnNpb24gMVwiKTtcblx0XHRcdCAgIH1cblx0XHRcdHRoaXMuc2FtcGxlX29mZnNldHMucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PSAxKSB7XG5cdFx0Zm9yKGk9MDsgaTxlbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnNhbXBsZV9jb3VudHMucHVzaChzdHJlYW0ucmVhZFVpbnQzMigpKTtcblx0XHRcdHRoaXMuc2FtcGxlX29mZnNldHMucHVzaChzdHJlYW0ucmVhZEludDMyKCkpOyAvKiBzaWduZWQgKi9cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2RhYzMuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwiZGFjM1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHRtcF9ieXRlMSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dmFyIHRtcF9ieXRlMiA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dmFyIHRtcF9ieXRlMyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5mc2NvZCA9IHRtcF9ieXRlMSA+PiA2O1xuXHR0aGlzLmJzaWQgID0gKCh0bXBfYnl0ZTEgPj4gMSkgJiAweDFGKTtcblx0dGhpcy5ic21vZCA9ICgodG1wX2J5dGUxICYgMHgxKSA8PCAgMikgfCAoKHRtcF9ieXRlMiA+PiA2KSAmIDB4Myk7XG5cdHRoaXMuYWNtb2QgPSAoKHRtcF9ieXRlMiA+PiAzKSAmIDB4Nyk7XG5cdHRoaXMubGZlb24gPSAoKHRtcF9ieXRlMiA+PiAyKSAmIDB4MSk7XG5cdHRoaXMuYml0X3JhdGVfY29kZSA9ICh0bXBfYnl0ZTIgJiAweDMpIHwgKCh0bXBfYnl0ZTMgPj4gNSkgJiAweDcpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvZGVjMy5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJkZWMzXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgdG1wXzE2ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5kYXRhX3JhdGUgPSB0bXBfMTYgPj4gMztcblx0dGhpcy5udW1faW5kX3N1YiA9IHRtcF8xNiAmIDB4Nztcblx0dGhpcy5pbmRfc3VicyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtX2luZF9zdWIrMTsgaSsrKSB7XG5cdFx0dmFyIGluZF9zdWIgPSB7fTtcblx0XHR0aGlzLmluZF9zdWJzLnB1c2goaW5kX3N1Yik7XG5cdFx0dmFyIHRtcF9ieXRlMSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR2YXIgdG1wX2J5dGUyID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHZhciB0bXBfYnl0ZTMgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0aW5kX3N1Yi5mc2NvZCA9IHRtcF9ieXRlMSA+PiA2O1xuXHRcdGluZF9zdWIuYnNpZCAgPSAoKHRtcF9ieXRlMSA+PiAxKSAmIDB4MUYpO1xuXHRcdGluZF9zdWIuYnNtb2QgPSAoKHRtcF9ieXRlMSAmIDB4MSkgPDwgNCkgfCAoKHRtcF9ieXRlMiA+PiA0KSAmIDB4Rik7XG5cdFx0aW5kX3N1Yi5hY21vZCA9ICgodG1wX2J5dGUyID4+IDEpICYgMHg3KTtcblx0XHRpbmRfc3ViLmxmZW9uID0gKHRtcF9ieXRlMiAmIDB4MSk7XG5cdFx0aW5kX3N1Yi5udW1fZGVwX3N1YiA9ICgodG1wX2J5dGUzID4+IDEpICYgMHhGKTtcblx0XHRpZiAoaW5kX3N1Yi5udW1fZGVwX3N1YiA+IDApIHtcblx0XHRcdGluZF9zdWIuY2hhbl9sb2MgPSAoKHRtcF9ieXRlMyAmIDB4MSkgPDwgOCkgfCBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9kZkxhLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJkZkxhXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBCTE9DS1RZUEVfTUFTSyA9IDB4N0Y7XG4gICAgdmFyIExBU1RNRVRBREFUQUJMT0NLRkxBR19NQVNLID0gMHg4MDtcblxuICAgIHZhciBib3hlc0ZvdW5kID0gW107XG4gICAgdmFyIGtub3duQmxvY2tUeXBlcyA9IFtcbiAgICAgICAgXCJTVFJFQU1JTkZPXCIsXG4gICAgICAgIFwiUEFERElOR1wiLFxuICAgICAgICBcIkFQUExJQ0FUSU9OXCIsXG4gICAgICAgIFwiU0VFS1RBQkxFXCIsXG4gICAgICAgIFwiVk9SQklTX0NPTU1FTlRcIixcbiAgICAgICAgXCJDVUVTSEVFVFwiLFxuICAgICAgICBcIlBJQ1RVUkVcIixcbiAgICAgICAgXCJSRVNFUlZFRFwiXG4gICAgXTtcblxuICAgIC8vIGRmTGEgaXMgYSBGdWxsQm94XG4gICAgdGhpcy5wYXJzZUZ1bGxIZWFkZXIoc3RyZWFtKTtcblxuICAgIC8vIGZvciAoaT0wOyA7IGkrKykgeyAvLyB0byBlbmQgb2YgYm94XG4gICAgZG8ge1xuICAgICAgICB2YXIgZmxhZ0FuZFR5cGUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIChmbGFnQW5kVHlwZSAmIEJMT0NLVFlQRV9NQVNLKSxcbiAgICAgICAgICAgIChrbm93bkJsb2NrVHlwZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgU1RSRUFNSU5GTyBibG9jaywgcmVhZCB0aGUgdHJ1ZSBzYW1wbGVyYXRlIHNpbmNlIHRoaXNcbiAgICAgICAgLy8gY2FuIGJlIGRpZmZlcmVudCB0byB0aGUgQXVkaW9TYW1wbGVFbnRyeSBzYW1wbGVyYXRlLlxuICAgICAgICBpZiAoISh0eXBlKSkge1xuICAgICAgICAgICAgLy8gcmVhZCBwYXN0IGFsbCB0aGUgb3RoZXIgc3R1ZmZcbiAgICAgICAgICAgIHN0cmVhbS5yZWFkVWludDhBcnJheSgxMyk7XG5cbiAgICAgICAgICAgIC8vIGV4dHJhY3Qgc2FtcGxlcmF0ZVxuICAgICAgICAgICAgdGhpcy5zYW1wbGVyYXRlID0gKHN0cmVhbS5yZWFkVWludDMyKCkgPj4gMTIpO1xuXG4gICAgICAgICAgICAvLyByZWFkIHRvIGVuZCBvZiBTVFJFQU1JTkZPXG4gICAgICAgICAgICBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGludGVyZXN0ZWQgaW4gb3RoZXIgYmxvY2sgdHlwZXMgc28ganVzdCBkaXNjYXJkIGxlbmd0aCBieXRlc1xuICAgICAgICAgICAgc3RyZWFtLnJlYWRVaW50OEFycmF5KHN0cmVhbS5yZWFkVWludDI0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYm94ZXNGb3VuZC5wdXNoKGtub3duQmxvY2tUeXBlc1t0eXBlXSk7XG5cbiAgICAgICAgaWYgKCEhKGZsYWdBbmRUeXBlICYgTEFTVE1FVEFEQVRBQkxPQ0tGTEFHX01BU0spKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgdGhpcy5udW1NZXRhZGF0YUJsb2NrcyA9XG4gICAgICAgIGJveGVzRm91bmQubGVuZ3RoICsgXCIgKFwiICsgYm94ZXNGb3VuZC5qb2luKFwiLCBcIikgKyBcIilcIjtcbn0pO1xuLy8gZmlsZTpzcmMvcGFyc2luZy9kaW1tLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImRpbW1cIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuYnl0ZXNzZW50ID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2RtYXguanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwiZG1heFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy50aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2RtZWQuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwiZG1lZFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5ieXRlc3NlbnQgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvZHJlZi5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZHJlZlwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHJldDtcblx0dmFyIGJveDtcblx0dGhpcy5lbnRyaWVzID0gW107XG5cdHZhciBlbnRyeV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnlfY291bnQ7IGkrKykge1xuXHRcdHJldCA9IEJveFBhcnNlci5wYXJzZU9uZUJveChzdHJlYW0sIGZhbHNlLCB0aGlzLnNpemUgLSAoc3RyZWFtLmdldFBvc2l0aW9uKCkgLSB0aGlzLnN0YXJ0KSk7XG5cdFx0aWYgKHJldC5jb2RlID09PSBCb3hQYXJzZXIuT0spIHtcblx0XHRcdGJveCA9IHJldC5ib3g7XG5cdFx0XHR0aGlzLmVudHJpZXMucHVzaChib3gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9kcmVwLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImRyZXBcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuYnl0ZXNzZW50ID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2VsbmcuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcImVsbmdcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuZXh0ZW5kZWRfbGFuZ3VhZ2UgPSBzdHJlYW0ucmVhZFN0cmluZyh0aGlzLnNpemUtdGhpcy5oZHJfc2l6ZSk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9lbHN0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJlbHN0XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmVudHJpZXMgPSBbXTtcblx0dmFyIGVudHJ5X2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0ge307XG5cdFx0dGhpcy5lbnRyaWVzLnB1c2goZW50cnkpO1xuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHRcdGVudHJ5LnNlZ21lbnRfZHVyYXRpb24gPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuXHRcdFx0ZW50cnkubWVkaWFfdGltZSA9IHN0cmVhbS5yZWFkSW50NjQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZW50cnkuc2VnbWVudF9kdXJhdGlvbiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHRlbnRyeS5tZWRpYV90aW1lID0gc3RyZWFtLnJlYWRJbnQzMigpO1xuXHRcdH1cblx0XHRlbnRyeS5tZWRpYV9yYXRlX2ludGVnZXIgPSBzdHJlYW0ucmVhZEludDE2KCk7XG5cdFx0ZW50cnkubWVkaWFfcmF0ZV9mcmFjdGlvbiA9IHN0cmVhbS5yZWFkSW50MTYoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvZW1zZy5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiZW1zZ1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0aWYgKHRoaXMudmVyc2lvbiA9PSAxKSB7XG5cdFx0dGhpcy50aW1lc2NhbGUgXHRcdFx0XHRcdD0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLnByZXNlbnRhdGlvbl90aW1lIFx0XHRcdD0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHR0aGlzLmV2ZW50X2R1cmF0aW9uXHRcdFx0IFx0PSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuaWQgXHRcdFx0XHRcdFx0PSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuc2NoZW1lX2lkX3VyaSBcdFx0XHRcdD0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdFx0dGhpcy52YWx1ZSBcdFx0XHRcdFx0XHQ9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuc2NoZW1lX2lkX3VyaSBcdFx0XHRcdD0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdFx0dGhpcy52YWx1ZSBcdFx0XHRcdFx0XHQ9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHRcdHRoaXMudGltZXNjYWxlIFx0XHRcdFx0XHQ9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dGhpcy5wcmVzZW50YXRpb25fdGltZV9kZWx0YSBcdD0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLmV2ZW50X2R1cmF0aW9uXHRcdFx0IFx0PSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuaWQgXHRcdFx0XHRcdFx0PSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG5cdHZhciBtZXNzYWdlX3NpemUgPSB0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gKDQqNCArICh0aGlzLnNjaGVtZV9pZF91cmkubGVuZ3RoKzEpICsgKHRoaXMudmFsdWUubGVuZ3RoKzEpKTtcblx0aWYgKHRoaXMudmVyc2lvbiA9PSAxKSB7XG5cdFx0bWVzc2FnZV9zaXplIC09IDQ7XG5cdH1cblx0dGhpcy5tZXNzYWdlX2RhdGEgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkobWVzc2FnZV9zaXplKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL2VzZHMuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcImVzZHNcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBlc2RfZGF0YSA9IHN0cmVhbS5yZWFkVWludDhBcnJheSh0aGlzLnNpemUtdGhpcy5oZHJfc2l6ZSk7XG5cdGlmICh0eXBlb2YgTVBFRzREZXNjcmlwdG9yUGFyc2VyICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0dmFyIGVzZF9wYXJzZXIgPSBuZXcgTVBFRzREZXNjcmlwdG9yUGFyc2VyKCk7XG5cdFx0dGhpcy5lc2QgPSBlc2RfcGFyc2VyLnBhcnNlT25lRGVzY3JpcHRvcihuZXcgRGF0YVN0cmVhbShlc2RfZGF0YS5idWZmZXIsIDAsIERhdGFTdHJlYW0uQklHX0VORElBTikpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9maWVsLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImZpZWxcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuZmllbGRDb3VudCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5maWVsZE9yZGVyaW5nID0gc3RyZWFtLnJlYWRVaW50OCgpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvZnJtYS5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJmcm1hXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmRhdGFfZm9ybWF0ID0gc3RyZWFtLnJlYWRTdHJpbmcoNCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9mdHlwLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImZ0eXBcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciB0b3BhcnNlID0gdGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZTtcblx0dGhpcy5tYWpvcl9icmFuZCA9IHN0cmVhbS5yZWFkU3RyaW5nKDQpO1xuXHR0aGlzLm1pbm9yX3ZlcnNpb24gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0b3BhcnNlIC09IDg7XG5cdHRoaXMuY29tcGF0aWJsZV9icmFuZHMgPSBbXTtcblx0dmFyIGkgPSAwO1xuXHR3aGlsZSAodG9wYXJzZT49NCkge1xuXHRcdHRoaXMuY29tcGF0aWJsZV9icmFuZHNbaV0gPSBzdHJlYW0ucmVhZFN0cmluZyg0KTtcblx0XHR0b3BhcnNlIC09IDQ7XG5cdFx0aSsrO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9oZGxyLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJoZGxyXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0c3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLmhhbmRsZXIgPSBzdHJlYW0ucmVhZFN0cmluZyg0KTtcblx0XHRzdHJlYW0ucmVhZFVpbnQzMkFycmF5KDMpO1xuXHRcdHRoaXMubmFtZSA9IHN0cmVhbS5yZWFkU3RyaW5nKHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplLTIwKTtcblx0XHRpZiAodGhpcy5uYW1lW3RoaXMubmFtZS5sZW5ndGgtMV09PT0nXFwwJykge1xuXHRcdFx0dGhpcy5uYW1lID0gdGhpcy5uYW1lLnNsaWNlKDAsLTEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvaHZjQy5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJodmNDXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgaSwgajtcblx0dmFyIGxlbmd0aDtcblx0dmFyIHRtcF9ieXRlO1xuXHR0aGlzLmNvbmZpZ3VyYXRpb25WZXJzaW9uID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0bXBfYnl0ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5nZW5lcmFsX3Byb2ZpbGVfc3BhY2UgPSB0bXBfYnl0ZSA+PiA2O1xuXHR0aGlzLmdlbmVyYWxfdGllcl9mbGFnID0gKHRtcF9ieXRlICYgMHgyMCkgPj4gNTtcblx0dGhpcy5nZW5lcmFsX3Byb2ZpbGVfaWRjID0gKHRtcF9ieXRlICYgMHgxRik7XG5cdHRoaXMuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHkgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3IgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoNik7XG5cdHRoaXMuZ2VuZXJhbF9sZXZlbF9pZGMgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMubWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYyA9IHN0cmVhbS5yZWFkVWludDE2KCkgJiAweEZGRjtcblx0dGhpcy5wYXJhbGxlbGlzbVR5cGUgPSAoc3RyZWFtLnJlYWRVaW50OCgpICYgMHgzKTtcblx0dGhpcy5jaHJvbWFfZm9ybWF0X2lkYyA9IChzdHJlYW0ucmVhZFVpbnQ4KCkgJiAweDMpO1xuXHR0aGlzLmJpdF9kZXB0aF9sdW1hX21pbnVzOCA9IChzdHJlYW0ucmVhZFVpbnQ4KCkgJiAweDcpO1xuXHR0aGlzLmJpdF9kZXB0aF9jaHJvbWFfbWludXM4ID0gKHN0cmVhbS5yZWFkVWludDgoKSAmIDB4Nyk7XG5cdHRoaXMuYXZnRnJhbWVSYXRlID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dG1wX2J5dGUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuY29uc3RhbnRGcmFtZVJhdGUgPSAodG1wX2J5dGUgPj4gNik7XG5cdHRoaXMubnVtVGVtcG9yYWxMYXllcnMgPSAodG1wX2J5dGUgJiAwWEQpID4+IDM7XG5cdHRoaXMudGVtcG9yYWxJZE5lc3RlZCA9ICh0bXBfYnl0ZSAmIDBYNCkgPj4gMjtcblx0dGhpcy5sZW5ndGhTaXplTWludXNPbmUgPSAodG1wX2J5dGUgJiAwWDMpO1xuXG5cdHRoaXMubmFsdV9hcnJheXMgPSBbXTtcblx0dmFyIG51bU9mQXJyYXlzID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRmb3IgKGkgPSAwOyBpIDwgbnVtT2ZBcnJheXM7IGkrKykge1xuXHRcdHZhciBuYWx1X2FycmF5ID0gW107XG5cdFx0dGhpcy5uYWx1X2FycmF5cy5wdXNoKG5hbHVfYXJyYXkpO1xuXHRcdHRtcF9ieXRlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdG5hbHVfYXJyYXkuY29tcGxldGVuZXNzID0gKHRtcF9ieXRlICYgMHg4MCkgPj4gNztcblx0XHRuYWx1X2FycmF5Lm5hbHVfdHlwZSA9IHRtcF9ieXRlICYgMHgzRjtcblx0XHR2YXIgbnVtTmFsdXMgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdGZvciAoaiA9IDA7IGogPCBudW1OYWx1czsgaisrKSB7XG5cdFx0XHR2YXIgbmFsdSA9IHt9O1xuXHRcdFx0bmFsdV9hcnJheS5wdXNoKG5hbHUpO1xuXHRcdFx0bGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHRcdG5hbHUuZGF0YSAgID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KGxlbmd0aCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9paW5mLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJpaW5mXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgcmV0O1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0dGhpcy5lbnRyeV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5lbnRyeV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdH1cblx0dGhpcy5pdGVtX2luZm9zID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0cmV0ID0gQm94UGFyc2VyLnBhcnNlT25lQm94KHN0cmVhbSwgZmFsc2UsIHRoaXMuc2l6ZSAtIChzdHJlYW0uZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKTtcblx0XHRpZiAocmV0LmNvZGUgPT09IEJveFBhcnNlci5PSykge1xuXHRcdFx0aWYgKHJldC5ib3gudHlwZSAhPT0gXCJpbmZlXCIpIHtcblx0XHRcdFx0TG9nLmVycm9yKFwiQm94UGFyc2VyXCIsIFwiRXhwZWN0ZWQgJ2luZmUnIGJveCwgZ290IFwiK3JldC5ib3gudHlwZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1faW5mb3NbaV0gPSByZXQuYm94O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9pbG9jLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJpbG9jXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgYnl0ZTtcblx0Ynl0ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5vZmZzZXRfc2l6ZSA9IChieXRlID4+IDQpICYgMHhGO1xuXHR0aGlzLmxlbmd0aF9zaXplID0gYnl0ZSAmIDB4Rjtcblx0Ynl0ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5iYXNlX29mZnNldF9zaXplID0gKGJ5dGUgPj4gNCkgJiAweEY7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDEgfHwgdGhpcy52ZXJzaW9uID09PSAyKSB7XG5cdFx0dGhpcy5pbmRleF9zaXplID0gYnl0ZSAmIDB4Rjtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmluZGV4X3NpemUgPSAwO1xuXHRcdC8vIHJlc2VydmVkID0gYnl0ZSAmIDB4Rjtcblx0fVxuXHR0aGlzLml0ZW1zID0gW107XG5cdHZhciBpdGVtX2NvdW50ID0gMDtcblx0aWYgKHRoaXMudmVyc2lvbiA8IDIpIHtcblx0XHRpdGVtX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0fSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcblx0XHRpdGVtX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBcInZlcnNpb24gb2YgaWxvYyBib3ggbm90IHN1cHBvcnRlZFwiO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbV9jb3VudDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSB7fTtcblx0XHR0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG5cdFx0aWYgKHRoaXMudmVyc2lvbiA8IDIpIHtcblx0XHRcdGl0ZW0uaXRlbV9JRCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcblx0XHRcdGl0ZW0uaXRlbV9JRCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IFwidmVyc2lvbiBvZiBpbG9jIGJveCBub3Qgc3VwcG9ydGVkXCI7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDEgfHwgdGhpcy52ZXJzaW9uID09PSAyKSB7XG5cdFx0XHRpdGVtLmNvbnN0cnVjdGlvbl9tZXRob2QgPSAoc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4Rik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW0uY29uc3RydWN0aW9uX21ldGhvZCA9IDA7XG5cdFx0fVxuXHRcdGl0ZW0uZGF0YV9yZWZlcmVuY2VfaW5kZXggPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdHN3aXRjaCh0aGlzLmJhc2Vfb2Zmc2V0X3NpemUpIHtcblx0XHRcdGNhc2UgMDpcblx0XHRcdFx0aXRlbS5iYXNlX29mZnNldCA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRpdGVtLmJhc2Vfb2Zmc2V0ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDg6XG5cdFx0XHRcdGl0ZW0uYmFzZV9vZmZzZXQgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IFwiRXJyb3IgcmVhZGluZyBiYXNlIG9mZnNldCBzaXplXCI7XG5cdFx0fVxuXHRcdHZhciBleHRlbnRfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdGl0ZW0uZXh0ZW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGo9MDsgaiA8IGV4dGVudF9jb3VudDsgaisrKSB7XG5cdFx0XHR2YXIgZXh0ZW50ID0ge307XG5cdFx0XHRpdGVtLmV4dGVudHMucHVzaChleHRlbnQpO1xuXHRcdFx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMSB8fCB0aGlzLnZlcnNpb24gPT09IDIpIHtcblx0XHRcdFx0c3dpdGNoKHRoaXMuaW5kZXhfc2l6ZSkge1xuXHRcdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRcdGV4dGVudC5leHRlbnRfaW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0ZXh0ZW50LmV4dGVudF9pbmRleCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHRleHRlbnQuZXh0ZW50X2luZGV4ID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyBcIkVycm9yIHJlYWRpbmcgZXh0ZW50IGluZGV4XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN3aXRjaCh0aGlzLm9mZnNldF9zaXplKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRleHRlbnQuZXh0ZW50X29mZnNldCA9IDA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRleHRlbnQuZXh0ZW50X29mZnNldCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHRleHRlbnQuZXh0ZW50X29mZnNldCA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgXCJFcnJvciByZWFkaW5nIGV4dGVudCBpbmRleFwiO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKHRoaXMubGVuZ3RoX3NpemUpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdGV4dGVudC5leHRlbnRfbGVuZ3RoID0gMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdGV4dGVudC5leHRlbnRfbGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdGV4dGVudC5leHRlbnRfbGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBcIkVycm9yIHJlYWRpbmcgZXh0ZW50IGluZGV4XCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9pbWlyLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImltaXJcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciB0bXAgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMucmVzZXJ2ZWQgPSB0bXAgPj4gNztcblx0dGhpcy5heGlzID0gdG1wICYgMTtcbn0pOy8vIGZpbGU6c3JjL3BhcnNpbmcvaW5mZS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaW5mZVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMCB8fCB0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHR0aGlzLml0ZW1fSUQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdHRoaXMuaXRlbV9wcm90ZWN0aW9uX2luZGV4ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHR0aGlzLml0ZW1fbmFtZSA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHRcdHRoaXMuY29udGVudF90eXBlID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdFx0dGhpcy5jb250ZW50X2VuY29kaW5nID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdH1cblx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuXHRcdHRoaXMuZXh0ZW5zaW9uX3R5cGUgPSBzdHJlYW0ucmVhZFN0cmluZyg0KTtcblx0XHRMb2cud2FybihcIkJveFBhcnNlclwiLCBcIkNhbm5vdCBwYXJzZSBleHRlbnNpb24gdHlwZVwiKTtcblx0XHRzdHJlYW0uc2Vlayh0aGlzLnN0YXJ0K3RoaXMuc2l6ZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmICh0aGlzLnZlcnNpb24gPj0gMikge1xuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcblx0XHRcdHRoaXMuaXRlbV9JRCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDMpIHtcblx0XHRcdHRoaXMuaXRlbV9JRCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0fVxuXHRcdHRoaXMuaXRlbV9wcm90ZWN0aW9uX2luZGV4ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0XHR0aGlzLml0ZW1fdHlwZSA9IHN0cmVhbS5yZWFkU3RyaW5nKDQpO1xuXHRcdHRoaXMuaXRlbV9uYW1lID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdFx0aWYgKHRoaXMuaXRlbV90eXBlID09PSBcIm1pbWVcIikge1xuXHRcdFx0dGhpcy5jb250ZW50X3R5cGUgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0XHRcdHRoaXMuY29udGVudF9lbmNvZGluZyA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5pdGVtX3R5cGUgPT09IFwidXJpIFwiKSB7XG5cdFx0XHR0aGlzLml0ZW1fdXJpX3R5cGUgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0XHR9XG5cdH1cbn0pO1xuLy8gZmlsZTpzcmMvcGFyc2luZy9pcG1hLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJpcG1hXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgaSwgajtcblx0ZW50cnlfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmFzc29jaWF0aW9ucyA9IFtdO1xuXHRmb3IoaT0wOyBpPGVudHJ5X2NvdW50OyBpKyspIHtcblx0XHR2YXIgaXRlbV9hc3NvYyA9IHt9O1xuXHRcdHRoaXMuYXNzb2NpYXRpb25zLnB1c2goaXRlbV9hc3NvYyk7XG5cdFx0aWYgKHRoaXMudmVyc2lvbiA8IDEpIHtcblx0XHRcdGl0ZW1fYXNzb2MuaWQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtX2Fzc29jLmlkID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR9XG5cdFx0dmFyIGFzc29jaWF0aW9uX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdGl0ZW1fYXNzb2MucHJvcHMgPSBbXTtcblx0XHRmb3IgKGogPSAwOyBqIDwgYXNzb2NpYXRpb25fY291bnQ7IGorKykge1xuXHRcdFx0dmFyIHRtcCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHRcdHZhciBwID0ge307XG5cdFx0XHRpdGVtX2Fzc29jLnByb3BzLnB1c2gocCk7XG5cdFx0XHRwLmVzc2VudGlhbCA9ICgodG1wICYgMHg4MCkgPj4gNykgPT09IDE7XG5cdFx0XHRpZiAodGhpcy5mbGFncyAmIDB4MSkge1xuXHRcdFx0XHRwLnByb3BlcnR5X2luZGV4ID0gKHRtcCAmIDB4N0YpIDw8IDggfCBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwLnByb3BlcnR5X2luZGV4ID0gKHRtcCAmIDB4N0YpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvaXJlZi5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaXJlZlwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHJldDtcblx0dmFyIGJveDtcblx0dGhpcy5yZWZlcmVuY2VzID0gW107XG5cblx0d2hpbGUgKHN0cmVhbS5nZXRQb3NpdGlvbigpIDwgdGhpcy5zdGFydCt0aGlzLnNpemUpIHtcblx0XHRyZXQgPSBCb3hQYXJzZXIucGFyc2VPbmVCb3goc3RyZWFtLCB0cnVlLCB0aGlzLnNpemUgLSAoc3RyZWFtLmdldFBvc2l0aW9uKCkgLSB0aGlzLnN0YXJ0KSk7XG5cdFx0aWYgKHJldC5jb2RlID09PSBCb3hQYXJzZXIuT0spIHtcblx0XHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHRcdFx0Ym94ID0gbmV3IEJveFBhcnNlci5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveChyZXQudHlwZSwgcmV0LnNpemUsIHJldC5oZHJfc2l6ZSwgcmV0LnN0YXJ0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJveCA9IG5ldyBCb3hQYXJzZXIuU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3hMYXJnZShyZXQudHlwZSwgcmV0LnNpemUsIHJldC5oZHJfc2l6ZSwgcmV0LnN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdGlmIChib3gud3JpdGUgPT09IEJveFBhcnNlci5Cb3gucHJvdG90eXBlLndyaXRlICYmIGJveC50eXBlICE9PSBcIm1kYXRcIikge1xuXHRcdFx0XHRMb2cud2FybihcIkJveFBhcnNlclwiLCBib3gudHlwZStcIiBib3ggd3JpdGluZyBub3QgeWV0IGltcGxlbWVudGVkLCBrZWVwaW5nIHVucGFyc2VkIGRhdGEgaW4gbWVtb3J5IGZvciBsYXRlciB3cml0ZVwiKTtcblx0XHRcdFx0Ym94LnBhcnNlRGF0YUFuZFJld2luZChzdHJlYW0pO1xuXHRcdFx0fVxuXHRcdFx0Ym94LnBhcnNlKHN0cmVhbSk7XG5cdFx0XHR0aGlzLnJlZmVyZW5jZXMucHVzaChib3gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG59KTtcbi8vIGZpbGU6c3JjL3BhcnNpbmcvaXJvdC5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJpcm90XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmFuZ2xlID0gc3RyZWFtLnJlYWRVaW50OCgpICYgMHgzO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvaXNwZS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwiaXNwZVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5pbWFnZV93aWR0aCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuaW1hZ2VfaGVpZ2h0ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pOy8vIGZpbGU6c3JjL3BhcnNpbmcva2luZC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwia2luZFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zY2hlbWVVUkkgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0dGhpcy52YWx1ZSA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xufSk7XG4vLyBmaWxlOnNyYy9wYXJzaW5nL2xldmEuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcImxldmFcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBjb3VudCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5sZXZlbHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0dmFyIGxldmVsID0ge307XG5cdFx0dGhpcy5sZXZlbHNbaV0gPSBsZXZlbDtcblx0XHRsZXZlbC50cmFja19JRCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dmFyIHRtcF9ieXRlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdGxldmVsLnBhZGRpbmdfZmxhZyA9IHRtcF9ieXRlID4+IDc7XG5cdFx0bGV2ZWwuYXNzaWdubWVudF90eXBlID0gdG1wX2J5dGUgJiAweDdGO1xuXHRcdHN3aXRjaCAobGV2ZWwuYXNzaWdubWVudF90eXBlKSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRcdGxldmVsLmdyb3VwaW5nX3R5cGUgPSBzdHJlYW0ucmVhZFN0cmluZyg0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdGxldmVsLmdyb3VwaW5nX3R5cGUgPSBzdHJlYW0ucmVhZFN0cmluZyg0KTtcblx0XHRcdFx0bGV2ZWwuZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDM6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRsZXZlbC5zdWJfdHJhY2tfaWQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiVW5rbm93biBsZXZhIGFzc2lnbmVtZW50IHR5cGVcIik7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9sc2VsLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcImxzZWxcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMubGF5ZXJfaWQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9tYXhyLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcIm1heHJcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucGVyaW9kID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5ieXRlcyA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9tZGN2LmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcIm1kY3ZcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdGhpcy5kaXNwbGF5X3ByaW1hcmllcyA9IFtdO1xuICAgIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMF0gPSB7fTtcbiAgICB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzBdLnggPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMF0ueSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1sxXSA9IHt9O1xuICAgIHRoaXMuZGlzcGxheV9wcmltYXJpZXNbMV0ueCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1sxXS55ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzJdID0ge307XG4gICAgdGhpcy5kaXNwbGF5X3ByaW1hcmllc1syXS54ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLmRpc3BsYXlfcHJpbWFyaWVzWzJdLnkgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIHRoaXMud2hpdGVfcG9pbnQgPSB7fTtcbiAgICB0aGlzLndoaXRlX3BvaW50LnggPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIHRoaXMud2hpdGVfcG9pbnQueSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5tYXhfZGlzcGxheV9tYXN0ZXJpbmdfbHVtaW5hbmNlID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICB0aGlzLm1pbl9kaXNwbGF5X21hc3RlcmluZ19sdW1pbmFuY2UgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvbWRoZC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWRoZFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0aWYgKHRoaXMudmVyc2lvbiA9PSAxKSB7XG5cdFx0dGhpcy5jcmVhdGlvbl90aW1lID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHR0aGlzLm1vZGlmaWNhdGlvbl90aW1lID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHR0aGlzLnRpbWVzY2FsZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5jcmVhdGlvbl90aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLm1vZGlmaWNhdGlvbl90aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLnRpbWVzY2FsZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdH1cblx0dGhpcy5wYXJzZUxhbmd1YWdlKHN0cmVhbSk7XG5cdHN0cmVhbS5yZWFkVWludDE2KCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9tZWhkLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJtZWhkXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRpZiAodGhpcy5mbGFncyAmIDB4MSkge1xuXHRcdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwibWVoZCBib3ggaW5jb3JyZWN0bHkgdXNlcyBmbGFncyBzZXQgdG8gMSwgY29udmVydGluZyB2ZXJzaW9uIHRvIDFcIik7XG5cdFx0dGhpcy52ZXJzaW9uID0gMTtcblx0fVxuXHRpZiAodGhpcy52ZXJzaW9uID09IDEpIHtcblx0XHR0aGlzLmZyYWdtZW50X2R1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmZyYWdtZW50X2R1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvbWV0YS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWV0YVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5ib3hlcyA9IFtdO1xuXHRCb3hQYXJzZXIuQ29udGFpbmVyQm94LnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHN0cmVhbSk7XG59KTtcbi8vIGZpbGU6c3JjL3BhcnNpbmcvbWZoZC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWZoZFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zZXF1ZW5jZV9udW1iZXIgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvbWZyby5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwibWZyb1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5fc2l6ZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9tdmhkLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJtdmhkXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRpZiAodGhpcy52ZXJzaW9uID09IDEpIHtcblx0XHR0aGlzLmNyZWF0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuXHRcdHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuXHRcdHRoaXMudGltZXNjYWxlID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLmR1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmNyZWF0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMudGltZXNjYWxlID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLmR1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fVxuXHR0aGlzLnJhdGUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnZvbHVtZSA9IHN0cmVhbS5yZWFkVWludDE2KCk+Pjg7XG5cdHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHN0cmVhbS5yZWFkVWludDMyQXJyYXkoMik7XG5cdHRoaXMubWF0cml4ID0gc3RyZWFtLnJlYWRVaW50MzJBcnJheSg5KTtcblx0c3RyZWFtLnJlYWRVaW50MzJBcnJheSg2KTtcblx0dGhpcy5uZXh0X3RyYWNrX2lkID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuLy8gZmlsZTpzcmMvcGFyc2luZy9ucGNrLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcIm5wY2tcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucGFja2V0c3NlbnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvbnVtcC5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJudW1wXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhY2tldHNzZW50ID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3BhZGIuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInBhZGJcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBzYW1wbGVfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnBhZGJpdHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLmZsb29yKChzYW1wbGVfY291bnQrMSkvMik7IGkrKykge1xuXHRcdHRoaXMucGFkYml0cyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvcGFzcC5qc1xuQm94UGFyc2VyLmNyZWF0ZUJveEN0b3IoXCJwYXNwXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmhTcGFjaW5nID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy52U3BhY2luZyA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTsvLyBmaWxlOnNyYy9wYXJzaW5nL3BheWwuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwicGF5bFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy50ZXh0ID0gc3RyZWFtLnJlYWRTdHJpbmcodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9wYXl0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcInBheXRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucGF5bG9hZElEID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dmFyIGNvdW50ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLnJ0cG1hcF9zdHJpbmcgPSBzdHJlYW0ucmVhZFN0cmluZyhjb3VudCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9wZGluLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJwZGluXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgY291bnQgPSAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSkvODtcblx0dGhpcy5yYXRlID0gW107XG5cdHRoaXMuaW5pdGlhbF9kZWxheSA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHR0aGlzLnJhdGVbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuaW5pdGlhbF9kZWxheVtpXSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3BpdG0uanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInBpdG1cIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHR0aGlzLml0ZW1faWQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuaXRlbV9pZCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3BpeGkuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInBpeGlcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR0aGlzLm51bV9jaGFubmVscyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5iaXRzX3Blcl9jaGFubmVscyA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1fY2hhbm5lbHM7IGkrKykge1xuXHRcdHRoaXMuYml0c19wZXJfY2hhbm5lbHNbaV0gPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3BtYXguanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwicG1heFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5ieXRlcyA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9wcmZ0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJwcmZ0XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnJlZl90cmFja19pZCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMubnRwX3RpbWVzdGFtcCA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHR0aGlzLm1lZGlhX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMubWVkaWFfdGltZSA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3Bzc2guanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInBzc2hcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuc3lzdGVtX2lkID0gQm94UGFyc2VyLnBhcnNlSGV4MTYoc3RyZWFtKTtcblx0aWYgKHRoaXMudmVyc2lvbiA+IDApIHtcblx0XHR2YXIgY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMua2lkID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLmtpZFtpXSA9IEJveFBhcnNlci5wYXJzZUhleDE2KHN0cmVhbSk7XG5cdFx0fVxuXHR9XG5cdHZhciBkYXRhc2l6ZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdGlmIChkYXRhc2l6ZSA+IDApIHtcblx0XHR0aGlzLmRhdGEgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoZGF0YXNpemUpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9xdC9jbGVmLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJjbGVmXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLndpZHRoID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5oZWlnaHQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9xdC9lbm9mLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJlbm9mXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLndpZHRoID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5oZWlnaHQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9xdC9wcm9mLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJwcm9mXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLndpZHRoID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5oZWlnaHQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9xdC90YXB0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlQ29udGFpbmVyQm94Q3RvcihcInRhcHRcIiwgbnVsbCwgWyBcImNsZWZcIiwgXCJwcm9mXCIsIFwiZW5vZlwiXSk7Ly8gZmlsZTpzcmMvcGFyc2luZy9ydHAuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwicnRwIFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5kZXNjcmlwdGlvbmZvcm1hdCA9IHN0cmVhbS5yZWFkU3RyaW5nKDQpO1xuXHR0aGlzLnNkcHRleHQgPSBzdHJlYW0ucmVhZFN0cmluZyh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gNCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYWlvLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzYWlvXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRpZiAodGhpcy5mbGFncyAmIDB4MSkge1xuXHRcdHRoaXMuYXV4X2luZm9fdHlwZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dGhpcy5hdXhfaW5mb190eXBlX3BhcmFtZXRlciA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdH1cblx0dmFyIGNvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5vZmZzZXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMCkge1xuXHRcdFx0dGhpcy5vZmZzZXRbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9mZnNldFtpXSA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdFx0fVxuXHR9XG59KTtcbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2Fpei5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2FpelwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0aWYgKHRoaXMuZmxhZ3MgJiAweDEpIHtcblx0XHR0aGlzLmF1eF9pbmZvX3R5cGUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuYXV4X2luZm9fdHlwZV9wYXJhbWV0ZXIgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG5cdHRoaXMuZGVmYXVsdF9zYW1wbGVfaW5mb19zaXplID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR2YXIgY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnNhbXBsZV9pbmZvX3NpemUgPSBbXTtcblx0aWYgKHRoaXMuZGVmYXVsdF9zYW1wbGVfaW5mb19zaXplID09PSAwKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnNhbXBsZV9pbmZvX3NpemVbaV0gPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVlbnRyaWVzL21ldHQuanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX01FVEFEQVRBLCBcIm1ldHRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucGFyc2VIZWFkZXIoc3RyZWFtKTtcblx0dGhpcy5jb250ZW50X2VuY29kaW5nID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdHRoaXMubWltZV9mb3JtYXQgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0dGhpcy5wYXJzZUZvb3RlcihzdHJlYW0pO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZW50cmllcy9tZXR4LmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSwgXCJtZXR4XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlSGVhZGVyKHN0cmVhbSk7XG5cdHRoaXMuY29udGVudF9lbmNvZGluZyA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHR0aGlzLm5hbWVzcGFjZSA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHR0aGlzLnNjaGVtYV9sb2NhdGlvbiA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHR0aGlzLnBhcnNlRm9vdGVyKHN0cmVhbSk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVlbnRyaWVzL3NidHQuanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVFbnRyeUN0b3IoQm94UGFyc2VyLlNBTVBMRV9FTlRSWV9UWVBFX1NVQlRJVExFLCBcInNidHRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucGFyc2VIZWFkZXIoc3RyZWFtKTtcblx0dGhpcy5jb250ZW50X2VuY29kaW5nID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdHRoaXMubWltZV9mb3JtYXQgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0dGhpcy5wYXJzZUZvb3RlcihzdHJlYW0pO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZW50cmllcy9zdHBwLmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSwgXCJzdHBwXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlSGVhZGVyKHN0cmVhbSk7XG5cdHRoaXMubmFtZXNwYWNlID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdHRoaXMuc2NoZW1hX2xvY2F0aW9uID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdHRoaXMuYXV4aWxpYXJ5X21pbWVfdHlwZXMgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0dGhpcy5wYXJzZUZvb3RlcihzdHJlYW0pO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZW50cmllcy9zdHh0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9TVUJUSVRMRSwgXCJzdHh0XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlSGVhZGVyKHN0cmVhbSk7XG5cdHRoaXMuY29udGVudF9lbmNvZGluZyA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHR0aGlzLm1pbWVfZm9ybWF0ID0gc3RyZWFtLnJlYWRDU3RyaW5nKCk7XG5cdHRoaXMucGFyc2VGb290ZXIoc3RyZWFtKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWVudHJpZXMvdHgzZy5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUVudHJ5Q3RvcihCb3hQYXJzZXIuU0FNUExFX0VOVFJZX1RZUEVfU1VCVElUTEUsIFwidHgzZ1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5wYXJzZUhlYWRlcihzdHJlYW0pO1xuXHR0aGlzLmRpc3BsYXlGbGFncyA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuaG9yaXpvbnRhbF9qdXN0aWZpY2F0aW9uID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdHRoaXMudmVydGljYWxfanVzdGlmaWNhdGlvbiA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHR0aGlzLmJnX2NvbG9yX3JnYmEgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoNCk7XG5cdHRoaXMuYm94X3JlY29yZCA9IHN0cmVhbS5yZWFkSW50MTZBcnJheSg0KTtcblx0dGhpcy5zdHlsZV9yZWNvcmQgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoMTIpO1xuXHR0aGlzLnBhcnNlRm9vdGVyKHN0cmVhbSk7XG59KTtcbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZW50cmllcy93dnR0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlRW50cnlDdG9yKEJveFBhcnNlci5TQU1QTEVfRU5UUllfVFlQRV9NRVRBREFUQSwgXCJ3dnR0XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlSGVhZGVyKHN0cmVhbSk7XG5cdHRoaXMucGFyc2VGb290ZXIoc3RyZWFtKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy9hbHN0LmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwiYWxzdFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHZhciByb2xsX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5maXJzdF9vdXRwdXRfc2FtcGxlID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5zYW1wbGVfb2Zmc2V0ID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByb2xsX2NvdW50OyBpKyspIHtcblx0XHR0aGlzLnNhbXBsZV9vZmZzZXRbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG5cdHZhciByZW1haW5pbmcgPSB0aGlzLmRlc2NyaXB0aW9uX2xlbmd0aCAtIDQgLSA0KnJvbGxfY291bnQ7XG5cdHRoaXMubnVtX291dHB1dF9zYW1wbGVzID0gW107XG5cdHRoaXMubnVtX3RvdGFsX3NhbXBsZXMgPSBbXTtcblx0Zm9yIChpID0gMDsgaSA8IHJlbWFpbmluZy80OyBpKyspIHtcblx0XHR0aGlzLm51bV9vdXRwdXRfc2FtcGxlc1tpXSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0dGhpcy5udW1fdG90YWxfc2FtcGxlc1tpXSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy9hdmxsLmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwiYXZsbFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5sYXllck51bWJlciA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5hY2N1cmF0ZVN0YXRpc3RpY3NGbGFnID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLmF2Z0JpdFJhdGUgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR0aGlzLmF2Z0ZyYW1lUmF0ZSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVncm91cHMvYXZzcy5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcImF2c3NcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuc3ViU2VxdWVuY2VJZGVudGlmaWVyID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5sYXllck51bWJlciA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dmFyIHRtcF9ieXRlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLmR1cmF0aW9uRmxhZyA9IHRtcF9ieXRlID4+IDc7XG5cdHRoaXMuYXZnUmF0ZUZsYWcgPSAodG1wX2J5dGUgPj4gNikgJiAweDE7XG5cdGlmICh0aGlzLmR1cmF0aW9uRmxhZykge1xuXHRcdHRoaXMuZHVyYXRpb24gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG5cdGlmICh0aGlzLmF2Z1JhdGVGbGFnKSB7XG5cdFx0dGhpcy5hY2N1cmF0ZVN0YXRpc3RpY3NGbGFnID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMuYXZnQml0UmF0ZSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0dGhpcy5hdmdGcmFtZVJhdGUgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR9XG5cdHRoaXMuZGVwZW5kZW5jeSA9IFtdO1xuXHR2YXIgbnVtUmVmZXJlbmNlcyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1SZWZlcmVuY2VzOyBpKyspIHtcblx0XHR2YXIgZGVwZW5kZW5jeUluZm8gPSB7fTtcblx0XHR0aGlzLmRlcGVuZGVuY3kucHVzaChkZXBlbmRlbmN5SW5mbyk7XG5cdFx0ZGVwZW5kZW5jeUluZm8uc3ViU2VxRGlyZWN0aW9uRmxhZyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHRkZXBlbmRlbmN5SW5mby5sYXllck51bWJlciA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHRkZXBlbmRlbmN5SW5mby5zdWJTZXF1ZW5jZUlkZW50aWZpZXIgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVncm91cHMvZHRydC5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcImR0cnRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiK3RoaXMuZ3JvdXBpbmdfdHlwZStcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZ3JvdXBzL212aWYuanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJtdmlmXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRMb2cud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIit0aGlzLmdyb3VwaW5nX3R5cGUrXCIgbm90IGZ1bGx5IHBhcnNlZFwiKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy9wcm9sLmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwicHJvbFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5yb2xsX2Rpc3RhbmNlID0gc3RyZWFtLnJlYWRJbnQxNigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZ3JvdXBzL3JhcC5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInJhcCBcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciB0bXBfYnl0ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5udW1fbGVhZGluZ19zYW1wbGVzX2tub3duID0gdG1wX2J5dGUgPj4gNztcblx0dGhpcy5udW1fbGVhZGluZ19zYW1wbGVzID0gdG1wX2J5dGUgJiAweDdGO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZ3JvdXBzL3Jhc2guanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJyYXNoXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdGlmICh0aGlzLmRlc2NyaXB0aW9uX2xlbmd0aCAhPT0gMisodGhpcy5vcGVyYXRpb25fcG9pbnRfY291bnQgPT09IDE/Mjp0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCo2KSs5KSB7XG5cdFx0TG9nLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJNaXNtYXRjaCBpbiBcIit0aGlzLmdyb3VwaW5nX3R5cGUrXCIgc2FtcGxlIGdyb3VwIGxlbmd0aFwiKTtcblx0XHR0aGlzLmRhdGEgPSAgc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuZGVzY3JpcHRpb25fbGVuZ3RoLTIpO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0aGlzLm9wZXJhdGlvbl9wb2ludF9jb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy50YXJnZXRfcmF0ZV9zaGFyZSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudGFyZ2V0X3JhdGVfc2hhcmUgPSBbXTtcblx0XHRcdHRoaXMuYXZhaWxhYmxlX2JpdHJhdGUgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcGVyYXRpb25fcG9pbnRfY291bnQ7IGkrKykge1xuXHRcdFx0XHR0aGlzLmF2YWlsYWJsZV9iaXRyYXRlW2ldID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRcdFx0dGhpcy50YXJnZXRfcmF0ZV9zaGFyZVtpXSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMubWF4aW11bV9iaXRyYXRlID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLm1pbmltdW1fYml0cmF0ZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dGhpcy5kaXNjYXJkX3ByaW9yaXR5ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVncm91cHMvcm9sbC5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInJvbGxcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMucm9sbF9kaXN0YW5jZSA9IHN0cmVhbS5yZWFkSW50MTYoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy9zYW1wbGVncm91cC5qc1xuQm94UGFyc2VyLlNhbXBsZUdyb3VwRW50cnkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiVW5rbm93biBTYW1wbGUgR3JvdXAgdHlwZTogXCIrdGhpcy5ncm91cGluZ190eXBlKTtcblx0dGhpcy5kYXRhID0gIHN0cmVhbS5yZWFkVWludDhBcnJheSh0aGlzLmRlc2NyaXB0aW9uX2xlbmd0aCk7XG59O1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy9zY2lmLmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwic2NpZlwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0TG9nLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIrdGhpcy5ncm91cGluZ190eXBlK1wiIG5vdCBmdWxseSBwYXJzZWRcIik7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVncm91cHMvc2NubS5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInNjbm1cIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiK3RoaXMuZ3JvdXBpbmdfdHlwZStcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZ3JvdXBzL3NlaWcuanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJzZWlnXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnJlc2VydmVkID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR2YXIgdG1wID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLmNyeXB0X2J5dGVfYmxvY2sgPSB0bXAgPj4gNDtcblx0dGhpcy5za2lwX2J5dGVfYmxvY2sgPSB0bXAgJiAweEY7XG5cdHRoaXMuaXNQcm90ZWN0ZWQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuUGVyX1NhbXBsZV9JVl9TaXplID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHR0aGlzLktJRCA9IEJveFBhcnNlci5wYXJzZUhleDE2KHN0cmVhbSk7XG5cdHRoaXMuY29uc3RhbnRfSVZfc2l6ZSA9IDA7XG5cdHRoaXMuY29uc3RhbnRfSVYgPSAwO1xuXHRpZiAodGhpcy5pc1Byb3RlY3RlZCA9PT0gMSAmJiB0aGlzLlBlcl9TYW1wbGVfSVZfU2l6ZSA9PT0gMCkge1xuXHRcdHRoaXMuY29uc3RhbnRfSVZfc2l6ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR0aGlzLmNvbnN0YW50X0lWID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KHRoaXMuY29uc3RhbnRfSVZfc2l6ZSk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy9zdHNhLmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwic3RzYVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0TG9nLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIrdGhpcy5ncm91cGluZ190eXBlK1wiIG5vdCBmdWxseSBwYXJzZWRcIik7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVncm91cHMvc3luYy5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInN5bmNcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciB0bXBfYnl0ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5OQUxfdW5pdF90eXBlID0gdG1wX2J5dGUgJiAweDNGO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZ3JvdXBzL3RlbGUuanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJ0ZWxlXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgdG1wX2J5dGUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMubGV2ZWxfaW5kZXBlbmRlbnRseV9kZWNvZGFibGUgPSB0bXBfYnl0ZSA+PiA3O1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2FtcGxlZ3JvdXBzL3RzYXMuanNcbkJveFBhcnNlci5jcmVhdGVTYW1wbGVHcm91cEN0b3IoXCJ0c2FzXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRMb2cud2FybihcIkJveFBhcnNlclwiLCBcIlNhbXBsZSBHcm91cCB0eXBlOiBcIit0aGlzLmdyb3VwaW5nX3R5cGUrXCIgbm90IGZ1bGx5IHBhcnNlZFwiKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NhbXBsZWdyb3Vwcy90c2NsLmpzXG5Cb3hQYXJzZXIuY3JlYXRlU2FtcGxlR3JvdXBDdG9yKFwidHNjbFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0TG9nLndhcm4oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGUgR3JvdXAgdHlwZTogXCIrdGhpcy5ncm91cGluZ190eXBlK1wiIG5vdCBmdWxseSBwYXJzZWRcIik7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zYW1wbGVncm91cHMvdmlwci5qc1xuQm94UGFyc2VyLmNyZWF0ZVNhbXBsZUdyb3VwQ3RvcihcInZpcHJcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdExvZy53YXJuKFwiQm94UGFyc2VyXCIsIFwiU2FtcGxlIEdyb3VwIHR5cGU6IFwiK3RoaXMuZ3JvdXBpbmdfdHlwZStcIiBub3QgZnVsbHkgcGFyc2VkXCIpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2JncC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2JncFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5ncm91cGluZ190eXBlID0gc3RyZWFtLnJlYWRTdHJpbmcoNCk7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHR0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyID0gMDtcblx0fVxuXHR0aGlzLmVudHJpZXMgPSBbXTtcblx0dmFyIGVudHJ5X2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0ge307XG5cdFx0dGhpcy5lbnRyaWVzLnB1c2goZW50cnkpO1xuXHRcdGVudHJ5LnNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkSW50MzIoKTtcblx0XHRlbnRyeS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA9IHN0cmVhbS5yZWFkSW50MzIoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2NobS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2NobVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zY2hlbWVfdHlwZSA9IHN0cmVhbS5yZWFkU3RyaW5nKDQpO1xuXHR0aGlzLnNjaGVtZV92ZXJzaW9uID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0aWYgKHRoaXMuZmxhZ3MgJiAweDAwMDAwMSkge1xuXHRcdHRoaXMuc2NoZW1lX3VyaSA9IHN0cmVhbS5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSA4KTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2RwLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcInNkcCBcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuc2RwdGV4dCA9IHN0cmVhbS5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc2R0cC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic2R0cFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHRtcF9ieXRlO1xuXHR2YXIgY291bnQgPSAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSk7XG5cdHRoaXMuaXNfbGVhZGluZyA9IFtdO1xuXHR0aGlzLnNhbXBsZV9kZXBlbmRzX29uID0gW107XG5cdHRoaXMuc2FtcGxlX2lzX2RlcGVuZGVkX29uID0gW107XG5cdHRoaXMuc2FtcGxlX2hhc19yZWR1bmRhbmN5ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdHRtcF9ieXRlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMuaXNfbGVhZGluZ1tpXSA9IHRtcF9ieXRlID4+IDY7XG5cdFx0dGhpcy5zYW1wbGVfZGVwZW5kc19vbltpXSA9ICh0bXBfYnl0ZSA+PiA0KSAmIDB4Mztcblx0XHR0aGlzLnNhbXBsZV9pc19kZXBlbmRlZF9vbltpXSA9ICh0bXBfYnl0ZSA+PiAyKSAmIDB4Mztcblx0XHR0aGlzLnNhbXBsZV9oYXNfcmVkdW5kYW5jeVtpXSA9IHRtcF9ieXRlICYgMHgzO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zZW5jLmpzXG4vLyBDYW5ub3QgYmUgZnVsbHkgcGFyc2VkIGJlY2F1c2UgUGVyX1NhbXBsZV9JVl9TaXplIG5lZWRzIHRvIGJlIGtub3duXHJcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInNlbmNcIiAvKiwgZnVuY3Rpb24oc3RyZWFtKSB7XHJcblx0dGhpcy5wYXJzZUZ1bGxIZWFkZXIoc3RyZWFtKTtcclxuXHR2YXIgc2FtcGxlX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcclxuXHR0aGlzLnNhbXBsZXMgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZV9jb3VudDsgaSsrKSB7XHJcblx0XHR2YXIgc2FtcGxlID0ge307XHJcblx0XHQvLyB0ZW5jLmRlZmF1bHRfUGVyX1NhbXBsZV9JVl9TaXplIG9yIHNlaWcuUGVyX1NhbXBsZV9JVl9TaXplXHJcblx0XHRzYW1wbGUuSW5pdGlhbGl6YXRpb25WZWN0b3IgPSB0aGlzLnJlYWRVaW50OEFycmF5KFBlcl9TYW1wbGVfSVZfU2l6ZSo4KTtcclxuXHRcdGlmICh0aGlzLmZsYWdzICYgMHgyKSB7XHJcblx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzID0gW107XHJcblx0XHRcdHN1YnNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc3Vic2FtcGxlX2NvdW50OyBqKyspIHtcclxuXHRcdFx0XHR2YXIgc3Vic2FtcGxlID0ge307XHJcblx0XHRcdFx0c3Vic2FtcGxlLkJ5dGVzT2ZDbGVhckRhdGEgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xyXG5cdFx0XHRcdHN1YnNhbXBsZS5CeXRlc09mUHJvdGVjdGVkRGF0YSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XHJcblx0XHRcdFx0c2FtcGxlLnN1YnNhbXBsZXMucHVzaChzdWJzYW1wbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBUT0RPXHJcblx0XHR0aGlzLnNhbXBsZXMucHVzaChzYW1wbGUpO1xyXG5cdH1cclxufSovKTtcclxuLy8gZmlsZTpzcmMvcGFyc2luZy9zZ3BkLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzZ3BkXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmdyb3VwaW5nX3R5cGUgPSBzdHJlYW0ucmVhZFN0cmluZyg0KTtcblx0TG9nLmRlYnVnKFwiQm94UGFyc2VyXCIsIFwiRm91bmQgU2FtcGxlIEdyb3VwcyBvZiB0eXBlIFwiK3RoaXMuZ3JvdXBpbmdfdHlwZSk7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHR0aGlzLmRlZmF1bHRfbGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmRlZmF1bHRfbGVuZ3RoID0gMDtcblx0fVxuXHRpZiAodGhpcy52ZXJzaW9uID49IDIpIHtcblx0XHR0aGlzLmRlZmF1bHRfZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG5cdHRoaXMuZW50cmllcyA9IFtdO1xuXHR2YXIgZW50cnlfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5X2NvdW50OyBpKyspIHtcblx0XHR2YXIgZW50cnk7XG5cdFx0aWYgKEJveFBhcnNlclt0aGlzLmdyb3VwaW5nX3R5cGUrXCJTYW1wbGVHcm91cEVudHJ5XCJdKSB7XG5cdFx0XHRlbnRyeSA9IG5ldyBCb3hQYXJzZXJbdGhpcy5ncm91cGluZ190eXBlK1wiU2FtcGxlR3JvdXBFbnRyeVwiXSh0aGlzLmdyb3VwaW5nX3R5cGUpO1xuXHRcdH0gIGVsc2Uge1xuXHRcdFx0ZW50cnkgPSBuZXcgQm94UGFyc2VyLlNhbXBsZUdyb3VwRW50cnkodGhpcy5ncm91cGluZ190eXBlKTtcblx0XHR9XG5cdFx0dGhpcy5lbnRyaWVzLnB1c2goZW50cnkpO1xuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHRcdGlmICh0aGlzLmRlZmF1bHRfbGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGVudHJ5LmRlc2NyaXB0aW9uX2xlbmd0aCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbnRyeS5kZXNjcmlwdGlvbl9sZW5ndGggPSB0aGlzLmRlZmF1bHRfbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbnRyeS5kZXNjcmlwdGlvbl9sZW5ndGggPSB0aGlzLmRlZmF1bHRfbGVuZ3RoO1xuXHRcdH1cblx0XHRpZiAoZW50cnkud3JpdGUgPT09IEJveFBhcnNlci5TYW1wbGVHcm91cEVudHJ5LnByb3RvdHlwZS53cml0ZSkge1xuXHRcdFx0TG9nLmluZm8oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGVHcm91cCBmb3IgdHlwZSBcIit0aGlzLmdyb3VwaW5nX3R5cGUrXCIgd3JpdGluZyBub3QgeWV0IGltcGxlbWVudGVkLCBrZWVwaW5nIHVucGFyc2VkIGRhdGEgaW4gbWVtb3J5IGZvciBsYXRlciB3cml0ZVwiKTtcblx0XHRcdC8vIHN0b3JpbmcgZGF0YVxuXHRcdFx0ZW50cnkuZGF0YSA9IHN0cmVhbS5yZWFkVWludDhBcnJheShlbnRyeS5kZXNjcmlwdGlvbl9sZW5ndGgpO1xuXHRcdFx0Ly8gcmV3aW5kaW5nXG5cdFx0XHRzdHJlYW0ucG9zaXRpb24gLT0gZW50cnkuZGVzY3JpcHRpb25fbGVuZ3RoO1xuXHRcdH1cblx0XHRlbnRyeS5wYXJzZShzdHJlYW0pO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zaWR4LmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzaWR4XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnJlZmVyZW5jZV9JRCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMudGltZXNjYWxlID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMCkge1xuXHRcdHRoaXMuZWFybGllc3RfcHJlc2VudGF0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMuZmlyc3Rfb2Zmc2V0ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmVhcmxpZXN0X3ByZXNlbnRhdGlvbl90aW1lID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHR0aGlzLmZpcnN0X29mZnNldCA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdH1cblx0c3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5yZWZlcmVuY2VzID0gW107XG5cdHZhciBjb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdHZhciByZWYgPSB7fTtcblx0XHR0aGlzLnJlZmVyZW5jZXMucHVzaChyZWYpO1xuXHRcdHZhciB0bXBfMzIgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHJlZi5yZWZlcmVuY2VfdHlwZSA9ICh0bXBfMzIgPj4gMzEpICYgMHgxO1xuXHRcdHJlZi5yZWZlcmVuY2VkX3NpemUgPSB0bXBfMzIgJiAweDdGRkZGRkZGO1xuXHRcdHJlZi5zdWJzZWdtZW50X2R1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0bXBfMzIgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHJlZi5zdGFydHNfd2l0aF9TQVAgPSAodG1wXzMyID4+IDMxKSAmIDB4MTtcblx0XHRyZWYuU0FQX3R5cGUgPSAodG1wXzMyID4+IDI4KSAmIDB4Nztcblx0XHRyZWYuU0FQX2RlbHRhX3RpbWUgPSB0bXBfMzIgJiAweEZGRkZGRkY7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3NpbmdsZWl0ZW10eXBlcmVmZXJlbmNlLmpzXG5Cb3hQYXJzZXIuU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3ggPSBmdW5jdGlvbih0eXBlLCBzaXplLCBoZHJfc2l6ZSwgc3RhcnQpIHtcblx0Qm94UGFyc2VyLkJveC5jYWxsKHRoaXMsIHR5cGUsIHNpemUpO1xuXHR0aGlzLmhkcl9zaXplID0gaGRyX3NpemU7XG5cdHRoaXMuc3RhcnQgPSBzdGFydDtcbn07XG5Cb3hQYXJzZXIuU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3gucHJvdG90eXBlID0gbmV3IEJveFBhcnNlci5Cb3goKTtcbkJveFBhcnNlci5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5mcm9tX2l0ZW1fSUQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR2YXIgY291bnQgPSAgc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5yZWZlcmVuY2VzID0gW107XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0dGhpcy5yZWZlcmVuY2VzW2ldID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0fVxufTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zaW5nbGVpdGVtdHlwZXJlZmVyZW5jZWxhcmdlLmpzXG5Cb3hQYXJzZXIuU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3hMYXJnZSA9IGZ1bmN0aW9uKHR5cGUsIHNpemUsIGhkcl9zaXplLCBzdGFydCkge1xuXHRCb3hQYXJzZXIuQm94LmNhbGwodGhpcywgdHlwZSwgc2l6ZSk7XG5cdHRoaXMuaGRyX3NpemUgPSBoZHJfc2l6ZTtcblx0dGhpcy5zdGFydCA9IHN0YXJ0O1xufTtcbkJveFBhcnNlci5TaW5nbGVJdGVtVHlwZVJlZmVyZW5jZUJveExhcmdlLnByb3RvdHlwZSA9IG5ldyBCb3hQYXJzZXIuQm94KCk7XG5Cb3hQYXJzZXIuU2luZ2xlSXRlbVR5cGVSZWZlcmVuY2VCb3hMYXJnZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5mcm9tX2l0ZW1fSUQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR2YXIgY291bnQgPSAgc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5yZWZlcmVuY2VzID0gW107XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0dGhpcy5yZWZlcmVuY2VzW2ldID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fVxufTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9TbURtLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJTbURtXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnByaW1hcnlSQ2hyb21hdGljaXR5X3ggPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIHRoaXMucHJpbWFyeVJDaHJvbWF0aWNpdHlfeSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5wcmltYXJ5R0Nocm9tYXRpY2l0eV94ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLnByaW1hcnlHQ2hyb21hdGljaXR5X3kgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIHRoaXMucHJpbWFyeUJDaHJvbWF0aWNpdHlfeCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy5wcmltYXJ5QkNocm9tYXRpY2l0eV95ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICB0aGlzLndoaXRlUG9pbnRDaHJvbWF0aWNpdHlfeCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgdGhpcy53aGl0ZVBvaW50Q2hyb21hdGljaXR5X3kgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgIHRoaXMubHVtaW5hbmNlTWF4ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICB0aGlzLmx1bWluYW5jZU1pbiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zbWhkLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzbWhkXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmJhbGFuY2UgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRzdHJlYW0ucmVhZFVpbnQxNigpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3NpeC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3NpeFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zdWJzZWdtZW50cyA9IFtdO1xuXHR2YXIgc3Vic2VnbWVudF9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2VnbWVudF9jb3VudDsgaSsrKSB7XG5cdFx0dmFyIHN1YnNlZ21lbnQgPSB7fTtcblx0XHR0aGlzLnN1YnNlZ21lbnRzLnB1c2goc3Vic2VnbWVudCk7XG5cdFx0c3Vic2VnbWVudC5yYW5nZXMgPSBbXTtcblx0XHR2YXIgcmFuZ2VfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgcmFuZ2VfY291bnQ7IGorKykge1xuXHRcdFx0dmFyIHJhbmdlID0ge307XG5cdFx0XHRzdWJzZWdtZW50LnJhbmdlcy5wdXNoKHJhbmdlKTtcblx0XHRcdHJhbmdlLmxldmVsID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdFx0cmFuZ2UucmFuZ2Vfc2l6ZSA9IHN0cmVhbS5yZWFkVWludDI0KCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zdGNvLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzdGNvXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgZW50cnlfY291bnQ7XG5cdGVudHJ5X2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5jaHVua19vZmZzZXRzID0gW107XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5X2NvdW50OyBpKyspIHtcblx0XHRcdHRoaXMuY2h1bmtfb2Zmc2V0cy5wdXNoKHN0cmVhbS5yZWFkVWludDMyKCkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3RkcC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RkcFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGNvdW50ID0gKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpLzI7XG5cdHRoaXMucHJpb3JpdHkgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0dGhpcy5wcmlvcml0eVtpXSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3N0aGQuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInN0aGRcIik7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3RyaS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RyaVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zd2l0Y2hfZ3JvdXAgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR0aGlzLmFsdGVybmF0ZV9ncm91cCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdHRoaXMuc3ViX3RyYWNrX2lkID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dmFyIGNvdW50ID0gKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgLSA4KS80O1xuXHR0aGlzLmF0dHJpYnV0ZV9saXN0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdHRoaXMuYXR0cmlidXRlX2xpc3RbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zdHNjLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzdHNjXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgZW50cnlfY291bnQ7XG5cdHZhciBpO1xuXHRlbnRyeV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuZmlyc3RfY2h1bmsgPSBbXTtcblx0dGhpcy5zYW1wbGVzX3Blcl9jaHVuayA9IFtdO1xuXHR0aGlzLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA9IFtdO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0Zm9yKGk9MDsgaTxlbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLmZpcnN0X2NodW5rLnB1c2goc3RyZWFtLnJlYWRVaW50MzIoKSk7XG5cdFx0XHR0aGlzLnNhbXBsZXNfcGVyX2NodW5rLnB1c2goc3RyZWFtLnJlYWRVaW50MzIoKSk7XG5cdFx0XHR0aGlzLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleC5wdXNoKHN0cmVhbS5yZWFkVWludDMyKCkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3RzZC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RzZFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHZhciByZXQ7XG5cdHZhciBlbnRyeUNvdW50O1xuXHR2YXIgYm94O1xuXHR0aGlzLmVudHJpZXMgPSBbXTtcblx0ZW50cnlDb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdGZvciAoaSA9IDE7IGkgPD0gZW50cnlDb3VudDsgaSsrKSB7XG5cdFx0cmV0ID0gQm94UGFyc2VyLnBhcnNlT25lQm94KHN0cmVhbSwgdHJ1ZSwgdGhpcy5zaXplIC0gKHN0cmVhbS5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpO1xuXHRcdGlmIChyZXQuY29kZSA9PT0gQm94UGFyc2VyLk9LKSB7XG5cdFx0XHRpZiAoQm94UGFyc2VyW3JldC50eXBlK1wiU2FtcGxlRW50cnlcIl0pIHtcblx0XHRcdFx0Ym94ID0gbmV3IEJveFBhcnNlcltyZXQudHlwZStcIlNhbXBsZUVudHJ5XCJdKHJldC5zaXplKTtcblx0XHRcdFx0Ym94Lmhkcl9zaXplID0gcmV0Lmhkcl9zaXplO1xuXHRcdFx0XHRib3guc3RhcnQgPSByZXQuc3RhcnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMb2cud2FybihcIkJveFBhcnNlclwiLCBcIlVua25vd24gc2FtcGxlIGVudHJ5IHR5cGU6IFwiK3JldC50eXBlKTtcblx0XHRcdFx0Ym94ID0gbmV3IEJveFBhcnNlci5TYW1wbGVFbnRyeShyZXQudHlwZSwgcmV0LnNpemUsIHJldC5oZHJfc2l6ZSwgcmV0LnN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdGlmIChib3gud3JpdGUgPT09IEJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGUpIHtcblx0XHRcdFx0TG9nLmluZm8oXCJCb3hQYXJzZXJcIiwgXCJTYW1wbGVFbnRyeSBcIitib3gudHlwZStcIiBib3ggd3JpdGluZyBub3QgeWV0IGltcGxlbWVudGVkLCBrZWVwaW5nIHVucGFyc2VkIGRhdGEgaW4gbWVtb3J5IGZvciBsYXRlciB3cml0ZVwiKTtcblx0XHRcdFx0Ym94LnBhcnNlRGF0YUFuZFJld2luZChzdHJlYW0pO1xuXHRcdFx0fVxuXHRcdFx0Ym94LnBhcnNlKHN0cmVhbSk7XG5cdFx0XHR0aGlzLmVudHJpZXMucHVzaChib3gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zdHNnLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzdHNnXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmdyb3VwaW5nX3R5cGUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR2YXIgY291bnQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR0aGlzLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdHRoaXMuZ3JvdXBfZGVzY3JpcHRpb25faW5kZXhbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zdHNoLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzdHNoXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgZW50cnlfY291bnQ7XG5cdHZhciBpO1xuXHRlbnRyeV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuc2hhZG93ZWRfc2FtcGxlX251bWJlcnMgPSBbXTtcblx0dGhpcy5zeW5jX3NhbXBsZV9udW1iZXJzID0gW107XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHRmb3IoaT0wOyBpPGVudHJ5X2NvdW50OyBpKyspIHtcblx0XHRcdHRoaXMuc2hhZG93ZWRfc2FtcGxlX251bWJlcnMucHVzaChzdHJlYW0ucmVhZFVpbnQzMigpKTtcblx0XHRcdHRoaXMuc3luY19zYW1wbGVfbnVtYmVycy5wdXNoKHN0cmVhbS5yZWFkVWludDMyKCkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3Rzcy5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3Rzc1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHZhciBlbnRyeV9jb3VudDtcblx0ZW50cnlfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0dGhpcy5zYW1wbGVfbnVtYmVycyA9IFtdO1xuXHRcdGZvcihpPTA7IGk8ZW50cnlfY291bnQ7IGkrKykge1xuXHRcdFx0dGhpcy5zYW1wbGVfbnVtYmVycy5wdXNoKHN0cmVhbS5yZWFkVWludDMyKCkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3Rzei5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3RzelwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHRoaXMuc2FtcGxlX3NpemVzID0gW107XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHR0aGlzLnNhbXBsZV9zaXplID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLnNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2FtcGxlX2NvdW50OyBpKyspIHtcblx0XHRcdGlmICh0aGlzLnNhbXBsZV9zaXplID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2FtcGxlX3NpemVzLnB1c2goc3RyZWFtLnJlYWRVaW50MzIoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNhbXBsZV9zaXplc1tpXSA9IHRoaXMuc2FtcGxlX3NpemU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy9zdHRzLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJzdHRzXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgZW50cnlfY291bnQ7XG5cdHZhciBpO1xuXHR2YXIgZGVsdGE7XG5cdGVudHJ5X2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5zYW1wbGVfY291bnRzID0gW107XG5cdHRoaXMuc2FtcGxlX2RlbHRhcyA9IFtdO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0Zm9yKGk9MDsgaTxlbnRyeV9jb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnNhbXBsZV9jb3VudHMucHVzaChzdHJlYW0ucmVhZFVpbnQzMigpKTtcblx0XHRcdGRlbHRhID0gc3RyZWFtLnJlYWRJbnQzMigpO1xuXHRcdFx0aWYgKGRlbHRhIDwgMCkge1xuXHRcdFx0XHRMb2cud2FybihcIkJveFBhcnNlclwiLCBcIkZpbGUgdXNlcyBuZWdhdGl2ZSBzdHRzIHNhbXBsZSBkZWx0YSwgdXNpbmcgdmFsdWUgMSBpbnN0ZWFkLCBzeW5jIG1heSBiZSBsb3N0IVwiKTtcblx0XHRcdFx0ZGVsdGEgPSAxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zYW1wbGVfZGVsdGFzLnB1c2goZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvc3R2aS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwic3R2aVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHRtcDMyID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5zaW5nbGVfdmlld19hbGxvd2VkID0gdG1wMzIgJiAweDM7XG5cdHRoaXMuc3RlcmVvX3NjaGVtZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHZhciBsZW5ndGggPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnN0ZXJlb19pbmRpY2F0aW9uX3R5cGUgPSBzdHJlYW0ucmVhZFN0cmluZyhsZW5ndGgpO1xuXHR2YXIgcmV0O1xuXHR2YXIgYm94O1xuXHR0aGlzLmJveGVzID0gW107XG5cdHdoaWxlIChzdHJlYW0uZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQrdGhpcy5zaXplKSB7XG5cdFx0cmV0ID0gQm94UGFyc2VyLnBhcnNlT25lQm94KHN0cmVhbSwgZmFsc2UsIHRoaXMuc2l6ZSAtIChzdHJlYW0uZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKTtcblx0XHRpZiAocmV0LmNvZGUgPT09IEJveFBhcnNlci5PSykge1xuXHRcdFx0Ym94ID0gcmV0LmJveDtcblx0XHRcdHRoaXMuYm94ZXMucHVzaChib3gpO1xuXHRcdFx0dGhpc1tib3gudHlwZV0gPSBib3g7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3N0eXAuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwic3R5cFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0Qm94UGFyc2VyLmZ0eXBCb3gucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc3RyZWFtKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3N0ejIuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInN0ejJcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR2YXIgc2FtcGxlX2NvdW50O1xuXHR0aGlzLnNhbXBsZV9zaXplcyA9IFtdO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0dGhpcy5yZXNlcnZlZCA9IHN0cmVhbS5yZWFkVWludDI0KCk7XG5cdFx0dGhpcy5maWVsZF9zaXplID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0aWYgKHRoaXMuZmllbGRfc2l6ZSA9PT0gNCkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNhbXBsZV9jb3VudDsgaSs9Mikge1xuXHRcdFx0XHR2YXIgdG1wID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdFx0XHR0aGlzLnNhbXBsZV9zaXplc1tpXSA9ICh0bXAgPj4gNCkgJiAweEY7XG5cdFx0XHRcdHRoaXMuc2FtcGxlX3NpemVzW2krMV0gPSB0bXAgJiAweEY7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLmZpZWxkX3NpemUgPT09IDgpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzYW1wbGVfY291bnQ7IGkrKykge1xuXHRcdFx0XHR0aGlzLnNhbXBsZV9zaXplc1tpXSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMuZmllbGRfc2l6ZSA9PT0gMTYpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzYW1wbGVfY291bnQ7IGkrKykge1xuXHRcdFx0XHR0aGlzLnNhbXBsZV9zaXplc1tpXSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdExvZy5lcnJvcihcIkJveFBhcnNlclwiLCBcIkVycm9yIGluIGxlbmd0aCBmaWVsZCBpbiBzdHoyIGJveFwiKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3N1YnMuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInN1YnNcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpLGo7XG5cdHZhciBlbnRyeV9jb3VudDtcblx0dmFyIHN1YnNhbXBsZV9jb3VudDtcblx0ZW50cnlfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmVudHJpZXMgPSBbXTtcblx0Zm9yIChpID0gMDsgaSA8IGVudHJ5X2NvdW50OyBpKyspIHtcblx0XHR2YXIgc2FtcGxlSW5mbyA9IHt9O1xuXHRcdHRoaXMuZW50cmllc1tpXSA9IHNhbXBsZUluZm87XG5cdFx0c2FtcGxlSW5mby5zYW1wbGVfZGVsdGEgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHNhbXBsZUluZm8uc3Vic2FtcGxlcyA9IFtdO1xuXHRcdHN1YnNhbXBsZV9jb3VudCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0aWYgKHN1YnNhbXBsZV9jb3VudD4wKSB7XG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgc3Vic2FtcGxlX2NvdW50OyBqKyspIHtcblx0XHRcdFx0dmFyIHN1YnNhbXBsZSA9IHt9O1xuXHRcdFx0XHRzYW1wbGVJbmZvLnN1YnNhbXBsZXMucHVzaChzdWJzYW1wbGUpO1xuXHRcdFx0XHRpZiAodGhpcy52ZXJzaW9uID09IDEpIHtcblx0XHRcdFx0XHRzdWJzYW1wbGUuc2l6ZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3Vic2FtcGxlLnNpemUgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN1YnNhbXBsZS5wcmlvcml0eSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHRcdFx0c3Vic2FtcGxlLmRpc2NhcmRhYmxlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdFx0XHRzdWJzYW1wbGUuY29kZWNfc3BlY2lmaWNfcGFyYW1ldGVycyA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy90ZW5jLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJ0ZW5jXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRzdHJlYW0ucmVhZFVpbnQ4KCk7IC8vIHJlc2VydmVkXG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHRzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHRtcCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR0aGlzLmRlZmF1bHRfY3J5cHRfYnl0ZV9ibG9jayA9ICh0bXAgPj4gNCkgJiAweEY7XG5cdFx0dGhpcy5kZWZhdWx0X3NraXBfYnl0ZV9ibG9jayA9IHRtcCAmIDB4Rjtcblx0fVxuXHR0aGlzLmRlZmF1bHRfaXNQcm90ZWN0ZWQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuZGVmYXVsdF9QZXJfU2FtcGxlX0lWX1NpemUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuZGVmYXVsdF9LSUQgPSBCb3hQYXJzZXIucGFyc2VIZXgxNihzdHJlYW0pO1xuXHRpZiAodGhpcy5kZWZhdWx0X2lzUHJvdGVjdGVkID09PSAxICYmIHRoaXMuZGVmYXVsdF9QZXJfU2FtcGxlX0lWX1NpemUgPT09IDApIHtcblx0XHR0aGlzLmRlZmF1bHRfY29uc3RhbnRfSVZfc2l6ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR0aGlzLmRlZmF1bHRfY29uc3RhbnRfSVYgPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkodGhpcy5kZWZhdWx0X2NvbnN0YW50X0lWX3NpemUpO1xuXHR9XG59KTsvLyBmaWxlOnNyYy9wYXJzaW5nL3RmZHQuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInRmZHRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdGlmICh0aGlzLnZlcnNpb24gPT0gMSkge1xuXHRcdHRoaXMuYmFzZU1lZGlhRGVjb2RlVGltZSA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdGZoZC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidGZoZFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHJlYWRCeXRlcyA9IDA7XG5cdHRoaXMudHJhY2tfaWQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRpZiAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IHJlYWRCeXRlcyAmJiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5URkhEX0ZMQUdfQkFTRV9EQVRBX09GRlNFVCkpIHtcblx0XHR0aGlzLmJhc2VfZGF0YV9vZmZzZXQgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuXHRcdHJlYWRCeXRlcyArPSA4O1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuYmFzZV9kYXRhX29mZnNldCA9IDA7XG5cdH1cblx0aWYgKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiByZWFkQnl0ZXMgJiYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9ERVNDKSkge1xuXHRcdHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHJlYWRCeXRlcyArPSA0O1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggPSAwO1xuXHR9XG5cdGlmICh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gcmVhZEJ5dGVzICYmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19TQU1QTEVfRFVSKSkge1xuXHRcdHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHJlYWRCeXRlcyArPSA0O1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gPSAwO1xuXHR9XG5cdGlmICh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplID4gcmVhZEJ5dGVzICYmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19TQU1QTEVfU0laRSkpIHtcblx0XHR0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHJlYWRCeXRlcyArPSA0O1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZGVmYXVsdF9zYW1wbGVfc2l6ZSA9IDA7XG5cdH1cblx0aWYgKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiByZWFkQnl0ZXMgJiYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9GTEFHUykpIHtcblx0XHR0aGlzLmRlZmF1bHRfc2FtcGxlX2ZsYWdzID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRyZWFkQnl0ZXMgKz0gNDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmRlZmF1bHRfc2FtcGxlX2ZsYWdzID0gMDtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdGZyYS5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidGZyYVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy50cmFja19JRCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHN0cmVhbS5yZWFkVWludDI0KCk7XG5cdHZhciB0bXBfYnl0ZSA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0dGhpcy5sZW5ndGhfc2l6ZV9vZl90cmFmX251bSA9ICh0bXBfYnl0ZSA+PiA0KSAmIDB4Mztcblx0dGhpcy5sZW5ndGhfc2l6ZV9vZl90cnVuX251bSA9ICh0bXBfYnl0ZSA+PiAyKSAmIDB4Mztcblx0dGhpcy5sZW5ndGhfc2l6ZV9vZl9zYW1wbGVfbnVtID0gKHRtcF9ieXRlKSAmIDB4Mztcblx0dGhpcy5lbnRyaWVzID0gW107XG5cdHZhciBudW1iZXJfb2ZfZW50cmllcyA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyX29mX2VudHJpZXM7IGkrKykge1xuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHRcdHRoaXMudGltZSA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdFx0XHR0aGlzLm1vb2Zfb2Zmc2V0ID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRcdHRoaXMubW9vZl9vZmZzZXQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdH1cblx0XHR0aGlzLnRyYWZfbnVtYmVyID0gc3RyZWFtW1wicmVhZFVpbnRcIisoOCoodGhpcy5sZW5ndGhfc2l6ZV9vZl90cmFmX251bSsxKSldKCk7XG5cdFx0dGhpcy50cnVuX251bWJlciA9IHN0cmVhbVtcInJlYWRVaW50XCIrKDgqKHRoaXMubGVuZ3RoX3NpemVfb2ZfdHJ1bl9udW0rMSkpXSgpO1xuXHRcdHRoaXMuc2FtcGxlX251bWJlciA9IHN0cmVhbVtcInJlYWRVaW50XCIrKDgqKHRoaXMubGVuZ3RoX3NpemVfb2Zfc2FtcGxlX251bSsxKSldKCk7XG5cdH1cbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RraGQuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInRraGRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdGlmICh0aGlzLnZlcnNpb24gPT0gMSkge1xuXHRcdHRoaXMuY3JlYXRpb25fdGltZSA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdFx0dGhpcy5tb2RpZmljYXRpb25fdGltZSA9IHN0cmVhbS5yZWFkVWludDY0KCk7XG5cdFx0dGhpcy50cmFja19pZCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0c3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHR0aGlzLmR1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50NjQoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmNyZWF0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMubW9kaWZpY2F0aW9uX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHRoaXMudHJhY2tfaWQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdH1cblx0c3RyZWFtLnJlYWRVaW50MzJBcnJheSgyKTtcblx0dGhpcy5sYXllciA9IHN0cmVhbS5yZWFkSW50MTYoKTtcblx0dGhpcy5hbHRlcm5hdGVfZ3JvdXAgPSBzdHJlYW0ucmVhZEludDE2KCk7XG5cdHRoaXMudm9sdW1lID0gc3RyZWFtLnJlYWRJbnQxNigpPj44O1xuXHRzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHR0aGlzLm1hdHJpeCA9IHN0cmVhbS5yZWFkSW50MzJBcnJheSg5KTtcblx0dGhpcy53aWR0aCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuaGVpZ2h0ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RtYXguanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwidG1heFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy50aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RtaW4uanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwidG1pblwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy50aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RvdGwuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwidG90bFwiLGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLmJ5dGVzc2VudCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy90cGF5LmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcInRwYXlcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuYnl0ZXNzZW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RweWwuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwidHB5bFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5ieXRlc3NlbnQgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvVHJhY2tHcm91cC5qc1xuQm94UGFyc2VyLlRyYWNrR3JvdXBUeXBlQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnBhcnNlRnVsbEhlYWRlcihzdHJlYW0pO1xuXHR0aGlzLnRyYWNrX2dyb3VwX2lkID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn07XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdHJhY2tncm91cHMvbXNyYy5qc1xuQm94UGFyc2VyLmNyZWF0ZVRyYWNrR3JvdXBDdG9yKFwibXNyY1wiKTsvLyBmaWxlOnNyYy9wYXJzaW5nL1RyYWtSZWZlcmVuY2UuanNcbkJveFBhcnNlci5UcmFja1JlZmVyZW5jZVR5cGVCb3ggPSBmdW5jdGlvbih0eXBlLCBzaXplLCBoZHJfc2l6ZSwgc3RhcnQpIHtcblx0Qm94UGFyc2VyLkJveC5jYWxsKHRoaXMsIHR5cGUsIHNpemUpO1xuXHR0aGlzLmhkcl9zaXplID0gaGRyX3NpemU7XG5cdHRoaXMuc3RhcnQgPSBzdGFydDtcbn07XG5Cb3hQYXJzZXIuVHJhY2tSZWZlcmVuY2VUeXBlQm94LnByb3RvdHlwZSA9IG5ldyBCb3hQYXJzZXIuQm94KCk7XG5Cb3hQYXJzZXIuVHJhY2tSZWZlcmVuY2VUeXBlQm94LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnRyYWNrX2lkcyA9IHN0cmVhbS5yZWFkVWludDMyQXJyYXkoKHRoaXMuc2l6ZS10aGlzLmhkcl9zaXplKS80KTtcbn07XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdHJlZi5qc1xuQm94UGFyc2VyLnRyZWZCb3gucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciByZXQ7XG5cdHZhciBib3g7XG5cdHdoaWxlIChzdHJlYW0uZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQrdGhpcy5zaXplKSB7XG5cdFx0cmV0ID0gQm94UGFyc2VyLnBhcnNlT25lQm94KHN0cmVhbSwgdHJ1ZSwgdGhpcy5zaXplIC0gKHN0cmVhbS5nZXRQb3NpdGlvbigpIC0gdGhpcy5zdGFydCkpO1xuXHRcdGlmIChyZXQuY29kZSA9PT0gQm94UGFyc2VyLk9LKSB7XG5cdFx0XHRib3ggPSBuZXcgQm94UGFyc2VyLlRyYWNrUmVmZXJlbmNlVHlwZUJveChyZXQudHlwZSwgcmV0LnNpemUsIHJldC5oZHJfc2l6ZSwgcmV0LnN0YXJ0KTtcblx0XHRcdGlmIChib3gud3JpdGUgPT09IEJveFBhcnNlci5Cb3gucHJvdG90eXBlLndyaXRlICYmIGJveC50eXBlICE9PSBcIm1kYXRcIikge1xuXHRcdFx0XHRMb2cuaW5mbyhcIkJveFBhcnNlclwiLCBcIlRyYWNrUmVmZXJlbmNlIFwiK2JveC50eXBlK1wiIGJveCB3cml0aW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIGtlZXBpbmcgdW5wYXJzZWQgZGF0YSBpbiBtZW1vcnkgZm9yIGxhdGVyIHdyaXRlXCIpO1xuXHRcdFx0XHRib3gucGFyc2VEYXRhQW5kUmV3aW5kKHN0cmVhbSk7XG5cdFx0XHR9XG5cdFx0XHRib3gucGFyc2Uoc3RyZWFtKTtcblx0XHRcdHRoaXMuYm94ZXMucHVzaChib3gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RyZXAuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInRyZXBcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudHJhY2tfSUQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmJveGVzID0gW107XG5cdHdoaWxlIChzdHJlYW0uZ2V0UG9zaXRpb24oKSA8IHRoaXMuc3RhcnQrdGhpcy5zaXplKSB7XG5cdFx0cmV0ID0gQm94UGFyc2VyLnBhcnNlT25lQm94KHN0cmVhbSwgZmFsc2UsIHRoaXMuc2l6ZSAtIChzdHJlYW0uZ2V0UG9zaXRpb24oKSAtIHRoaXMuc3RhcnQpKTtcblx0XHRpZiAocmV0LmNvZGUgPT09IEJveFBhcnNlci5PSykge1xuXHRcdFx0Ym94ID0gcmV0LmJveDtcblx0XHRcdHRoaXMuYm94ZXMucHVzaChib3gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy90cmV4LmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJ0cmV4XCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnRyYWNrX2lkID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0dGhpcy5kZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLmRlZmF1bHRfc2FtcGxlX2ZsYWdzID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3RycHkuanNcbkJveFBhcnNlci5jcmVhdGVCb3hDdG9yKFwidHJweVwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5ieXRlc3NlbnQgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdHJ1bi5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidHJ1blwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIHJlYWRCeXRlcyA9IDA7XG5cdHRoaXMuc2FtcGxlX2NvdW50ID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0cmVhZEJ5dGVzKz0gNDtcblx0aWYgKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUgPiByZWFkQnl0ZXMgJiYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVFJVTl9GTEFHU19EQVRBX09GRlNFVCkgKSB7XG5cdFx0dGhpcy5kYXRhX29mZnNldCA9IHN0cmVhbS5yZWFkSW50MzIoKTsgLy9zaWduZWRcblx0XHRyZWFkQnl0ZXMgKz0gNDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmRhdGFfb2Zmc2V0ID0gMDtcblx0fVxuXHRpZiAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IHJlYWRCeXRlcyAmJiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcpICkge1xuXHRcdHRoaXMuZmlyc3Rfc2FtcGxlX2ZsYWdzID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRyZWFkQnl0ZXMgKz0gNDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmZpcnN0X3NhbXBsZV9mbGFncyA9IDA7XG5cdH1cblx0dGhpcy5zYW1wbGVfZHVyYXRpb24gPSBbXTtcblx0dGhpcy5zYW1wbGVfc2l6ZSA9IFtdO1xuXHR0aGlzLnNhbXBsZV9mbGFncyA9IFtdO1xuXHR0aGlzLnNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldCA9IFtdO1xuXHRpZiAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSA+IHJlYWRCeXRlcykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGVfY291bnQ7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVFJVTl9GTEFHU19EVVJBVElPTikge1xuXHRcdFx0XHR0aGlzLnNhbXBsZV9kdXJhdGlvbltpXSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX1NJWkUpIHtcblx0XHRcdFx0dGhpcy5zYW1wbGVfc2l6ZVtpXSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0ZMQUdTKSB7XG5cdFx0XHRcdHRoaXMuc2FtcGxlX2ZsYWdzW2ldID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfQ1RTX09GRlNFVCkge1xuXHRcdFx0XHRpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRbaV0gPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2ldID0gc3RyZWFtLnJlYWRJbnQzMigpOyAvL3NpZ25lZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy90c2VsLmpzXG5Cb3hQYXJzZXIuY3JlYXRlRnVsbEJveEN0b3IoXCJ0c2VsXCIsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnN3aXRjaF9ncm91cCA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdHZhciBjb3VudCA9ICh0aGlzLnNpemUgLSB0aGlzLmhkcl9zaXplIC0gNCkvNDtcblx0dGhpcy5hdHRyaWJ1dGVfbGlzdCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHR0aGlzLmF0dHJpYnV0ZV9saXN0W2ldID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdHh0Qy5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidHh0Q1wiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5jb25maWcgPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3VybC5qc1xuQm94UGFyc2VyLmNyZWF0ZUZ1bGxCb3hDdG9yKFwidXJsIFwiLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0aWYgKHRoaXMuZmxhZ3MgIT09IDB4MDAwMDAxKSB7XG5cdFx0dGhpcy5sb2NhdGlvbiA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHR9XG59KTtcblxuLy8gZmlsZTpzcmMvcGFyc2luZy91cm4uanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInVybiBcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMubmFtZSA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHRpZiAodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSAtIHRoaXMubmFtZS5sZW5ndGggLSAxID4gMCkge1xuXHRcdHRoaXMubG9jYXRpb24gPSBzdHJlYW0ucmVhZENTdHJpbmcoKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdXVpZC9waWZmL3BpZmZMc20uanNcbkJveFBhcnNlci5jcmVhdGVVVUlEQm94KFwiYTVkNDBiMzBlODE0MTFkZGJhMmYwODAwMjAwYzlhNjZcIiwgdHJ1ZSwgZmFsc2UsIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHRoaXMuTGl2ZVNlcnZlck1hbmlmZXN0ID0gc3RyZWFtLnJlYWRTdHJpbmcodGhpcy5zaXplIC0gdGhpcy5oZHJfc2l6ZSlcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcbn0pOy8vIGZpbGU6c3JjL3BhcnNpbmcvdXVpZC9waWZmL3BpZmZQc3NoLmpzXG5Cb3hQYXJzZXIuY3JlYXRlVVVJREJveChcImQwOGE0ZjE4MTBmMzRhODJiNmM4MzJkOGFiYTE4M2QzXCIsIHRydWUsIGZhbHNlLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zeXN0ZW1faWQgPSBCb3hQYXJzZXIucGFyc2VIZXgxNihzdHJlYW0pO1xuXHR2YXIgZGF0YXNpemUgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHRpZiAoZGF0YXNpemUgPiAwKSB7XG5cdFx0dGhpcy5kYXRhID0gc3RyZWFtLnJlYWRVaW50OEFycmF5KGRhdGFzaXplKTtcblx0fVxufSk7XG5cbi8vIGZpbGU6c3JjL3BhcnNpbmcvdXVpZC9waWZmL3BpZmZTZW5jLmpzXG5Cb3hQYXJzZXIuY3JlYXRlVVVJREJveChcImEyMzk0ZjUyNWE5YjRmMTRhMjQ0NmM0MjdjNjQ4ZGY0XCIsIHRydWUsIGZhbHNlIC8qLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0aWYgKHRoaXMuZmxhZ3MgJiAweDEpIHtcblx0XHR0aGlzLkFsZ29yaXRobUlEID0gc3RyZWFtLnJlYWRVaW50MjQoKTtcblx0XHR0aGlzLklWX3NpemUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0dGhpcy5LSUQgPSBCb3hQYXJzZXIucGFyc2VIZXgxNihzdHJlYW0pO1xuXHR9XG5cdHZhciBzYW1wbGVfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQzMigpO1xuXHR0aGlzLnNhbXBsZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVfY291bnQ7IGkrKykge1xuXHRcdHZhciBzYW1wbGUgPSB7fTtcblx0XHRzYW1wbGUuSW5pdGlhbGl6YXRpb25WZWN0b3IgPSB0aGlzLnJlYWRVaW50OEFycmF5KHRoaXMuSVZfc2l6ZSo4KTtcblx0XHRpZiAodGhpcy5mbGFncyAmIDB4Mikge1xuXHRcdFx0c2FtcGxlLnN1YnNhbXBsZXMgPSBbXTtcblx0XHRcdHNhbXBsZS5OdW1iZXJPZkVudHJpZXMgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGUuTnVtYmVyT2ZFbnRyaWVzOyBqKyspIHtcblx0XHRcdFx0dmFyIHN1YnNhbXBsZSA9IHt9O1xuXHRcdFx0XHRzdWJzYW1wbGUuQnl0ZXNPZkNsZWFyRGF0YSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XG5cdFx0XHRcdHN1YnNhbXBsZS5CeXRlc09mUHJvdGVjdGVkRGF0YSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG5cdFx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzLnB1c2goc3Vic2FtcGxlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5zYW1wbGVzLnB1c2goc2FtcGxlKTtcblx0fVxufSovKTtcbi8vIGZpbGU6c3JjL3BhcnNpbmcvdXVpZC9waWZmL3BpZmZUZW5jLmpzXG5Cb3hQYXJzZXIuY3JlYXRlVVVJREJveChcIjg5NzRkYmNlN2JlNzRjNTE4NGY5NzE0OGY5ODgyNTU0XCIsIHRydWUsIGZhbHNlLCBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5kZWZhdWx0X0FsZ29yaXRobUlEID0gc3RyZWFtLnJlYWRVaW50MjQoKTtcblx0dGhpcy5kZWZhdWx0X0lWX3NpemUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdHRoaXMuZGVmYXVsdF9LSUQgPSBCb3hQYXJzZXIucGFyc2VIZXgxNihzdHJlYW0pO1xufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy91dWlkL3BpZmYvcGlmZlRmcmYuanNcbkJveFBhcnNlci5jcmVhdGVVVUlEQm94KFwiZDQ4MDdlZjJjYTM5NDY5NThlNTQyNmNiOWU0NmE3OWZcIiwgdHJ1ZSwgZmFsc2UsIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHRoaXMuZnJhZ21lbnRfY291bnQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG4gICAgdGhpcy5lbnRyaWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJhZ21lbnRfY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSB7fTtcbiAgICAgICAgdmFyIGFic29sdXRlX3RpbWUgPSAwO1xuICAgICAgICB2YXIgYWJzb2x1dGVfZHVyYXRpb24gPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIGFic29sdXRlX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuICAgICAgICAgICAgYWJzb2x1dGVfZHVyYXRpb24gPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWJzb2x1dGVfdGltZSA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBhYnNvbHV0ZV9kdXJhdGlvbiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5hYnNvbHV0ZV90aW1lID0gYWJzb2x1dGVfdGltZTtcbiAgICAgICAgZW50cnkuYWJzb2x1dGVfZHVyYXRpb24gPSBhYnNvbHV0ZV9kdXJhdGlvbjtcblxuICAgICAgICB0aGlzLmVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy91dWlkL3BpZmYvcGlmZlRmeGQuanNcbkJveFBhcnNlci5jcmVhdGVVVUlEQm94KFwiNmQxZDliMDU0MmQ1NDRlNjgwZTIxNDFkYWZmNzU3YjJcIiwgdHJ1ZSwgZmFsc2UsIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcbiAgICAgICB0aGlzLmFic29sdXRlX3RpbWUgPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuICAgICAgIHRoaXMuZHVyYXRpb24gPSBzdHJlYW0ucmVhZFVpbnQ2NCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgdGhpcy5hYnNvbHV0ZV90aW1lID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICB0aGlzLmR1cmF0aW9uID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICB9XG59KTsvLyBmaWxlOnNyYy9wYXJzaW5nL3ZtaGQuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInZtaGRcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuZ3JhcGhpY3Ntb2RlID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcblx0dGhpcy5vcGNvbG9yID0gc3RyZWFtLnJlYWRVaW50MTZBcnJheSgzKTtcbn0pO1xuXG4vLyBmaWxlOnNyYy9wYXJzaW5nL3ZwY0MuanNcbkJveFBhcnNlci5jcmVhdGVGdWxsQm94Q3RvcihcInZwY0NcIiwgZnVuY3Rpb24gKHN0cmVhbSkge1xuXHR2YXIgdG1wO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG5cdFx0dGhpcy5wcm9maWxlID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMubGV2ZWwgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0dG1wID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMuYml0RGVwdGggPSB0bXAgPj4gNDtcblx0XHR0aGlzLmNocm9tYVN1YnNhbXBsaW5nID0gKHRtcCA+PiAxKSAmIDB4Nztcblx0XHR0aGlzLnZpZGVvRnVsbFJhbmdlRmxhZyA9IHRtcCAmIDB4MTtcblx0XHR0aGlzLmNvbG91clByaW1hcmllcyA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR0aGlzLnRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMubWF0cml4Q29lZmZpY2llbnRzID0gc3RyZWFtLnJlYWRVaW50OCgpO1xuXHRcdHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YVNpemUgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YSA9IHN0cmVhbS5yZWFkVWludDhBcnJheSh0aGlzLmNvZGVjSW50aWFsaXphdGlvbkRhdGFTaXplKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnByb2ZpbGUgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0dGhpcy5sZXZlbCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR0bXAgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XG5cdFx0dGhpcy5iaXREZXB0aCA9ICh0bXAgPj4gNCkgJiAweEY7XG5cdFx0dGhpcy5jb2xvclNwYWNlID0gdG1wICYgMHhGO1xuXHRcdHRtcCA9IHN0cmVhbS5yZWFkVWludDgoKTtcblx0XHR0aGlzLmNocm9tYVN1YnNhbXBsaW5nID0gKHRtcCA+PiA0KSAmIDB4Rjtcblx0XHR0aGlzLnRyYW5zZmVyRnVuY3Rpb24gPSAodG1wID4+IDEpICYgMHg3O1xuXHRcdHRoaXMudmlkZW9GdWxsUmFuZ2VGbGFnID0gdG1wICYgMHgxO1xuXHRcdHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YVNpemUgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xuXHRcdHRoaXMuY29kZWNJbnRpYWxpemF0aW9uRGF0YSA9IHN0cmVhbS5yZWFkVWludDhBcnJheSh0aGlzLmNvZGVjSW50aWFsaXphdGlvbkRhdGFTaXplKTtcblx0fVxufSk7Ly8gZmlsZTpzcmMvcGFyc2luZy92dHRDLmpzXG5Cb3hQYXJzZXIuY3JlYXRlQm94Q3RvcihcInZ0dENcIiwgZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudGV4dCA9IHN0cmVhbS5yZWFkU3RyaW5nKHRoaXMuc2l6ZSAtIHRoaXMuaGRyX3NpemUpO1xufSk7XG5cbi8vIGZpbGU6c3JjL2JveC1jb2RlY3MuanNcbkJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUuaXNWaWRlbyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLmlzQXVkaW8gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc1N1YnRpdGxlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbkJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUuaXNNZXRhZGF0YSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLmlzSGludCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnR5cGUucmVwbGFjZSgnLicsJycpO1xufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCJcIjtcbn07XG5cbkJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIlwiO1xufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDaGFubmVsQ291bnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiXCI7XG59O1xuXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVJhdGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiXCI7XG59O1xuXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVNpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiXCI7XG59O1xuXG5Cb3hQYXJzZXIuVmlzdWFsU2FtcGxlRW50cnkucHJvdG90eXBlLmlzVmlkZW8gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRydWU7XG59O1xuXG5Cb3hQYXJzZXIuVmlzdWFsU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLndpZHRoO1xufTtcblxuQm94UGFyc2VyLlZpc3VhbFNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuaGVpZ2h0O1xufTtcblxuQm94UGFyc2VyLkF1ZGlvU2FtcGxlRW50cnkucHJvdG90eXBlLmlzQXVkaW8gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRydWU7XG59O1xuXG5Cb3hQYXJzZXIuQXVkaW9TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q2hhbm5lbENvdW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNoYW5uZWxfY291bnQ7XG59O1xuXG5Cb3hQYXJzZXIuQXVkaW9TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0U2FtcGxlUmF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zYW1wbGVyYXRlO1xufTtcblxuQm94UGFyc2VyLkF1ZGlvU2FtcGxlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZVNpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc2FtcGxlc2l6ZTtcbn07XG5cbkJveFBhcnNlci5TdWJ0aXRsZVNhbXBsZUVudHJ5LnByb3RvdHlwZS5pc1N1YnRpdGxlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0cnVlO1xufTtcblxuQm94UGFyc2VyLk1ldGFkYXRhU2FtcGxlRW50cnkucHJvdG90eXBlLmlzTWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbkJveFBhcnNlci5kZWNpbWFsVG9IZXggPSBmdW5jdGlvbihkLCBwYWRkaW5nKSB7XG5cdHZhciBoZXggPSBOdW1iZXIoZCkudG9TdHJpbmcoMTYpO1xuXHRwYWRkaW5nID0gdHlwZW9mIChwYWRkaW5nKSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwYWRkaW5nID09PSBudWxsID8gcGFkZGluZyA9IDIgOiBwYWRkaW5nO1xuXHR3aGlsZSAoaGV4Lmxlbmd0aCA8IHBhZGRpbmcpIHtcblx0XHRoZXggPSBcIjBcIiArIGhleDtcblx0fVxuXHRyZXR1cm4gaGV4O1xufTtcblxuQm94UGFyc2VyLmF2YzFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPVxuQm94UGFyc2VyLmF2YzJTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPVxuQm94UGFyc2VyLmF2YzNTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPVxuQm94UGFyc2VyLmF2YzRTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGJhc2VDb2RlYyA9IEJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMuY2FsbCh0aGlzKTtcblx0aWYgKHRoaXMuYXZjQykge1xuXHRcdHJldHVybiBiYXNlQ29kZWMrXCIuXCIrQm94UGFyc2VyLmRlY2ltYWxUb0hleCh0aGlzLmF2Y0MuQVZDUHJvZmlsZUluZGljYXRpb24pK1xuXHRcdFx0XHRcdFx0ICBcIlwiK0JveFBhcnNlci5kZWNpbWFsVG9IZXgodGhpcy5hdmNDLnByb2ZpbGVfY29tcGF0aWJpbGl0eSkrXG5cdFx0XHRcdFx0XHQgIFwiXCIrQm94UGFyc2VyLmRlY2ltYWxUb0hleCh0aGlzLmF2Y0MuQVZDTGV2ZWxJbmRpY2F0aW9uKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gYmFzZUNvZGVjO1xuXHR9XG59O1xuXG5Cb3hQYXJzZXIuaGV2MVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9XG5Cb3hQYXJzZXIuaHZjMVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgaTtcblx0dmFyIGJhc2VDb2RlYyA9IEJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMuY2FsbCh0aGlzKTtcblx0aWYgKHRoaXMuaHZjQykge1xuXHRcdGJhc2VDb2RlYyArPSAnLic7XG5cdFx0c3dpdGNoICh0aGlzLmh2Y0MuZ2VuZXJhbF9wcm9maWxlX3NwYWNlKSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRcdGJhc2VDb2RlYyArPSAnJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdGJhc2VDb2RlYyArPSAnQSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRiYXNlQ29kZWMgKz0gJ0InO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMzpcblx0XHRcdFx0YmFzZUNvZGVjICs9ICdDJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGJhc2VDb2RlYyArPSB0aGlzLmh2Y0MuZ2VuZXJhbF9wcm9maWxlX2lkYztcblx0XHRiYXNlQ29kZWMgKz0gJy4nO1xuXHRcdHZhciB2YWwgPSB0aGlzLmh2Y0MuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHk7XG5cdFx0dmFyIHJldmVyc2VkID0gMDtcblx0XHRmb3IgKGk9MDsgaTwzMjsgaSsrKSB7XG5cdFx0XHRyZXZlcnNlZCB8PSB2YWwgJiAxO1xuXHRcdFx0aWYgKGk9PTMxKSBicmVhaztcblx0XHRcdHJldmVyc2VkIDw8PSAxO1xuXHRcdFx0dmFsID4+PTE7XG5cdFx0fVxuXHRcdGJhc2VDb2RlYyArPSBCb3hQYXJzZXIuZGVjaW1hbFRvSGV4KHJldmVyc2VkLCAwKTtcblx0XHRiYXNlQ29kZWMgKz0gJy4nO1xuXHRcdGlmICh0aGlzLmh2Y0MuZ2VuZXJhbF90aWVyX2ZsYWcgPT09IDApIHtcblx0XHRcdGJhc2VDb2RlYyArPSAnTCc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJhc2VDb2RlYyArPSAnSCc7XG5cdFx0fVxuXHRcdGJhc2VDb2RlYyArPSB0aGlzLmh2Y0MuZ2VuZXJhbF9sZXZlbF9pZGM7XG5cdFx0dmFyIGhhc0J5dGUgPSBmYWxzZTtcblx0XHR2YXIgY29uc3RyYWludF9zdHJpbmcgPSBcIlwiO1xuXHRcdGZvciAoaSA9IDU7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAodGhpcy5odmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JbaV0gfHwgaGFzQnl0ZSkge1xuXHRcdFx0XHRjb25zdHJhaW50X3N0cmluZyA9IFwiLlwiK0JveFBhcnNlci5kZWNpbWFsVG9IZXgodGhpcy5odmNDLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JbaV0sIDApK2NvbnN0cmFpbnRfc3RyaW5nO1xuXHRcdFx0XHRoYXNCeXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YmFzZUNvZGVjICs9IGNvbnN0cmFpbnRfc3RyaW5nO1xuXHR9XG5cdHJldHVybiBiYXNlQ29kZWM7XG59O1xuXG5Cb3hQYXJzZXIubXA0YVNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYmFzZUNvZGVjID0gQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS5nZXRDb2RlYy5jYWxsKHRoaXMpO1xuXHRpZiAodGhpcy5lc2RzICYmIHRoaXMuZXNkcy5lc2QpIHtcblx0XHR2YXIgb3RpID0gdGhpcy5lc2RzLmVzZC5nZXRPVEkoKTtcblx0XHR2YXIgZHNpID0gdGhpcy5lc2RzLmVzZC5nZXRBdWRpb0NvbmZpZygpO1xuXHRcdHJldHVybiBiYXNlQ29kZWMrXCIuXCIrQm94UGFyc2VyLmRlY2ltYWxUb0hleChvdGkpKyhkc2kgPyBcIi5cIitkc2k6IFwiXCIpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBiYXNlQ29kZWM7XG5cdH1cbn07XG5cbkJveFBhcnNlci5zdHh0U2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjID0gZnVuY3Rpb24oKSB7XG5cdHZhciBiYXNlQ29kZWMgPSBCb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLmdldENvZGVjLmNhbGwodGhpcyk7XG5cdGlmKHRoaXMubWltZV9mb3JtYXQpIHtcblx0XHRyZXR1cm4gYmFzZUNvZGVjICsgXCIuXCIgKyB0aGlzLm1pbWVfZm9ybWF0O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBiYXNlQ29kZWNcblx0fVxufTtcblxuQm94UGFyc2VyLmF2MDFTYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGJhc2VDb2RlYyA9IEJveFBhcnNlci5TYW1wbGVFbnRyeS5wcm90b3R5cGUuZ2V0Q29kZWMuY2FsbCh0aGlzKTtcblx0dmFyIGJpdGRlcHRoO1xuXHRpZiAodGhpcy5hdjFDLnNlcV9wcm9maWxlID09PSAyICYmIHRoaXMuYXYxQy5oaWdoX2JpdGRlcHRoID09PSAxKSB7XG5cdFx0Yml0ZGVwdGggPSAodGhpcy5hdjFDLnR3ZWx2ZV9iaXQgPT09IDEpID8gXCIxMlwiIDogXCIxMFwiO1xuXHR9IGVsc2UgaWYgKCB0aGlzLmF2MUMuc2VxX3Byb2ZpbGUgPD0gMiApIHtcblx0XHRiaXRkZXB0aCA9ICh0aGlzLmF2MUMuaGlnaF9iaXRkZXB0aCA9PT0gMSkgPyBcIjEwXCIgOiBcIjA4XCI7XG5cdH1cblx0Ly8gVE9ETyBuZWVkIHRvIHBhcnNlIHRoZSBTSCB0byBmaW5kIGNvbG9yIGNvbmZpZ1xuXHRyZXR1cm4gYmFzZUNvZGVjK1wiLlwiK3RoaXMuYXYxQy5zZXFfcHJvZmlsZStcIi5cIit0aGlzLmF2MUMuc2VxX2xldmVsX2lkeF8wKyh0aGlzLmF2MUMuc2VxX3RpZXJfMD9cIkhcIjpcIk1cIikrXCIuXCIrYml0ZGVwdGg7Ly8rXCIuXCIrdGhpcy5hdjFDLm1vbm9jaHJvbWUrXCIuXCIrdGhpcy5hdjFDLmNocm9tYV9zdWJzYW1wbGluZ194K1wiXCIrdGhpcy5hdjFDLmNocm9tYV9zdWJzYW1wbGluZ195K1wiXCIrdGhpcy5hdjFDLmNocm9tYV9zYW1wbGVfcG9zaXRpb247XG59O1xuXG5cbi8vIGZpbGU6c3JjL2JveC13cml0ZS5qc1xuLyogXG4gKiBDb3B5cmlnaHQgKGMpIFRlbGVjb20gUGFyaXNUZWNoL1RTSS9NTS9HUEFDIEN5cmlsIENvbmNvbGF0b1xuICogTGljZW5zZTogQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBmaWxlKVxuICovXG5Cb3hQYXJzZXIuQm94LnByb3RvdHlwZS53cml0ZUhlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSwgbXNnKSB7XG5cdHRoaXMuc2l6ZSArPSA4O1xuXHRpZiAodGhpcy5zaXplID4gTUFYX1NJWkUpIHtcblx0XHR0aGlzLnNpemUgKz0gODtcblx0fVxuXHRpZiAodGhpcy50eXBlID09PSBcInV1aWRcIikge1xuXHRcdHRoaXMuc2l6ZSArPSAxNjtcblx0fVxuXHRMb2cuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJXcml0aW5nIGJveCBcIit0aGlzLnR5cGUrXCIgb2Ygc2l6ZTogXCIrdGhpcy5zaXplK1wiIGF0IHBvc2l0aW9uIFwiK3N0cmVhbS5nZXRQb3NpdGlvbigpKyhtc2cgfHwgXCJcIikpO1xuXHRpZiAodGhpcy5zaXplID4gTUFYX1NJWkUpIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIoMSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5zaXplUG9zaXRpb24gPSBzdHJlYW0uZ2V0UG9zaXRpb24oKTtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zaXplKTtcblx0fVxuXHRzdHJlYW0ud3JpdGVTdHJpbmcodGhpcy50eXBlLCBudWxsLCA0KTtcblx0aWYgKHRoaXMudHlwZSA9PT0gXCJ1dWlkXCIpIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50OEFycmF5KHRoaXMudXVpZCk7XG5cdH1cblx0aWYgKHRoaXMuc2l6ZSA+IE1BWF9TSVpFKSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDY0KHRoaXMuc2l6ZSk7XG5cdH0gXG59O1xuXG5Cb3hQYXJzZXIuRnVsbEJveC5wcm90b3R5cGUud3JpdGVIZWFkZXIgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zaXplICs9IDQ7XG5cdEJveFBhcnNlci5Cb3gucHJvdG90eXBlLndyaXRlSGVhZGVyLmNhbGwodGhpcywgc3RyZWFtLCBcIiB2PVwiK3RoaXMudmVyc2lvbitcIiBmPVwiK3RoaXMuZmxhZ3MpO1xuXHRzdHJlYW0ud3JpdGVVaW50OCh0aGlzLnZlcnNpb24pO1xuXHRzdHJlYW0ud3JpdGVVaW50MjQodGhpcy5mbGFncyk7XG59O1xuXG5Cb3hQYXJzZXIuQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRpZiAodGhpcy50eXBlID09PSBcIm1kYXRcIikge1xuXHRcdC8qIFRPRE86IGZpeCB0aGlzICovXG5cdFx0aWYgKHRoaXMuZGF0YSkge1xuXHRcdFx0dGhpcy5zaXplID0gdGhpcy5kYXRhLmxlbmd0aDtcblx0XHRcdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0XHRcdHN0cmVhbS53cml0ZVVpbnQ4QXJyYXkodGhpcy5kYXRhKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5zaXplID0gKHRoaXMuZGF0YSA/IHRoaXMuZGF0YS5sZW5ndGggOiAwKTtcblx0XHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdFx0aWYgKHRoaXMuZGF0YSkge1xuXHRcdFx0c3RyZWFtLndyaXRlVWludDhBcnJheSh0aGlzLmRhdGEpO1xuXHRcdH1cblx0fVxufTtcblxuQm94UGFyc2VyLkNvbnRhaW5lckJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy5zaXplID0gMDtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRmb3IgKHZhciBpPTA7IGk8dGhpcy5ib3hlcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLmJveGVzW2ldKSB7XG5cdFx0XHR0aGlzLmJveGVzW2ldLndyaXRlKHN0cmVhbSk7XG5cdFx0XHR0aGlzLnNpemUgKz0gdGhpcy5ib3hlc1tpXS5zaXplO1xuXHRcdH1cblx0fVxuXHQvKiBhZGp1c3RpbmcgdGhlIHNpemUsIG5vdyB0aGF0IGFsbCBzdWItYm94ZXMgYXJlIGtub3duICovXG5cdExvZy5kZWJ1ZyhcIkJveFdyaXRlclwiLCBcIkFkanVzdGluZyBib3ggXCIrdGhpcy50eXBlK1wiIHdpdGggbmV3IHNpemUgXCIrdGhpcy5zaXplKTtcblx0c3RyZWFtLmFkanVzdFVpbnQzMih0aGlzLnNpemVQb3NpdGlvbiwgdGhpcy5zaXplKTtcbn07XG5cbkJveFBhcnNlci5UcmFja1JlZmVyZW5jZVR5cGVCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuc2l6ZSA9IHRoaXMudHJhY2tfaWRzLmxlbmd0aCo0O1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMkFycmF5KHRoaXMudHJhY2tfaWRzKTtcbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvYXZjQy5qc1xuQm94UGFyc2VyLmF2Y0NCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR0aGlzLnNpemUgPSA3O1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5TUFMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLnNpemUgKz0gMit0aGlzLlNQU1tpXS5sZW5ndGg7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuUFBTLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5zaXplICs9IDIrdGhpcy5QUFNbaV0ubGVuZ3RoO1xuXHR9XG5cdGlmICh0aGlzLmV4dCkge1xuXHRcdHRoaXMuc2l6ZSArPSB0aGlzLmV4dC5sZW5ndGg7XG5cdH1cblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50OCh0aGlzLmNvbmZpZ3VyYXRpb25WZXJzaW9uKTtcblx0c3RyZWFtLndyaXRlVWludDgodGhpcy5BVkNQcm9maWxlSW5kaWNhdGlvbik7XG5cdHN0cmVhbS53cml0ZVVpbnQ4KHRoaXMucHJvZmlsZV9jb21wYXRpYmlsaXR5KTtcblx0c3RyZWFtLndyaXRlVWludDgodGhpcy5BVkNMZXZlbEluZGljYXRpb24pO1xuXHRzdHJlYW0ud3JpdGVVaW50OCh0aGlzLmxlbmd0aFNpemVNaW51c09uZSArICg2Mzw8MikpO1xuXHRzdHJlYW0ud3JpdGVVaW50OCh0aGlzLlNQUy5sZW5ndGggKyAoNzw8NSkpO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5TUFMubGVuZ3RoOyBpKyspIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MTYodGhpcy5TUFNbaV0ubGVuZ3RoKTtcblx0XHRzdHJlYW0ud3JpdGVVaW50OEFycmF5KHRoaXMuU1BTW2ldLm5hbHUpO1xuXHR9XG5cdHN0cmVhbS53cml0ZVVpbnQ4KHRoaXMuUFBTLmxlbmd0aCk7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLlBQUy5sZW5ndGg7IGkrKykge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLlBQU1tpXS5sZW5ndGgpO1xuXHRcdHN0cmVhbS53cml0ZVVpbnQ4QXJyYXkodGhpcy5QUFNbaV0ubmFsdSk7XG5cdH1cblx0aWYgKHRoaXMuZXh0KSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDhBcnJheSh0aGlzLmV4dCk7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvY282NC5qc1xuQm94UGFyc2VyLmNvNjRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNCs4KnRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGgpO1xuXHRmb3IoaT0wOyBpPHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQ2NCh0aGlzLmNodW5rX29mZnNldHNbaV0pO1xuXHR9XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL2NzbGcuanNcbkJveFBhcnNlci5jc2xnQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNCo1O1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZUludDMyKHRoaXMuY29tcG9zaXRpb25Ub0RUU1NoaWZ0KTtcblx0c3RyZWFtLndyaXRlSW50MzIodGhpcy5sZWFzdERlY29kZVRvRGlzcGxheURlbHRhKTtcblx0c3RyZWFtLndyaXRlSW50MzIodGhpcy5ncmVhdGVzdERlY29kZVRvRGlzcGxheURlbHRhKTtcblx0c3RyZWFtLndyaXRlSW50MzIodGhpcy5jb21wb3NpdGlvblN0YXJ0VGltZSk7XG5cdHN0cmVhbS53cml0ZUludDMyKHRoaXMuY29tcG9zaXRpb25FbmRUaW1lKTtcbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvY3R0cy5qc1xuQm94UGFyc2VyLmN0dHNCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNCs4KnRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGgpO1xuXHRmb3IoaT0wOyBpPHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9jb3VudHNbaV0pO1xuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHRcdHN0cmVhbS53cml0ZUludDMyKHRoaXMuc2FtcGxlX29mZnNldHNbaV0pOyAvKiBzaWduZWQgKi9cblx0XHR9IGVsc2Uge1x0XHRcdFxuXHRcdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX29mZnNldHNbaV0pOyAvKiB1bnNpZ25lZCAqL1xuXHRcdH1cblx0fVxufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9kcmVmLmpzXG5Cb3hQYXJzZXIuZHJlZkJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy52ZXJzaW9uID0gMDtcblx0dGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQ7IC8vXG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuZW50cmllcy5sZW5ndGgpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuZW50cmllc1tpXS53cml0ZShzdHJlYW0pO1xuXHRcdHRoaXMuc2l6ZSArPSB0aGlzLmVudHJpZXNbaV0uc2l6ZTtcblx0fVx0XG5cdC8qIGFkanVzdGluZyB0aGUgc2l6ZSwgbm93IHRoYXQgYWxsIHN1Yi1ib3hlcyBhcmUga25vd24gKi9cblx0TG9nLmRlYnVnKFwiQm94V3JpdGVyXCIsIFwiQWRqdXN0aW5nIGJveCBcIit0aGlzLnR5cGUrXCIgd2l0aCBuZXcgc2l6ZSBcIit0aGlzLnNpemUpO1xuXHRzdHJlYW0uYWRqdXN0VWludDMyKHRoaXMuc2l6ZVBvc2l0aW9uLCB0aGlzLnNpemUpO1xufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9lbG5nLmpzXG5Cb3hQYXJzZXIuZWxuZ0JveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy52ZXJzaW9uID0gMDtcdFxuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gdGhpcy5leHRlbmRlZF9sYW5ndWFnZS5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlU3RyaW5nKHRoaXMuZXh0ZW5kZWRfbGFuZ3VhZ2UpO1xufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9lbHN0LmpzXG5Cb3hQYXJzZXIuZWxzdEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy52ZXJzaW9uID0gMDtcdFxuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNCsxMip0aGlzLmVudHJpZXMubGVuZ3RoO1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKGVudHJ5LnNlZ21lbnRfZHVyYXRpb24pO1xuXHRcdHN0cmVhbS53cml0ZUludDMyKGVudHJ5Lm1lZGlhX3RpbWUpO1xuXHRcdHN0cmVhbS53cml0ZUludDE2KGVudHJ5Lm1lZGlhX3JhdGVfaW50ZWdlcik7XG5cdFx0c3RyZWFtLndyaXRlSW50MTYoZW50cnkubWVkaWFfcmF0ZV9mcmFjdGlvbik7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvZW1zZy5qc1xuQm94UGFyc2VyLmVtc2dCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XHRcblx0dGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQqNCt0aGlzLm1lc3NhZ2VfZGF0YS5sZW5ndGgrKHRoaXMuc2NoZW1lX2lkX3VyaS5sZW5ndGgrMSkrKHRoaXMudmFsdWUubGVuZ3RoKzEpO1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZUNTdHJpbmcodGhpcy5zY2hlbWVfaWRfdXJpKTtcblx0c3RyZWFtLndyaXRlQ1N0cmluZyh0aGlzLnZhbHVlKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMudGltZXNjYWxlKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMucHJlc2VudGF0aW9uX3RpbWVfZGVsdGEpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5ldmVudF9kdXJhdGlvbik7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmlkKTtcblx0c3RyZWFtLndyaXRlVWludDhBcnJheSh0aGlzLm1lc3NhZ2VfZGF0YSk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL2Z0eXAuanNcbkJveFBhcnNlci5mdHlwQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnNpemUgPSA4KzQqdGhpcy5jb21wYXRpYmxlX2JyYW5kcy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlU3RyaW5nKHRoaXMubWFqb3JfYnJhbmQsIG51bGwsIDQpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5taW5vcl92ZXJzaW9uKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBhdGlibGVfYnJhbmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0c3RyZWFtLndyaXRlU3RyaW5nKHRoaXMuY29tcGF0aWJsZV9icmFuZHNbaV0sIG51bGwsIDQpO1xuXHR9XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL2hkbHIuanNcbkJveFBhcnNlci5oZGxyQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnNpemUgPSA1KjQrdGhpcy5uYW1lLmxlbmd0aCsxO1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVN0cmluZyh0aGlzLmhhbmRsZXIsIG51bGwsIDQpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMigwKTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVDU3RyaW5nKHRoaXMubmFtZSk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL2tpbmQuanNcbkJveFBhcnNlci5raW5kQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAwO1x0XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSAodGhpcy5zY2hlbWVVUkkubGVuZ3RoKzEpKyh0aGlzLnZhbHVlLmxlbmd0aCsxKTtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVDU3RyaW5nKHRoaXMuc2NoZW1lVVJJKTtcblx0c3RyZWFtLndyaXRlQ1N0cmluZyh0aGlzLnZhbHVlKTtcbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvbWRoZC5qc1xuQm94UGFyc2VyLm1kaGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuc2l6ZSA9IDQqNCsyKjI7XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmNyZWF0aW9uX3RpbWUpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5tb2RpZmljYXRpb25fdGltZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnRpbWVzY2FsZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmR1cmF0aW9uKTtcblx0c3RyZWFtLndyaXRlVWludDE2KHRoaXMubGFuZ3VhZ2UpO1xuXHRzdHJlYW0ud3JpdGVVaW50MTYoMCk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL21laGQuanNcbkJveFBhcnNlci5tZWhkQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNDtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5mcmFnbWVudF9kdXJhdGlvbik7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL21maGQuanNcbkJveFBhcnNlci5tZmhkQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNDtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zZXF1ZW5jZV9udW1iZXIpO1xufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9tdmhkLmpzXG5Cb3hQYXJzZXIubXZoZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy52ZXJzaW9uID0gMDtcblx0dGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDIzKjQrMioyO1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmNyZWF0aW9uX3RpbWUpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5tb2RpZmljYXRpb25fdGltZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnRpbWVzY2FsZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmR1cmF0aW9uKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMucmF0ZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLnZvbHVtZTw8OCk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNigwKTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMkFycmF5KHRoaXMubWF0cml4KTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMigwKTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMigwKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMubmV4dF90cmFja19pZCk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3NhbXBsZWVudHJ5LmpzXG5Cb3hQYXJzZXIuU2FtcGxlRW50cnkucHJvdG90eXBlLndyaXRlSGVhZGVyID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMuc2l6ZSA9IDg7XG5cdEJveFBhcnNlci5Cb3gucHJvdG90eXBlLndyaXRlSGVhZGVyLmNhbGwodGhpcywgc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDgoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQ4KDApO1xuXHRzdHJlYW0ud3JpdGVVaW50OCgwKTtcblx0c3RyZWFtLndyaXRlVWludDgoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQ4KDApO1xuXHRzdHJlYW0ud3JpdGVVaW50OCgwKTtcblx0c3RyZWFtLndyaXRlVWludDE2KHRoaXMuZGF0YV9yZWZlcmVuY2VfaW5kZXgpO1xufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZUZvb3RlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRmb3IgKHZhciBpPTA7IGk8dGhpcy5ib3hlcy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuYm94ZXNbaV0ud3JpdGUoc3RyZWFtKTtcblx0XHR0aGlzLnNpemUgKz0gdGhpcy5ib3hlc1tpXS5zaXplO1xuXHR9XG5cdExvZy5kZWJ1ZyhcIkJveFdyaXRlclwiLCBcIkFkanVzdGluZyBib3ggXCIrdGhpcy50eXBlK1wiIHdpdGggbmV3IHNpemUgXCIrdGhpcy5zaXplKTtcblx0c3RyZWFtLmFkanVzdFVpbnQzMih0aGlzLnNpemVQb3NpdGlvbiwgdGhpcy5zaXplKTtcdFxufTtcblxuQm94UGFyc2VyLlNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQ4QXJyYXkodGhpcy5kYXRhKTtcblx0dGhpcy5zaXplICs9IHRoaXMuZGF0YS5sZW5ndGg7XG5cdExvZy5kZWJ1ZyhcIkJveFdyaXRlclwiLCBcIkFkanVzdGluZyBib3ggXCIrdGhpcy50eXBlK1wiIHdpdGggbmV3IHNpemUgXCIrdGhpcy5zaXplKTtcblx0c3RyZWFtLmFkanVzdFVpbnQzMih0aGlzLnNpemVQb3NpdGlvbiwgdGhpcy5zaXplKTtcdFxufTtcblxuQm94UGFyc2VyLlZpc3VhbFNhbXBsZUVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHRoaXMuc2l6ZSArPSAyKjcrNio0KzMyO1xuXHRzdHJlYW0ud3JpdGVVaW50MTYoMCk7IFxuXHRzdHJlYW0ud3JpdGVVaW50MTYoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMigwKTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLndpZHRoKTtcblx0c3RyZWFtLndyaXRlVWludDE2KHRoaXMuaGVpZ2h0KTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuaG9yaXpyZXNvbHV0aW9uKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMudmVydHJlc29sdXRpb24pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLmZyYW1lX2NvdW50KTtcblx0c3RyZWFtLndyaXRlVWludDgoTWF0aC5taW4oMzEsIHRoaXMuY29tcHJlc3Nvcm5hbWUubGVuZ3RoKSk7XG5cdHN0cmVhbS53cml0ZVN0cmluZyh0aGlzLmNvbXByZXNzb3JuYW1lLCBudWxsLCAzMSk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLmRlcHRoKTtcblx0c3RyZWFtLndyaXRlSW50MTYoLTEpO1xuXHR0aGlzLndyaXRlRm9vdGVyKHN0cmVhbSk7XG59O1xuXG5Cb3hQYXJzZXIuQXVkaW9TYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHR0aGlzLnNpemUgKz0gMio0KzMqNDtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLmNoYW5uZWxfY291bnQpO1xuXHRzdHJlYW0ud3JpdGVVaW50MTYodGhpcy5zYW1wbGVzaXplKTtcblx0c3RyZWFtLndyaXRlVWludDE2KDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MTYoMCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnNhbXBsZXJhdGU8PDE2KTtcblx0dGhpcy53cml0ZUZvb3RlcihzdHJlYW0pO1xufTtcblxuQm94UGFyc2VyLnN0cHBTYW1wbGVFbnRyeS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHR0aGlzLnNpemUgKz0gdGhpcy5uYW1lc3BhY2UubGVuZ3RoKzErXG5cdFx0XHRcdCB0aGlzLnNjaGVtYV9sb2NhdGlvbi5sZW5ndGgrMStcblx0XHRcdFx0IHRoaXMuYXV4aWxpYXJ5X21pbWVfdHlwZXMubGVuZ3RoKzE7XG5cdHN0cmVhbS53cml0ZUNTdHJpbmcodGhpcy5uYW1lc3BhY2UpO1xuXHRzdHJlYW0ud3JpdGVDU3RyaW5nKHRoaXMuc2NoZW1hX2xvY2F0aW9uKTtcblx0c3RyZWFtLndyaXRlQ1N0cmluZyh0aGlzLmF1eGlsaWFyeV9taW1lX3R5cGVzKTtcblx0dGhpcy53cml0ZUZvb3RlcihzdHJlYW0pO1xufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9zYW1wbGVncm91cHMvc2FtcGxlZ3JvdXAuanNcbkJveFBhcnNlci5TYW1wbGVHcm91cEVudHJ5LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRzdHJlYW0ud3JpdGVVaW50OEFycmF5KHRoaXMuZGF0YSk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3NiZ3AuanNcbkJveFBhcnNlci5zYmdwQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAxO1x0XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSAxMis4KnRoaXMuZW50cmllcy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlU3RyaW5nKHRoaXMuZ3JvdXBpbmdfdHlwZSwgbnVsbCwgNCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuZW50cmllcy5sZW5ndGgpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcblx0XHRzdHJlYW0ud3JpdGVJbnQzMihlbnRyeS5zYW1wbGVfY291bnQpO1xuXHRcdHN0cmVhbS53cml0ZUludDMyKGVudHJ5Lmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4KTtcblx0fVxufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9zZ3BkLmpzXG5Cb3hQYXJzZXIuc2dwZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHZhciBlbnRyeTtcblx0Ly8gbGVhdmUgdmVyc2lvbiBhcyByZWFkXG5cdC8vIHRoaXMudmVyc2lvbjtcblx0dGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDEyO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XG5cdFx0aWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuXHRcdFx0aWYgKHRoaXMuZGVmYXVsdF9sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dGhpcy5zaXplICs9IDQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNpemUgKz0gZW50cnkuZGF0YS5sZW5ndGg7XG5cdFx0fVxuXHR9XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlU3RyaW5nKHRoaXMuZ3JvdXBpbmdfdHlwZSwgbnVsbCwgNCk7XG5cdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5kZWZhdWx0X2xlbmd0aCk7XG5cdH1cblx0aWYgKHRoaXMudmVyc2lvbiA+PSAyKSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgpO1xuXHR9XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKTtcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xuXHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcblx0XHRcdGlmICh0aGlzLmRlZmF1bHRfbGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHN0cmVhbS53cml0ZVVpbnQzMihlbnRyeS5kZXNjcmlwdGlvbl9sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbnRyeS53cml0ZShzdHJlYW0pO1xuXHR9XG59O1xuXG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvc2lkeC5qc1xuQm94UGFyc2VyLnNpZHhCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XHRcblx0dGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQqNCsyKzIrMTIqdGhpcy5yZWZlcmVuY2VzLmxlbmd0aDtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5yZWZlcmVuY2VfSUQpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy50aW1lc2NhbGUpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5lYXJsaWVzdF9wcmVzZW50YXRpb25fdGltZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmZpcnN0X29mZnNldCk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNigwKTtcblx0c3RyZWFtLndyaXRlVWludDE2KHRoaXMucmVmZXJlbmNlcy5sZW5ndGgpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciByZWYgPSB0aGlzLnJlZmVyZW5jZXNbaV07XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHJlZi5yZWZlcmVuY2VfdHlwZSA8PCAzMSB8IHJlZi5yZWZlcmVuY2VkX3NpemUpO1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMihyZWYuc3Vic2VnbWVudF9kdXJhdGlvbik7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHJlZi5zdGFydHNfd2l0aF9TQVAgPDwgMzEgfCByZWYuU0FQX3R5cGUgPDwgMjggfCByZWYuU0FQX2RlbHRhX3RpbWUpO1xuXHR9XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3N0Y28uanNcbkJveFBhcnNlci5zdGNvQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNCs0KnRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuY2h1bmtfb2Zmc2V0cy5sZW5ndGgpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzJBcnJheSh0aGlzLmNodW5rX29mZnNldHMpO1xufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9zdHNjLmpzXG5Cb3hQYXJzZXIuc3RzY0JveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSA0KzEyKnRoaXMuZmlyc3RfY2h1bmsubGVuZ3RoO1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmZpcnN0X2NodW5rLmxlbmd0aCk7XG5cdGZvcihpPTA7IGk8dGhpcy5maXJzdF9jaHVuay5sZW5ndGg7IGkrKykge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmZpcnN0X2NodW5rW2ldKTtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zYW1wbGVzX3Blcl9jaHVua1tpXSk7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4W2ldKTtcblx0fVxufTtcblxuLy8gZmlsZTpzcmMvd3JpdGluZy9zdHNkLmpzXG5Cb3hQYXJzZXIuc3RzZEJveC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dmFyIGk7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSAwO1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmVudHJpZXMubGVuZ3RoKTtcblx0dGhpcy5zaXplICs9IDQ7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLmVudHJpZXNbaV0ud3JpdGUoc3RyZWFtKTtcblx0XHR0aGlzLnNpemUgKz0gdGhpcy5lbnRyaWVzW2ldLnNpemU7XG5cdH1cblx0LyogYWRqdXN0aW5nIHRoZSBzaXplLCBub3cgdGhhdCBhbGwgc3ViLWJveGVzIGFyZSBrbm93biAqL1xuXHRMb2cuZGVidWcoXCJCb3hXcml0ZXJcIiwgXCJBZGp1c3RpbmcgYm94IFwiK3RoaXMudHlwZStcIiB3aXRoIG5ldyBzaXplIFwiK3RoaXMuc2l6ZSk7XG5cdHN0cmVhbS5hZGp1c3RVaW50MzIodGhpcy5zaXplUG9zaXRpb24sIHRoaXMuc2l6ZSk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3N0c2guanNcbkJveFBhcnNlci5zdHNoQm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgaTtcblx0dGhpcy52ZXJzaW9uID0gMDtcblx0dGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQrOCp0aGlzLnNoYWRvd2VkX3NhbXBsZV9udW1iZXJzLmxlbmd0aDtcblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVycy5sZW5ndGgpO1xuXHRmb3IoaT0wOyBpPHRoaXMuc2hhZG93ZWRfc2FtcGxlX251bWJlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zaGFkb3dlZF9zYW1wbGVfbnVtYmVyc1tpXSk7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc3luY19zYW1wbGVfbnVtYmVyc1tpXSk7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvc3Rzcy5qc1xuQm94UGFyc2VyLnN0c3NCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSA0KzQqdGhpcy5zYW1wbGVfbnVtYmVycy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX251bWJlcnMubGVuZ3RoKTtcblx0c3RyZWFtLndyaXRlVWludDMyQXJyYXkodGhpcy5zYW1wbGVfbnVtYmVycyk7XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3N0c3ouanNcbkJveFBhcnNlci5zdHN6Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgaTtcblx0dmFyIGNvbnN0YW50ID0gdHJ1ZTtcblx0dGhpcy52ZXJzaW9uID0gMDtcblx0dGhpcy5mbGFncyA9IDA7XG5cdGlmICh0aGlzLnNhbXBsZV9zaXplcy5sZW5ndGggPiAwKSB7XG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKGkrMSA8IHRoaXMuc2FtcGxlX3NpemVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMuc2FtcGxlX3NpemVzW2krMV0gIT09ICB0aGlzLnNhbXBsZV9zaXplc1swXSkge1xuXHRcdFx0XHRjb25zdGFudCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3RhbnQgPSBmYWxzZTtcblx0fVxuXHR0aGlzLnNpemUgPSA4O1xuXHRpZiAoIWNvbnN0YW50KSB7XG5cdFx0dGhpcy5zaXplICs9IDQqdGhpcy5zYW1wbGVfc2l6ZXMubGVuZ3RoO1xuXHR9XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0aWYgKCFjb25zdGFudCkge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMigwKTtcblx0fSBlbHNlIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfc2l6ZXNbMF0pO1xuXHR9XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9zaXplcy5sZW5ndGgpO1xuXHRpZiAoIWNvbnN0YW50KSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyQXJyYXkodGhpcy5zYW1wbGVfc2l6ZXMpO1xuXHR9XHRcbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvc3R0cy5qc1xuQm94UGFyc2VyLnN0dHNCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHZhciBpO1xuXHR0aGlzLnZlcnNpb24gPSAwO1xuXHR0aGlzLmZsYWdzID0gMDtcblx0dGhpcy5zaXplID0gNCs4KnRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGgpO1xuXHRmb3IoaT0wOyBpPHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9jb3VudHNbaV0pO1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9kZWx0YXNbaV0pO1xuXHR9XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3RmZHQuanNcbkJveFBhcnNlci50ZmR0Qm94LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR2YXIgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cdC8vIHVzZSB2ZXJzaW9uIDEgaWYgYmFzZU1lZGlhRGVjb2RlVGltZSBkb2VzIG5vdCBmaXQgMzIgYml0c1xuXHR0aGlzLnZlcnNpb24gPSB0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUgPiBVSU5UMzJfTUFYID8gMSA6IDA7XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSA0O1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG5cdFx0dGhpcy5zaXplICs9IDQ7XG5cdH1cblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDY0KHRoaXMuYmFzZU1lZGlhRGVjb2RlVGltZSk7XG5cdH0gZWxzZSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuYmFzZU1lZGlhRGVjb2RlVGltZSk7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvdGZoZC5qc1xuQm94UGFyc2VyLnRmaGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQ7XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19CQVNFX0RBVEFfT0ZGU0VUKSB7XG5cdFx0dGhpcy5zaXplICs9IDg7XG5cdH1cblx0aWYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9ERVNDKSB7XG5cdFx0dGhpcy5zaXplICs9IDQ7XG5cdH1cblx0aWYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9EVVIpIHtcblx0XHR0aGlzLnNpemUgKz0gNDtcblx0fVxuXHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5URkhEX0ZMQUdfU0FNUExFX1NJWkUpIHtcblx0XHR0aGlzLnNpemUgKz0gNDtcblx0fVxuXHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5URkhEX0ZMQUdfU0FNUExFX0ZMQUdTKSB7XG5cdFx0dGhpcy5zaXplICs9IDQ7XG5cdH1cblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy50cmFja19pZCk7XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19CQVNFX0RBVEFfT0ZGU0VUKSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDY0KHRoaXMuYmFzZV9kYXRhX29mZnNldCk7XG5cdH1cblx0aWYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9ERVNDKSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgpO1xuXHR9XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19TQU1QTEVfRFVSKSB7XG5cdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24pO1xuXHR9XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19TQU1QTEVfU0laRSkge1xuXHRcdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX3NpemUpO1xuXHR9XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19TQU1QTEVfRkxBR1MpIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5kZWZhdWx0X3NhbXBsZV9mbGFncyk7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvdGtoZC5qc1xuQm94UGFyc2VyLnRraGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdC8vdGhpcy5mbGFncyA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQqMTgrMio0O1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmNyZWF0aW9uX3RpbWUpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5tb2RpZmljYXRpb25fdGltZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnRyYWNrX2lkKTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5kdXJhdGlvbik7XG5cdHN0cmVhbS53cml0ZVVpbnQzMigwKTtcblx0c3RyZWFtLndyaXRlVWludDMyKDApO1xuXHRzdHJlYW0ud3JpdGVJbnQxNih0aGlzLmxheWVyKTtcblx0c3RyZWFtLndyaXRlSW50MTYodGhpcy5hbHRlcm5hdGVfZ3JvdXApO1xuXHRzdHJlYW0ud3JpdGVJbnQxNih0aGlzLnZvbHVtZTw8OCk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNigwKTtcblx0c3RyZWFtLndyaXRlSW50MzJBcnJheSh0aGlzLm1hdHJpeCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLndpZHRoKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvdHJleC5qc1xuQm94UGFyc2VyLnRyZXhCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSA0KjU7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMudHJhY2tfaWQpO1xuXHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5kZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuZGVmYXVsdF9zYW1wbGVfc2l6ZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLmRlZmF1bHRfc2FtcGxlX2ZsYWdzKTtcbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvdHJ1bi5qc1xuQm94UGFyc2VyLnRydW5Cb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuc2l6ZSA9IDQ7XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQpIHtcblx0XHR0aGlzLnNpemUgKz0gNDtcblx0fVxuXHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcpIHtcblx0XHR0aGlzLnNpemUgKz0gNDtcblx0fVxuXHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0RVUkFUSU9OKSB7XG5cdFx0dGhpcy5zaXplICs9IDQqdGhpcy5zYW1wbGVfZHVyYXRpb24ubGVuZ3RoO1xuXHR9XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfU0laRSkge1xuXHRcdHRoaXMuc2l6ZSArPSA0KnRoaXMuc2FtcGxlX3NpemUubGVuZ3RoO1xuXHR9XG5cdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfRkxBR1MpIHtcblx0XHR0aGlzLnNpemUgKz0gNCp0aGlzLnNhbXBsZV9mbGFncy5sZW5ndGg7XG5cdH1cblx0aWYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVFJVTl9GTEFHU19DVFNfT0ZGU0VUKSB7XG5cdFx0dGhpcy5zaXplICs9IDQqdGhpcy5zYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXQubGVuZ3RoO1xuXHR9XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvdW50KTtcblx0aWYgKHRoaXMuZmxhZ3MgJiBCb3hQYXJzZXIuVFJVTl9GTEFHU19EQVRBX09GRlNFVCkge1xuXHRcdHRoaXMuZGF0YV9vZmZzZXRfcG9zaXRpb24gPSBzdHJlYW0uZ2V0UG9zaXRpb24oKTtcblx0XHRzdHJlYW0ud3JpdGVJbnQzMih0aGlzLmRhdGFfb2Zmc2V0KTsgLy9zaWduZWRcblx0fVxuXHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0ZJUlNUX0ZMQUcpIHtcblx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5maXJzdF9zYW1wbGVfZmxhZ3MpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGVfY291bnQ7IGkrKykge1xuXHRcdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfRFVSQVRJT04pIHtcblx0XHRcdHN0cmVhbS53cml0ZVVpbnQzMih0aGlzLnNhbXBsZV9kdXJhdGlvbltpXSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfU0laRSkge1xuXHRcdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX3NpemVbaV0pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0ZMQUdTKSB7XG5cdFx0XHRzdHJlYW0ud3JpdGVVaW50MzIodGhpcy5zYW1wbGVfZmxhZ3NbaV0pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0NUU19PRkZTRVQpIHtcblx0XHRcdGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcblx0XHRcdFx0c3RyZWFtLndyaXRlVWludDMyKHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cmVhbS53cml0ZUludDMyKHRoaXMuc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2ldKTsgLy9zaWduZWRcblx0XHRcdH1cblx0XHR9XG5cdH1cdFx0XG59O1xuXG4vLyBmaWxlOnNyYy93cml0aW5nL3VybC5qc1xuQm94UGFyc2VyW1widXJsIEJveFwiXS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0dGhpcy52ZXJzaW9uID0gMDtcdFxuXHRpZiAodGhpcy5sb2NhdGlvbikge1xuXHRcdHRoaXMuZmxhZ3MgPSAwO1xuXHRcdHRoaXMuc2l6ZSA9IHRoaXMubG9jYXRpb24ubGVuZ3RoKzE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5mbGFncyA9IDB4MDAwMDAxO1xuXHRcdHRoaXMuc2l6ZSA9IDA7XG5cdH1cblx0dGhpcy53cml0ZUhlYWRlcihzdHJlYW0pO1xuXHRpZiAodGhpcy5sb2NhdGlvbikge1xuXHRcdHN0cmVhbS53cml0ZUNTdHJpbmcodGhpcy5sb2NhdGlvbik7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvdXJuLmpzXG5Cb3hQYXJzZXJbXCJ1cm4gQm94XCJdLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHR0aGlzLnZlcnNpb24gPSAwO1x0XG5cdHRoaXMuZmxhZ3MgPSAwO1xuXHR0aGlzLnNpemUgPSB0aGlzLm5hbWUubGVuZ3RoKzErKHRoaXMubG9jYXRpb24gPyB0aGlzLmxvY2F0aW9uLmxlbmd0aCsxIDogMCk7XG5cdHRoaXMud3JpdGVIZWFkZXIoc3RyZWFtKTtcblx0c3RyZWFtLndyaXRlQ1N0cmluZyh0aGlzLm5hbWUpO1xuXHRpZiAodGhpcy5sb2NhdGlvbikge1xuXHRcdHN0cmVhbS53cml0ZUNTdHJpbmcodGhpcy5sb2NhdGlvbik7XG5cdH1cbn07XG5cbi8vIGZpbGU6c3JjL3dyaXRpbmcvdm1oZC5qc1xuQm94UGFyc2VyLnZtaGRCb3gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cdHRoaXMuZmxhZ3MgPSAxO1xuXHR0aGlzLnNpemUgPSA4O1xuXHR0aGlzLndyaXRlSGVhZGVyKHN0cmVhbSk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNih0aGlzLmdyYXBoaWNzbW9kZSk7XG5cdHN0cmVhbS53cml0ZVVpbnQxNkFycmF5KHRoaXMub3Bjb2xvcik7XG59O1xuXG4vLyBmaWxlOnNyYy9ib3gtdW5wYWNrLmpzXG4vKiBcbiAqIENvcHlyaWdodCAoYykgVGVsZWNvbSBQYXJpc1RlY2gvVFNJL01NL0dQQUMgQ3lyaWwgQ29uY29sYXRvXG4gKiBMaWNlbnNlOiBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGZpbGUpXG4gKi9cbkJveFBhcnNlci5jdHRzQm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbihzYW1wbGVzKSB7XG5cdHZhciBpLCBqLCBrO1xuXHRrID0gMDtcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2FtcGxlX2NvdW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGZvciAoaiA9IDA7IGogPCB0aGlzLnNhbXBsZV9jb3VudHNbaV07IGorKykge1xuXHRcdFx0c2FtcGxlc1trXS5wdHMgPSBzYW1wbGVzW2tdLmR0cyArIHRoaXMuc2FtcGxlX29mZnNldHNbaV07XG5cdFx0XHRrKys7XG5cdFx0fVxuXHR9XG59O1xuXG5Cb3hQYXJzZXIuc3R0c0JveC5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24oc2FtcGxlcykge1xuXHR2YXIgaSwgaiwgaztcblx0ayA9IDA7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLnNhbXBsZV9jb3VudHMubGVuZ3RoOyBpKyspIHtcblx0XHRmb3IgKGogPSAwOyBqIDwgdGhpcy5zYW1wbGVfY291bnRzW2ldOyBqKyspIHtcblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHNhbXBsZXNba10uZHRzID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNhbXBsZXNba10uZHRzID0gc2FtcGxlc1trLTFdLmR0cyArIHRoaXMuc2FtcGxlX2RlbHRhc1tpXTtcblx0XHRcdH1cblx0XHRcdGsrKztcblx0XHR9XG5cdH1cbn07XG5cbkJveFBhcnNlci5zdGNvQm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbihzYW1wbGVzKSB7XG5cdHZhciBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaHVua19vZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0c2FtcGxlc1tpXS5vZmZzZXQgPSB0aGlzLmNodW5rX29mZnNldHNbaV07XG5cdH1cbn07XG5cbkJveFBhcnNlci5zdHNjQm94LnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbihzYW1wbGVzKSB7XG5cdHZhciBpLCBqLCBrLCBsLCBtO1xuXHRsID0gMDtcblx0bSA9IDA7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpcnN0X2NodW5rLmxlbmd0aDsgaSsrKSB7XG5cdFx0Zm9yIChqID0gMDsgaiA8IChpKzEgPCB0aGlzLmZpcnN0X2NodW5rLmxlbmd0aCA/IHRoaXMuZmlyc3RfY2h1bmtbaSsxXSA6IEluZmluaXR5KTsgaisrKSB7XG5cdFx0XHRtKys7XG5cdFx0XHRmb3IgKGsgPSAwOyBrIDwgdGhpcy5zYW1wbGVzX3Blcl9jaHVua1tpXTsgaysrKSB7XG5cdFx0XHRcdGlmIChzYW1wbGVzW2xdKSB7XG5cdFx0XHRcdFx0c2FtcGxlc1tsXS5kZXNjcmlwdGlvbl9pbmRleCA9IHRoaXMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4W2ldO1xuXHRcdFx0XHRcdHNhbXBsZXNbbF0uY2h1bmtfaW5kZXggPSBtO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsKys7XG5cdFx0XHR9XHRcdFx0XG5cdFx0fVxuXHR9XG59O1xuXG5Cb3hQYXJzZXIuc3RzekJveC5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24oc2FtcGxlcykge1xuXHR2YXIgaTtcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2FtcGxlX3NpemVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0c2FtcGxlc1tpXS5zaXplID0gdGhpcy5zYW1wbGVfc2l6ZXNbaV07XG5cdH1cbn07XG4vLyBmaWxlOnNyYy9ib3gtZGlmZi5qc1xuXG5Cb3hQYXJzZXIuRElGRl9CT1hFU19QUk9QX05BTUVTID0gWyBcImJveGVzXCIsIFwiZW50cmllc1wiLCBcInJlZmVyZW5jZXNcIiwgXCJzdWJzYW1wbGVzXCIsXG5cdFx0XHRcdFx0IFx0IFwiaXRlbXNcIiwgXCJpdGVtX2luZm9zXCIsIFwiZXh0ZW50c1wiLCBcImFzc29jaWF0aW9uc1wiLFxuXHRcdFx0XHRcdCBcdCBcInN1YnNlZ21lbnRzXCIsIFwicmFuZ2VzXCIsIFwic2Vla0xpc3RzXCIsIFwic2Vla1BvaW50c1wiLFxuXHRcdFx0XHRcdCBcdCBcImVzZFwiLCBcImxldmVsc1wiXTtcblxuQm94UGFyc2VyLkRJRkZfUFJJTUlUSVZFX0FSUkFZX1BST1BfTkFNRVMgPSBbIFwiY29tcGF0aWJsZV9icmFuZHNcIiwgXCJtYXRyaXhcIiwgXCJvcGNvbG9yXCIsIFwic2FtcGxlX2NvdW50c1wiLCBcInNhbXBsZV9jb3VudHNcIiwgXCJzYW1wbGVfZGVsdGFzXCIsXG5cImZpcnN0X2NodW5rXCIsIFwic2FtcGxlc19wZXJfY2h1bmtcIiwgXCJzYW1wbGVfc2l6ZXNcIiwgXCJjaHVua19vZmZzZXRzXCIsIFwic2FtcGxlX29mZnNldHNcIiwgXCJzYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgXCJzYW1wbGVfZHVyYXRpb25cIiBdO1xuXG5Cb3hQYXJzZXIuYm94RXF1YWxGaWVsZHMgPSBmdW5jdGlvbihib3hfYSwgYm94X2IpIHtcblx0aWYgKGJveF9hICYmICFib3hfYikgcmV0dXJuIGZhbHNlO1xuXHR2YXIgcHJvcDtcblx0Zm9yIChwcm9wIGluIGJveF9hKSB7XG5cdFx0aWYgKEJveFBhcnNlci5ESUZGX0JPWEVTX1BST1BfTkFNRVMuaW5kZXhPZihwcm9wKSA+IC0xKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHQvLyB9IGVsc2UgaWYgKGV4Y2x1ZGVkX2ZpZWxkcyAmJiBleGNsdWRlZF9maWVsZHMuaW5kZXhPZihwcm9wKSA+IC0xKSB7XG5cdFx0Ly8gXHRjb250aW51ZTtcblx0XHR9IGVsc2UgaWYgKGJveF9hW3Byb3BdIGluc3RhbmNlb2YgQm94UGFyc2VyLkJveCB8fCBib3hfYltwcm9wXSBpbnN0YW5jZW9mIEJveFBhcnNlci5Cb3gpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGJveF9hW3Byb3BdID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBib3hfYltwcm9wXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYm94X2FbcHJvcF0gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgYm94X2JbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdChib3hfYS5zdWJCb3hOYW1lcyAmJiBib3hfYS5zdWJCb3hOYW1lcy5pbmRleE9mKHByb3Auc2xpY2UoMCw0KSkgPiAtMSkgfHxcblx0XHRcdChib3hfYi5zdWJCb3hOYW1lcyAmJiBib3hfYi5zdWJCb3hOYW1lcy5pbmRleE9mKHByb3Auc2xpY2UoMCw0KSkgPiAtMSkpICB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHByb3AgPT09IFwiZGF0YVwiIHx8IHByb3AgPT09IFwic3RhcnRcIiB8fCBwcm9wID09PSBcInNpemVcIiB8fCBwcm9wID09PSBcImNyZWF0aW9uX3RpbWVcIiB8fCBwcm9wID09PSBcIm1vZGlmaWNhdGlvbl90aW1lXCIpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKEJveFBhcnNlci5ESUZGX1BSSU1JVElWRV9BUlJBWV9QUk9QX05BTUVTLmluZGV4T2YocHJvcCkgPiAtMSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChib3hfYVtwcm9wXSAhPT0gYm94X2JbcHJvcF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Cb3hQYXJzZXIuYm94RXF1YWwgPSBmdW5jdGlvbihib3hfYSwgYm94X2IpIHtcblx0aWYgKCFCb3hQYXJzZXIuYm94RXF1YWxGaWVsZHMoYm94X2EsIGJveF9iKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRmb3IgKHZhciBqID0gMDsgaiA8IEJveFBhcnNlci5ESUZGX0JPWEVTX1BST1BfTkFNRVMubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgbmFtZSA9IEJveFBhcnNlci5ESUZGX0JPWEVTX1BST1BfTkFNRVNbal07XG5cdFx0aWYgKGJveF9hW25hbWVdICYmIGJveF9iW25hbWVdKSB7XG5cdFx0XHRpZiAoIUJveFBhcnNlci5ib3hFcXVhbChib3hfYVtuYW1lXSwgYm94X2JbbmFtZV0pKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59Oy8vIGZpbGU6c3JjL3RleHQtbXA0LmpzXG5cbnZhciBYTUxTdWJ0aXRsZWluNFBhcnNlciA9IGZ1bmN0aW9uKCkge1x0XG59O1xuXG5YTUxTdWJ0aXRsZWluNFBhcnNlci5wcm90b3R5cGUucGFyc2VTYW1wbGUgPSBmdW5jdGlvbihzYW1wbGUpIHtcblx0dmFyIHJlcyA9IHt9O1x0XG5cdHZhciBpO1xuXHRyZXMucmVzb3VyY2VzID0gW107XG5cdHZhciBzdHJlYW0gPSBuZXcgTVA0Qm94U3RyZWFtKHNhbXBsZS5kYXRhLmJ1ZmZlcik7XG5cdGlmICghc2FtcGxlLnN1YnNhbXBsZXMgfHwgc2FtcGxlLnN1YnNhbXBsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmVzLmRvY3VtZW50U3RyaW5nID0gc3RyZWFtLnJlYWRTdHJpbmcoc2FtcGxlLmRhdGEubGVuZ3RoKTtcblx0fSBlbHNlIHtcblx0XHRyZXMuZG9jdW1lbnRTdHJpbmcgPSBzdHJlYW0ucmVhZFN0cmluZyhzYW1wbGUuc3Vic2FtcGxlc1swXS5zaXplKTtcblx0XHRpZiAoc2FtcGxlLnN1YnNhbXBsZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IHNhbXBsZS5zdWJzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5yZXNvdXJjZXNbaV0gPSBzdHJlYW0ucmVhZFVpbnQ4QXJyYXkoc2FtcGxlLnN1YnNhbXBsZXNbaV0uc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2YgKERPTVBhcnNlcikgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRyZXMuZG9jdW1lbnQgPSAobmV3IERPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcocmVzLmRvY3VtZW50U3RyaW5nLCBcImFwcGxpY2F0aW9uL3htbFwiKTtcblx0fVxuXHRyZXR1cm4gcmVzO1xufTtcblxudmFyIFRleHRpbjRQYXJzZXIgPSBmdW5jdGlvbigpIHtcdFxufTtcblxuVGV4dGluNFBhcnNlci5wcm90b3R5cGUucGFyc2VTYW1wbGUgPSBmdW5jdGlvbihzYW1wbGUpIHtcblx0dmFyIHRleHRTdHJpbmc7XG5cdHZhciBzdHJlYW0gPSBuZXcgTVA0Qm94U3RyZWFtKHNhbXBsZS5kYXRhLmJ1ZmZlcik7XG5cdHRleHRTdHJpbmcgPSBzdHJlYW0ucmVhZFN0cmluZyhzYW1wbGUuZGF0YS5sZW5ndGgpO1xuXHRyZXR1cm4gdGV4dFN0cmluZztcbn07XG5cblRleHRpbjRQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29uZmlnID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgdGV4dFN0cmluZztcblx0dmFyIHN0cmVhbSA9IG5ldyBNUDRCb3hTdHJlYW0oZGF0YS5idWZmZXIpO1xuXHRzdHJlYW0ucmVhZFVpbnQzMigpOyAvLyB2ZXJzaW9uICYgZmxhZ3Ncblx0dGV4dFN0cmluZyA9IHN0cmVhbS5yZWFkQ1N0cmluZygpO1xuXHRyZXR1cm4gdGV4dFN0cmluZztcbn07XG5cbntcblx0ZXhwb3J0cy5YTUxTdWJ0aXRsZWluNFBhcnNlciA9IFhNTFN1YnRpdGxlaW40UGFyc2VyO1xuXHRleHBvcnRzLlRleHRpbjRQYXJzZXIgPSBUZXh0aW40UGFyc2VyO1xufVxuLy8gZmlsZTpzcmMvaXNvZmlsZS5qc1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzLiBUZWxlY29tIFBhcmlzVGVjaC9UU0kvTU0vR1BBQyBDeXJpbCBDb25jb2xhdG9cbiAqIExpY2Vuc2U6IEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgZmlsZSlcbiAqL1xudmFyIElTT0ZpbGUgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG5cdC8qIE11dGlCdWZmZXJTdHJlYW0gb2JqZWN0IHVzZWQgdG8gcGFyc2UgYm94ZXMgKi9cblx0dGhpcy5zdHJlYW0gPSBzdHJlYW0gfHwgbmV3IE11bHRpQnVmZmVyU3RyZWFtKCk7XG5cdC8qIEFycmF5IG9mIGFsbCBib3hlcyAoaW4gb3JkZXIpIGZvdW5kIGluIHRoZSBmaWxlICovXG5cdHRoaXMuYm94ZXMgPSBbXTtcblx0LyogQXJyYXkgb2YgYWxsIG1kYXRzICovXG5cdHRoaXMubWRhdHMgPSBbXTtcblx0LyogQXJyYXkgb2YgYWxsIG1vb2ZzICovXG5cdHRoaXMubW9vZnMgPSBbXTtcblx0LyogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBmaWxlIGlzIGNvbXBhdGlibGUgd2l0aCBwcm9ncmVzc2l2ZSBwYXJzaW5nIChtb292IGZpcnN0KSAqL1xuXHR0aGlzLmlzUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcblx0LyogQm9vbGVhbiB1c2VkIHRvIGZpcmUgbW9vdiBzdGFydCBldmVudCBvbmx5IG9uY2UgKi9cblx0dGhpcy5tb292U3RhcnRGb3VuZCA9IGZhbHNlO1xuXHQvKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgbW9vdiBwYXJzaW5nIHN0YXJ0cyAqL1xuXHR0aGlzLm9uTW9vdlN0YXJ0ID0gbnVsbDtcblx0LyogQm9vbGVhbiBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjYWxsIHRvIG9uTW9vdlN0YXJ0LCB0byBhdm9pZCBkb3VibGUgY2FsbHMgKi9cblx0dGhpcy5tb292U3RhcnRTZW50ID0gZmFsc2U7XG5cdC8qIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBtb292IGlzIGVudGlyZWx5IHBhcnNlZCAqL1xuXHR0aGlzLm9uUmVhZHkgPSBudWxsO1xuXHQvKiBCb29sZWFuIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGNhbGwgdG8gb25SZWFkeSwgdG8gYXZvaWQgZG91YmxlIGNhbGxzICovXG5cdHRoaXMucmVhZHlTZW50ID0gZmFsc2U7XG5cdC8qIENhbGxiYWNrIHRvIGNhbGwgd2hlbiBzZWdtZW50cyBhcmUgcmVhZHkgKi9cblx0dGhpcy5vblNlZ21lbnQgPSBudWxsO1xuXHQvKiBDYWxsYmFjayB0byBjYWxsIHdoZW4gc2FtcGxlcyBhcmUgcmVhZHkgKi9cblx0dGhpcy5vblNhbXBsZXMgPSBudWxsO1xuXHQvKiBDYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHBhcnNpbmcgb3IgcHJvY2Vzc2luZyBvZiBzYW1wbGVzICovXG5cdHRoaXMub25FcnJvciA9IG51bGw7XG5cdC8qIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgbW9vdiBib3ggcnVuLWxlbmd0aCBlbmNvZGVkIHRhYmxlcyBvZiBzYW1wbGUgaW5mb3JtYXRpb24gaGF2ZSBiZWVuIHByb2Nlc3NlZCAqL1xuXHR0aGlzLnNhbXBsZUxpc3RCdWlsdCA9IGZhbHNlO1xuXHQvKiBBcnJheSBvZiBUcmFjayBvYmplY3RzIGZvciB3aGljaCBmcmFnbWVudGF0aW9uIG9mIHNhbXBsZXMgaXMgcmVxdWVzdGVkICovXG5cdHRoaXMuZnJhZ21lbnRlZFRyYWNrcyA9IFtdO1xuXHQvKiBBcnJheSBvZiBUcmFjayBvYmplY3RzIGZvciB3aGljaCBleHRyYWN0aW9uIG9mIHNhbXBsZXMgaXMgcmVxdWVzdGVkICovXG5cdHRoaXMuZXh0cmFjdGVkVHJhY2tzID0gW107XG5cdC8qIEJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IGZyYWdtZW50aW9uIGlzIHJlYWR5ICovXG5cdHRoaXMuaXNGcmFnbWVudGF0aW9uSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0LyogQm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgZnJhZ21lbnRlZCBoYXMgc3RhcnRlZCAqL1xuXHR0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkID0gZmFsc2U7XG5cdC8qIE51bWJlciBvZiB0aGUgbmV4dCAnbW9vZicgdG8gZ2VuZXJhdGUgd2hlbiBmcmFnbWVudGluZyAqL1xuXHR0aGlzLm5leHRNb29mTnVtYmVyID0gMDtcblx0LyogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBpbml0aWFsIGxpc3Qgb2YgaXRlbXMgaGFzIGJlZW4gcHJvZHVjZWQgKi9cblx0dGhpcy5pdGVtTGlzdEJ1aWx0ID0gZmFsc2U7XG5cdC8qIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBzaWR4IGJveCBpcyBlbnRpcmVseSBwYXJzZWQgKi9cblx0dGhpcy5vblNpZHggPSBudWxsO1xuXHQvKiBCb29sZWFuIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGNhbGwgdG8gb25TaWR4LCB0byBhdm9pZCBkb3VibGUgY2FsbHMgKi9cblx0dGhpcy5zaWR4U2VudCA9IGZhbHNlO1xufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuc2V0U2VnbWVudE9wdGlvbnMgPSBmdW5jdGlvbihpZCwgdXNlciwgb3B0aW9ucykge1xuXHR2YXIgdHJhayA9IHRoaXMuZ2V0VHJhY2tCeUlkKGlkKTtcblx0aWYgKHRyYWspIHtcblx0XHR2YXIgZnJhZ1RyYWNrID0ge307XG5cdFx0dGhpcy5mcmFnbWVudGVkVHJhY2tzLnB1c2goZnJhZ1RyYWNrKTtcblx0XHRmcmFnVHJhY2suaWQgPSBpZDtcblx0XHRmcmFnVHJhY2sudXNlciA9IHVzZXI7XG5cdFx0ZnJhZ1RyYWNrLnRyYWsgPSB0cmFrO1xuXHRcdHRyYWsubmV4dFNhbXBsZSA9IDA7XG5cdFx0ZnJhZ1RyYWNrLnNlZ21lbnRTdHJlYW0gPSBudWxsO1xuXHRcdGZyYWdUcmFjay5uYl9zYW1wbGVzID0gMTAwMDtcblx0XHRmcmFnVHJhY2sucmFwQWxpZ25lbWVudCA9IHRydWU7XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChvcHRpb25zLm5iU2FtcGxlcykgZnJhZ1RyYWNrLm5iX3NhbXBsZXMgPSBvcHRpb25zLm5iU2FtcGxlcztcblx0XHRcdGlmIChvcHRpb25zLnJhcEFsaWduZW1lbnQpIGZyYWdUcmFjay5yYXBBbGlnbmVtZW50ID0gb3B0aW9ucy5yYXBBbGlnbmVtZW50O1xuXHRcdH1cblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUudW5zZXRTZWdtZW50T3B0aW9ucyA9IGZ1bmN0aW9uKGlkKSB7XG5cdHZhciBpbmRleCA9IC0xO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBmcmFnVHJhY2sgPSB0aGlzLmZyYWdtZW50ZWRUcmFja3NbaV07XG5cdFx0aWYgKGZyYWdUcmFjay5pZCA9PSBpZCkge1xuXHRcdFx0aW5kZXggPSBpO1xuXHRcdH1cblx0fVxuXHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5zZXRFeHRyYWN0aW9uT3B0aW9ucyA9IGZ1bmN0aW9uKGlkLCB1c2VyLCBvcHRpb25zKSB7XG5cdHZhciB0cmFrID0gdGhpcy5nZXRUcmFja0J5SWQoaWQpO1xuXHRpZiAodHJhaykge1xuXHRcdHZhciBleHRyYWN0VHJhY2sgPSB7fTtcblx0XHR0aGlzLmV4dHJhY3RlZFRyYWNrcy5wdXNoKGV4dHJhY3RUcmFjayk7XG5cdFx0ZXh0cmFjdFRyYWNrLmlkID0gaWQ7XG5cdFx0ZXh0cmFjdFRyYWNrLnVzZXIgPSB1c2VyO1xuXHRcdGV4dHJhY3RUcmFjay50cmFrID0gdHJhaztcblx0XHR0cmFrLm5leHRTYW1wbGUgPSAwO1xuXHRcdGV4dHJhY3RUcmFjay5uYl9zYW1wbGVzID0gMTAwMDtcblx0XHRleHRyYWN0VHJhY2suc2FtcGxlcyA9IFtdO1xuXHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5uYlNhbXBsZXMpIGV4dHJhY3RUcmFjay5uYl9zYW1wbGVzID0gb3B0aW9ucy5uYlNhbXBsZXM7XG5cdFx0fVxuXHR9XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS51bnNldEV4dHJhY3Rpb25PcHRpb25zID0gZnVuY3Rpb24oaWQpIHtcblx0dmFyIGluZGV4ID0gLTE7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5leHRyYWN0ZWRUcmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZXh0cmFjdFRyYWNrID0gdGhpcy5leHRyYWN0ZWRUcmFja3NbaV07XG5cdFx0aWYgKGV4dHJhY3RUcmFjay5pZCA9PSBpZCkge1xuXHRcdFx0aW5kZXggPSBpO1xuXHRcdH1cblx0fVxuXHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdHRoaXMuZXh0cmFjdGVkVHJhY2tzLnNwbGljZShpbmRleCwgMSk7XG5cdH1cbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG5cdHZhciByZXQ7XG5cdHZhciBib3g7XG5cdHZhciBwYXJzZUJveEhlYWRlcnNPbmx5ID0gZmFsc2U7XG5cblx0aWYgKHRoaXMucmVzdG9yZVBhcnNlUG9zaXRpb24pXHR7XG5cdFx0aWYgKCF0aGlzLnJlc3RvcmVQYXJzZVBvc2l0aW9uKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHR3aGlsZSAodHJ1ZSkge1xuXG5cdFx0aWYgKHRoaXMuaGFzSW5jb21wbGV0ZU1kYXQgJiYgdGhpcy5oYXNJbmNvbXBsZXRlTWRhdCgpKSB7XG5cdFx0XHRpZiAodGhpcy5wcm9jZXNzSW5jb21wbGV0ZU1kYXQoKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuc2F2ZVBhcnNlUG9zaXRpb24pXHR7XG5cdFx0XHRcdHRoaXMuc2F2ZVBhcnNlUG9zaXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldCA9IEJveFBhcnNlci5wYXJzZU9uZUJveCh0aGlzLnN0cmVhbSwgcGFyc2VCb3hIZWFkZXJzT25seSk7XG5cdFx0XHRpZiAocmV0LmNvZGUgPT09IEJveFBhcnNlci5FUlJfTk9UX0VOT1VHSF9EQVRBKSB7XG5cdFx0XHRcdGlmICh0aGlzLnByb2Nlc3NJbmNvbXBsZXRlQm94KSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvY2Vzc0luY29tcGxldGVCb3gocmV0KSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYm94X3R5cGU7XG5cdFx0XHRcdC8qIHRoZSBib3ggaXMgZW50aXJlbHkgcGFyc2VkICovXG5cdFx0XHRcdGJveCA9IHJldC5ib3g7XG5cdFx0XHRcdGJveF90eXBlID0gKGJveC50eXBlICE9PSBcInV1aWRcIiA/IGJveC50eXBlIDogYm94LnV1aWQpO1xuXHRcdFx0XHQvKiBzdG9yZSB0aGUgYm94IGluIHRoZSAnYm94ZXMnIGFycmF5IHRvIHByZXNlcnZlIGJveCBvcmRlciAoZm9yIGZpbGUgcmV3cml0ZSBpZiBuZWVkZWQpICAqL1xuXHRcdFx0XHR0aGlzLmJveGVzLnB1c2goYm94KTtcblx0XHRcdFx0LyogYnV0IGFsc28gc3RvcmUgYm94IGluIGEgcHJvcGVydHkgZm9yIG1vcmUgZGlyZWN0IGFjY2VzcyAqL1xuXHRcdFx0XHRzd2l0Y2ggKGJveF90eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIm1kYXRcIjpcblx0XHRcdFx0XHRcdHRoaXMubWRhdHMucHVzaChib3gpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm1vb2ZcIjpcblx0XHRcdFx0XHRcdHRoaXMubW9vZnMucHVzaChib3gpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm1vb3ZcIjpcblx0XHRcdFx0XHRcdHRoaXMubW9vdlN0YXJ0Rm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubWRhdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuaXNQcm9ncmVzc2l2ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKiBubyBicmVhayAqL1xuXHRcdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRpZiAodGhpc1tib3hfdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRMb2cud2FybihcIklTT0ZpbGVcIiwgXCJEdXBsaWNhdGUgQm94IG9mIHR5cGU6IFwiK2JveF90eXBlK1wiLCBvdmVycmlkaW5nIHByZXZpb3VzIG9jY3VycmVuY2VcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzW2JveF90eXBlXSA9IGJveDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnVwZGF0ZVVzZWRCeXRlcykge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlVXNlZEJ5dGVzKGJveCwgcmV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuY2hlY2tCdWZmZXIgPSBmdW5jdGlvbiAoYWIpIHtcblx0aWYgKGFiID09PSBudWxsIHx8IGFiID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyhcIkJ1ZmZlciBtdXN0IGJlIGRlZmluZWQgYW5kIG5vbiBlbXB0eVwiKTtcblx0fVxuXHRpZiAoYWIuZmlsZVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyhcIkJ1ZmZlciBtdXN0IGhhdmUgYSBmaWxlU3RhcnQgcHJvcGVydHlcIik7XG5cdH1cblx0aWYgKGFiLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHRMb2cud2FybihcIklTT0ZpbGVcIiwgXCJJZ25vcmluZyBlbXB0eSBidWZmZXIgKGZpbGVTdGFydDogXCIrYWIuZmlsZVN0YXJ0K1wiKVwiKTtcblx0XHR0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRMb2cuaW5mbyhcIklTT0ZpbGVcIiwgXCJQcm9jZXNzaW5nIGJ1ZmZlciAoZmlsZVN0YXJ0OiBcIithYi5maWxlU3RhcnQrXCIpXCIpO1xuXG5cdC8qIG1hcmsgdGhlIGJ5dGVzIGluIHRoZSBidWZmZXIgYXMgbm90IGJlaW5nIHVzZWQgeWV0ICovXG5cdGFiLnVzZWRCeXRlcyA9IDA7XG5cdHRoaXMuc3RyZWFtLmluc2VydEJ1ZmZlcihhYik7XG5cdHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCk7XG5cblx0aWYgKCF0aGlzLnN0cmVhbS5pbml0aWFsaXplZCgpKSB7XG5cdFx0TG9nLndhcm4oXCJJU09GaWxlXCIsIFwiTm90IHJlYWR5IHRvIHN0YXJ0IHBhcnNpbmdcIik7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcblxuLyogUHJvY2Vzc2VzIGEgbmV3IEFycmF5QnVmZmVyICh3aXRoIGEgZmlsZVN0YXJ0IHByb3BlcnR5KVxuICAgUmV0dXJucyB0aGUgbmV4dCBleHBlY3RlZCBmaWxlIHBvc2l0aW9uLCBvciB1bmRlZmluZWQgaWYgbm90IHJlYWR5IHRvIHBhcnNlICovXG5JU09GaWxlLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbihhYiwgbGFzdCkge1xuXHR2YXIgbmV4dEZpbGVTdGFydDtcblx0aWYgKCF0aGlzLmNoZWNrQnVmZmVyKGFiKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8qIFBhcnNlIHdoYXRldmVyIGlzIGluIHRoZSBleGlzdGluZyBidWZmZXJzICovXG5cdHRoaXMucGFyc2UoKTtcblxuXHQvKiBDaGVjayBpZiB0aGUgbW9vdlN0YXJ0IGNhbGxiYWNrIG5lZWRzIHRvIGJlIGNhbGxlZCAqL1xuXHRpZiAodGhpcy5tb292U3RhcnRGb3VuZCAmJiAhdGhpcy5tb292U3RhcnRTZW50KSB7XG5cdFx0dGhpcy5tb292U3RhcnRTZW50ID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5vbk1vb3ZTdGFydCkgdGhpcy5vbk1vb3ZTdGFydCgpO1xuXHR9XG5cblx0aWYgKHRoaXMubW9vdikge1xuXHRcdC8qIEEgbW9vdiBib3ggaGFzIGJlZW4gZW50aXJlbHkgcGFyc2VkICovXG5cblx0XHQvKiBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIGFmdGVyIHRoZSBtb292IGlzIGZvdW5kIHdlIGluaXRpYWxpemUgdGhlIGxpc3Qgb2Ygc2FtcGxlcyAobWF5IGJlIGVtcHR5IGluIGZyYWdtZW50ZWQgZmlsZXMpICovXG5cdFx0aWYgKCF0aGlzLnNhbXBsZUxpc3RCdWlsdCkge1xuXHRcdFx0dGhpcy5idWlsZFNhbXBsZUxpc3RzKCk7XG5cdFx0XHR0aGlzLnNhbXBsZUxpc3RCdWlsdCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0LyogV2UgdXBkYXRlIHRoZSBzYW1wbGUgaW5mb3JtYXRpb24gaWYgdGhlcmUgYXJlIGFueSBuZXcgbW9vZiBib3hlcyAqL1xuXHRcdHRoaXMudXBkYXRlU2FtcGxlTGlzdHMoKTtcblxuXHRcdC8qIElmIHRoZSBhcHBsaWNhdGlvbiBuZWVkcyB0byBiZSBpbmZvcm1lZCB0aGF0IHRoZSAnbW9vdicgaGFzIGJlZW4gZm91bmQsXG5cdFx0ICAgd2UgY3JlYXRlIHRoZSBpbmZvcm1hdGlvbiBvYmplY3QgYW5kIGNhbGxiYWNrIHRoZSBhcHBsaWNhdGlvbiAqL1xuXHRcdGlmICh0aGlzLm9uUmVhZHkgJiYgIXRoaXMucmVhZHlTZW50KSB7XG5cdFx0XHR0aGlzLnJlYWR5U2VudCA9IHRydWU7XG5cdFx0XHR0aGlzLm9uUmVhZHkodGhpcy5nZXRJbmZvKCkpO1xuXHRcdH1cblxuXHRcdC8qIFNlZSBpZiBhbnkgc2FtcGxlIGV4dHJhY3Rpb24gb3Igc2VnbWVudCBjcmVhdGlvbiBuZWVkcyB0byBiZSBkb25lIHdpdGggdGhlIGF2YWlsYWJsZSBzYW1wbGVzICovXG5cdFx0dGhpcy5wcm9jZXNzU2FtcGxlcyhsYXN0KTtcblxuXHRcdC8qIEluZm9ybSBhYm91dCB0aGUgYmVzdCByYW5nZSB0byBmZXRjaCBuZXh0ICovXG5cdFx0aWYgKHRoaXMubmV4dFNlZWtQb3NpdGlvbikge1xuXHRcdFx0bmV4dEZpbGVTdGFydCA9IHRoaXMubmV4dFNlZWtQb3NpdGlvbjtcblx0XHRcdHRoaXMubmV4dFNlZWtQb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV4dEZpbGVTdGFydCA9IHRoaXMubmV4dFBhcnNlUG9zaXRpb247XG5cdFx0fVxuXHRcdGlmICh0aGlzLnN0cmVhbS5nZXRFbmRGaWxlUG9zaXRpb25BZnRlcikge1xuXHRcdFx0bmV4dEZpbGVTdGFydCA9IHRoaXMuc3RyZWFtLmdldEVuZEZpbGVQb3NpdGlvbkFmdGVyKG5leHRGaWxlU3RhcnQpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAodGhpcy5uZXh0UGFyc2VQb3NpdGlvbikge1xuXHRcdFx0LyogbW9vdiBoYXMgbm90IGJlZW4gcGFyc2VkIGJ1dCB0aGUgZmlyc3QgYnVmZmVyIHdhcyByZWNlaXZlZCxcblx0XHRcdCAgIHRoZSBuZXh0IGZldGNoIHNob3VsZCBwcm9iYWJseSBiZSB0aGUgbmV4dCBib3ggc3RhcnQgKi9cblx0XHRcdG5leHRGaWxlU3RhcnQgPSB0aGlzLm5leHRQYXJzZVBvc2l0aW9uO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBObyB2YWxpZCBidWZmZXIgaGFzIGJlZW4gcGFyc2VkIHlldCwgd2UgY2Fubm90IGtub3cgd2hhdCB0byBwYXJzZSBuZXh0ICovXG5cdFx0XHRuZXh0RmlsZVN0YXJ0ID0gMDtcblx0XHR9XG5cdH1cblx0aWYgKHRoaXMuc2lkeCkge1xuXHRcdGlmICh0aGlzLm9uU2lkeCAmJiAhdGhpcy5zaWR4U2VudCkge1xuXHRcdFx0dGhpcy5vblNpZHgodGhpcy5zaWR4KTtcblx0XHRcdHRoaXMuc2lkeFNlbnQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy5tZXRhKSB7XG5cdFx0aWYgKHRoaXMuZmxhdHRlbkl0ZW1JbmZvICYmICF0aGlzLml0ZW1MaXN0QnVpbHQpIHtcblx0XHRcdHRoaXMuZmxhdHRlbkl0ZW1JbmZvKCk7XG5cdFx0XHR0aGlzLml0ZW1MaXN0QnVpbHQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wcm9jZXNzSXRlbXMpIHtcblx0XHRcdHRoaXMucHJvY2Vzc0l0ZW1zKHRoaXMub25JdGVtKTtcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5zdHJlYW0uY2xlYW5CdWZmZXJzKSB7XG5cdFx0TG9nLmluZm8oXCJJU09GaWxlXCIsIFwiRG9uZSBwcm9jZXNzaW5nIGJ1ZmZlciAoZmlsZVN0YXJ0OiBcIithYi5maWxlU3RhcnQrXCIpIC0gbmV4dCBidWZmZXIgdG8gZmV0Y2ggc2hvdWxkIGhhdmUgYSBmaWxlU3RhcnQgcG9zaXRpb24gb2YgXCIrbmV4dEZpbGVTdGFydCk7XG5cdFx0dGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoKTtcblx0XHR0aGlzLnN0cmVhbS5jbGVhbkJ1ZmZlcnMoKTtcblx0XHR0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCh0cnVlKTtcblx0XHRMb2cuaW5mbyhcIklTT0ZpbGVcIiwgXCJTYW1wbGUgZGF0YSBzaXplIGluIG1lbW9yeTogXCIrdGhpcy5nZXRBbGxvY2F0ZWRTYW1wbGVEYXRhU2l6ZSgpKTtcblx0fVxuXHRyZXR1cm4gbmV4dEZpbGVTdGFydDtcbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbigpIHtcblx0dmFyIGksIGo7XG5cdHZhciBtb3ZpZSA9IHt9O1xuXHR2YXIgdHJhaztcblx0dmFyIHRyYWNrO1xuXHR2YXIgc2FtcGxlX2Rlc2M7XG5cdHZhciBfMTkwNCA9IChuZXcgRGF0ZSgnMTkwNC0wMS0wMVQwMDowMDowMFonKS5nZXRUaW1lKCkpO1xuXG5cdGlmICh0aGlzLm1vb3YpIHtcblx0XHRtb3ZpZS5oYXNNb292ID0gdHJ1ZTtcblx0XHRtb3ZpZS5kdXJhdGlvbiA9IHRoaXMubW9vdi5tdmhkLmR1cmF0aW9uO1xuXHRcdG1vdmllLnRpbWVzY2FsZSA9IHRoaXMubW9vdi5tdmhkLnRpbWVzY2FsZTtcblx0XHRtb3ZpZS5pc0ZyYWdtZW50ZWQgPSAodGhpcy5tb292Lm12ZXggIT0gbnVsbCk7XG5cdFx0aWYgKG1vdmllLmlzRnJhZ21lbnRlZCAmJiB0aGlzLm1vb3YubXZleC5tZWhkKSB7XG5cdFx0XHRtb3ZpZS5mcmFnbWVudF9kdXJhdGlvbiA9IHRoaXMubW9vdi5tdmV4Lm1laGQuZnJhZ21lbnRfZHVyYXRpb247XG5cdFx0fVxuXHRcdG1vdmllLmlzUHJvZ3Jlc3NpdmUgPSB0aGlzLmlzUHJvZ3Jlc3NpdmU7XG5cdFx0bW92aWUuaGFzSU9EID0gKHRoaXMubW9vdi5pb2RzICE9IG51bGwpO1xuXHRcdG1vdmllLmJyYW5kcyA9IFtdO1xuXHRcdG1vdmllLmJyYW5kcy5wdXNoKHRoaXMuZnR5cC5tYWpvcl9icmFuZCk7XG5cdFx0bW92aWUuYnJhbmRzID0gbW92aWUuYnJhbmRzLmNvbmNhdCh0aGlzLmZ0eXAuY29tcGF0aWJsZV9icmFuZHMpO1xuXHRcdG1vdmllLmNyZWF0ZWQgPSBuZXcgRGF0ZShfMTkwNCt0aGlzLm1vb3YubXZoZC5jcmVhdGlvbl90aW1lKjEwMDApO1xuXHRcdG1vdmllLm1vZGlmaWVkID0gbmV3IERhdGUoXzE5MDQrdGhpcy5tb292Lm12aGQubW9kaWZpY2F0aW9uX3RpbWUqMTAwMCk7XG5cdFx0bW92aWUudHJhY2tzID0gW107XG5cdFx0bW92aWUuYXVkaW9UcmFja3MgPSBbXTtcblx0XHRtb3ZpZS52aWRlb1RyYWNrcyA9IFtdO1xuXHRcdG1vdmllLnN1YnRpdGxlVHJhY2tzID0gW107XG5cdFx0bW92aWUubWV0YWRhdGFUcmFja3MgPSBbXTtcblx0XHRtb3ZpZS5oaW50VHJhY2tzID0gW107XG5cdFx0bW92aWUub3RoZXJUcmFja3MgPSBbXTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5tb292LnRyYWtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0cmFrID0gdGhpcy5tb292LnRyYWtzW2ldO1xuXHRcdFx0c2FtcGxlX2Rlc2MgPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllc1swXTtcblx0XHRcdHRyYWNrID0ge307XG5cdFx0XHRtb3ZpZS50cmFja3MucHVzaCh0cmFjayk7XG5cdFx0XHR0cmFjay5pZCA9IHRyYWsudGtoZC50cmFja19pZDtcblx0XHRcdHRyYWNrLm5hbWUgPSB0cmFrLm1kaWEuaGRsci5uYW1lO1xuXHRcdFx0dHJhY2sucmVmZXJlbmNlcyA9IFtdO1xuXHRcdFx0aWYgKHRyYWsudHJlZikge1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgdHJhay50cmVmLmJveGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0cmVmID0ge307XG5cdFx0XHRcdFx0dHJhY2sucmVmZXJlbmNlcy5wdXNoKHJlZik7XG5cdFx0XHRcdFx0cmVmLnR5cGUgPSB0cmFrLnRyZWYuYm94ZXNbal0udHlwZTtcblx0XHRcdFx0XHRyZWYudHJhY2tfaWRzID0gdHJhay50cmVmLmJveGVzW2pdLnRyYWNrX2lkcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRyYWsuZWR0cykge1xuXHRcdFx0XHR0cmFjay5lZGl0cyA9IHRyYWsuZWR0cy5lbHN0LmVudHJpZXM7XG5cdFx0XHR9XG5cdFx0XHR0cmFjay5jcmVhdGVkID0gbmV3IERhdGUoXzE5MDQrdHJhay50a2hkLmNyZWF0aW9uX3RpbWUqMTAwMCk7XG5cdFx0XHR0cmFjay5tb2RpZmllZCA9IG5ldyBEYXRlKF8xOTA0K3RyYWsudGtoZC5tb2RpZmljYXRpb25fdGltZSoxMDAwKTtcblx0XHRcdHRyYWNrLm1vdmllX2R1cmF0aW9uID0gdHJhay50a2hkLmR1cmF0aW9uO1xuXHRcdFx0dHJhY2subW92aWVfdGltZXNjYWxlID0gbW92aWUudGltZXNjYWxlO1xuXHRcdFx0dHJhY2subGF5ZXIgPSB0cmFrLnRraGQubGF5ZXI7XG5cdFx0XHR0cmFjay5hbHRlcm5hdGVfZ3JvdXAgPSB0cmFrLnRraGQuYWx0ZXJuYXRlX2dyb3VwO1xuXHRcdFx0dHJhY2sudm9sdW1lID0gdHJhay50a2hkLnZvbHVtZTtcblx0XHRcdHRyYWNrLm1hdHJpeCA9IHRyYWsudGtoZC5tYXRyaXg7XG5cdFx0XHR0cmFjay50cmFja193aWR0aCA9IHRyYWsudGtoZC53aWR0aC8oMTw8MTYpO1xuXHRcdFx0dHJhY2sudHJhY2tfaGVpZ2h0ID0gdHJhay50a2hkLmhlaWdodC8oMTw8MTYpO1xuXHRcdFx0dHJhY2sudGltZXNjYWxlID0gdHJhay5tZGlhLm1kaGQudGltZXNjYWxlO1xuXHRcdFx0dHJhY2suY3RzX3NoaWZ0ID0gdHJhay5tZGlhLm1pbmYuc3RibC5jc2xnO1xuXHRcdFx0dHJhY2suZHVyYXRpb24gPSB0cmFrLm1kaWEubWRoZC5kdXJhdGlvbjtcblx0XHRcdHRyYWNrLnNhbXBsZXNfZHVyYXRpb24gPSB0cmFrLnNhbXBsZXNfZHVyYXRpb247XG5cdFx0XHR0cmFjay5jb2RlYyA9IHNhbXBsZV9kZXNjLmdldENvZGVjKCk7XG5cdFx0XHR0cmFjay5raW5kID0gKHRyYWsudWR0YSAmJiB0cmFrLnVkdGEua2luZHMubGVuZ3RoID8gdHJhay51ZHRhLmtpbmRzWzBdIDogeyBzY2hlbWVVUkk6IFwiXCIsIHZhbHVlOiBcIlwifSk7XG5cdFx0XHR0cmFjay5sYW5ndWFnZSA9ICh0cmFrLm1kaWEuZWxuZyA/IHRyYWsubWRpYS5lbG5nLmV4dGVuZGVkX2xhbmd1YWdlIDogdHJhay5tZGlhLm1kaGQubGFuZ3VhZ2VTdHJpbmcpO1xuXHRcdFx0dHJhY2submJfc2FtcGxlcyA9IHRyYWsuc2FtcGxlcy5sZW5ndGg7XG5cdFx0XHR0cmFjay5zaXplID0gdHJhay5zYW1wbGVzX3NpemU7XG5cdFx0XHR0cmFjay5iaXRyYXRlID0gKHRyYWNrLnNpemUqOCp0cmFjay50aW1lc2NhbGUpL3RyYWNrLnNhbXBsZXNfZHVyYXRpb247XG5cdFx0XHRpZiAoc2FtcGxlX2Rlc2MuaXNBdWRpbygpKSB7XG5cdFx0XHRcdHRyYWNrLnR5cGUgPSBcImF1ZGlvXCI7XG5cdFx0XHRcdG1vdmllLmF1ZGlvVHJhY2tzLnB1c2godHJhY2spO1xuXHRcdFx0XHR0cmFjay5hdWRpbyA9IHt9O1xuXHRcdFx0XHR0cmFjay5hdWRpby5zYW1wbGVfcmF0ZSA9IHNhbXBsZV9kZXNjLmdldFNhbXBsZVJhdGUoKTtcblx0XHRcdFx0dHJhY2suYXVkaW8uY2hhbm5lbF9jb3VudCA9IHNhbXBsZV9kZXNjLmdldENoYW5uZWxDb3VudCgpO1xuXHRcdFx0XHR0cmFjay5hdWRpby5zYW1wbGVfc2l6ZSA9IHNhbXBsZV9kZXNjLmdldFNhbXBsZVNpemUoKTtcblx0XHRcdH0gZWxzZSBpZiAoc2FtcGxlX2Rlc2MuaXNWaWRlbygpKSB7XG5cdFx0XHRcdHRyYWNrLnR5cGUgPSBcInZpZGVvXCI7XG5cdFx0XHRcdG1vdmllLnZpZGVvVHJhY2tzLnB1c2godHJhY2spO1xuXHRcdFx0XHR0cmFjay52aWRlbyA9IHt9O1xuXHRcdFx0XHR0cmFjay52aWRlby53aWR0aCA9IHNhbXBsZV9kZXNjLmdldFdpZHRoKCk7XG5cdFx0XHRcdHRyYWNrLnZpZGVvLmhlaWdodCA9IHNhbXBsZV9kZXNjLmdldEhlaWdodCgpO1xuXHRcdFx0fSBlbHNlIGlmIChzYW1wbGVfZGVzYy5pc1N1YnRpdGxlKCkpIHtcblx0XHRcdFx0dHJhY2sudHlwZSA9IFwic3VidGl0bGVzXCI7XG5cdFx0XHRcdG1vdmllLnN1YnRpdGxlVHJhY2tzLnB1c2godHJhY2spO1xuXHRcdFx0fSBlbHNlIGlmIChzYW1wbGVfZGVzYy5pc0hpbnQoKSkge1xuXHRcdFx0XHR0cmFjay50eXBlID0gXCJtZXRhZGF0YVwiO1xuXHRcdFx0XHRtb3ZpZS5oaW50VHJhY2tzLnB1c2godHJhY2spO1xuXHRcdFx0fSBlbHNlIGlmIChzYW1wbGVfZGVzYy5pc01ldGFkYXRhKCkpIHtcblx0XHRcdFx0dHJhY2sudHlwZSA9IFwibWV0YWRhdGFcIjtcblx0XHRcdFx0bW92aWUubWV0YWRhdGFUcmFja3MucHVzaCh0cmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmFjay50eXBlID0gXCJtZXRhZGF0YVwiO1xuXHRcdFx0XHRtb3ZpZS5vdGhlclRyYWNrcy5wdXNoKHRyYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0bW92aWUuaGFzTW9vdiA9IGZhbHNlO1xuXHR9XG5cdG1vdmllLm1pbWUgPSBcIlwiO1xuXHRpZiAobW92aWUuaGFzTW9vdiAmJiBtb3ZpZS50cmFja3MpIHtcblx0XHRpZiAobW92aWUudmlkZW9UcmFja3MgJiYgbW92aWUudmlkZW9UcmFja3MubGVuZ3RoID4gMCkge1xuXHRcdFx0bW92aWUubWltZSArPSAndmlkZW8vbXA0OyBjb2RlY3M9XFxcIic7XG5cdFx0fSBlbHNlIGlmIChtb3ZpZS5hdWRpb1RyYWNrcyAmJiBtb3ZpZS5hdWRpb1RyYWNrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtb3ZpZS5taW1lICs9ICdhdWRpby9tcDQ7IGNvZGVjcz1cXFwiJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0bW92aWUubWltZSArPSAnYXBwbGljYXRpb24vbXA0OyBjb2RlY3M9XFxcIic7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBtb3ZpZS50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpICE9PSAwKSBtb3ZpZS5taW1lICs9ICcsJztcblx0XHRcdG1vdmllLm1pbWUrPSBtb3ZpZS50cmFja3NbaV0uY29kZWM7XG5cdFx0fVxuXHRcdG1vdmllLm1pbWUgKz0gJ1xcXCI7IHByb2ZpbGVzPVxcXCInO1xuXHRcdG1vdmllLm1pbWUgKz0gdGhpcy5mdHlwLmNvbXBhdGlibGVfYnJhbmRzLmpvaW4oKTtcblx0XHRtb3ZpZS5taW1lICs9ICdcXFwiJztcblx0fVxuXHRyZXR1cm4gbW92aWU7XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5wcm9jZXNzU2FtcGxlcyA9IGZ1bmN0aW9uKGxhc3QpIHtcblx0dmFyIGk7XG5cdHZhciB0cmFrO1xuXHRpZiAoIXRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQpIHJldHVybjtcblxuXHQvKiBGb3IgZWFjaCB0cmFjayBtYXJrZWQgZm9yIGZyYWdtZW50YXRpb24sXG5cdCAgIGNoZWNrIGlmIHRoZSBuZXh0IHNhbXBsZSBpcyB0aGVyZSAoaS5lLiBpZiB0aGUgc2FtcGxlIGluZm9ybWF0aW9uIGlzIGtub3duIChpLmUuIG1vb2YgaGFzIGFycml2ZWQpIGFuZCBpZiBpdCBoYXMgYmVlbiBkb3dubG9hZGVkKVxuXHQgICBhbmQgY3JlYXRlIGEgZnJhZ21lbnQgd2l0aCBpdCAqL1xuXHRpZiAodGhpcy5pc0ZyYWdtZW50YXRpb25Jbml0aWFsaXplZCAmJiB0aGlzLm9uU2VnbWVudCAhPT0gbnVsbCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmZyYWdtZW50ZWRUcmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBmcmFnVHJhayA9IHRoaXMuZnJhZ21lbnRlZFRyYWNrc1tpXTtcblx0XHRcdHRyYWsgPSBmcmFnVHJhay50cmFrO1xuXHRcdFx0d2hpbGUgKHRyYWsubmV4dFNhbXBsZSA8IHRyYWsuc2FtcGxlcy5sZW5ndGggJiYgdGhpcy5zYW1wbGVQcm9jZXNzaW5nU3RhcnRlZCkge1xuXHRcdFx0XHQvKiBUaGUgc2FtcGxlIGluZm9ybWF0aW9uIGlzIHRoZXJlIChlaXRoZXIgYmVjYXVzZSB0aGUgZmlsZSBpcyBub3QgZnJhZ21lbnRlZCBhbmQgdGhpcyBpcyBub3QgdGhlIGxhc3Qgc2FtcGxlLFxuXHRcdFx0XHRvciBiZWNhdXNlIHRoZSBmaWxlIGlzIGZyYWdtZW50ZWQgYW5kIHRoZSBtb29mIGZvciB0aGF0IHNhbXBsZSBoYXMgYmVlbiByZWNlaXZlZCAqL1xuXHRcdFx0XHRMb2cuZGVidWcoXCJJU09GaWxlXCIsIFwiQ3JlYXRpbmcgbWVkaWEgZnJhZ21lbnQgb24gdHJhY2sgI1wiK2ZyYWdUcmFrLmlkICtcIiBmb3Igc2FtcGxlIFwiK3RyYWsubmV4dFNhbXBsZSk7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmNyZWF0ZUZyYWdtZW50KGZyYWdUcmFrLmlkLCB0cmFrLm5leHRTYW1wbGUsIGZyYWdUcmFrLnNlZ21lbnRTdHJlYW0pO1xuXHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0ZnJhZ1RyYWsuc2VnbWVudFN0cmVhbSA9IHJlc3VsdDtcblx0XHRcdFx0XHR0cmFrLm5leHRTYW1wbGUrKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBUaGUgZnJhZ21lbnQgY291bGQgbm90IGJlIGNyZWF0ZWQgYmVjYXVzZSB0aGUgbWVkaWEgZGF0YSBpcyBub3QgdGhlcmUgKG5vdCBkb3dubG9hZGVkKSwgd2FpdCBmb3IgaXQgKi9cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBBIGZyYWdtZW50IGlzIGNyZWF0ZWQgYnkgc2FtcGxlLCBidXQgdGhlIHNlZ21lbnQgaXMgdGhlIGFjY3VtdWxhdGlvbiBpbiB0aGUgYnVmZmVyIG9mIHRoZXNlIGZyYWdtZW50cy5cblx0XHRcdFx0ICAgSXQgaXMgZmx1c2hlZCBvbmx5IGFzIHJlcXVlc3RlZCBieSB0aGUgYXBwbGljYXRpb24gKG5iX3NhbXBsZXMpIHRvIGF2b2lkIHRvbyBtYW55IGNhbGxiYWNrcyAqL1xuXHRcdFx0XHRpZiAodHJhay5uZXh0U2FtcGxlICUgZnJhZ1RyYWsubmJfc2FtcGxlcyA9PT0gMCB8fCAobGFzdCB8fCB0cmFrLm5leHRTYW1wbGUgPj0gdHJhay5zYW1wbGVzLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRMb2cuaW5mbyhcIklTT0ZpbGVcIiwgXCJTZW5kaW5nIGZyYWdtZW50ZWQgZGF0YSBvbiB0cmFjayAjXCIrZnJhZ1RyYWsuaWQrXCIgZm9yIHNhbXBsZXMgW1wiK01hdGgubWF4KDAsdHJhay5uZXh0U2FtcGxlLWZyYWdUcmFrLm5iX3NhbXBsZXMpK1wiLFwiKyh0cmFrLm5leHRTYW1wbGUtMSkrXCJdXCIpO1xuXHRcdFx0XHRcdExvZy5pbmZvKFwiSVNPRmlsZVwiLCBcIlNhbXBsZSBkYXRhIHNpemUgaW4gbWVtb3J5OiBcIit0aGlzLmdldEFsbG9jYXRlZFNhbXBsZURhdGFTaXplKCkpO1xuXHRcdFx0XHRcdGlmICh0aGlzLm9uU2VnbWVudCkge1xuXHRcdFx0XHRcdFx0dGhpcy5vblNlZ21lbnQoZnJhZ1RyYWsuaWQsIGZyYWdUcmFrLnVzZXIsIGZyYWdUcmFrLnNlZ21lbnRTdHJlYW0uYnVmZmVyLCB0cmFrLm5leHRTYW1wbGUsIChsYXN0IHx8IHRyYWsubmV4dFNhbXBsZSA+PSB0cmFrLnNhbXBsZXMubGVuZ3RoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8qIGZvcmNlIHRoZSBjcmVhdGlvbiBvZiBhIG5ldyBidWZmZXIgKi9cblx0XHRcdFx0XHRmcmFnVHJhay5zZWdtZW50U3RyZWFtID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoZnJhZ1RyYWsgIT09IHRoaXMuZnJhZ21lbnRlZFRyYWNrc1tpXSkge1xuXHRcdFx0XHRcdFx0LyogbWFrZSBzdXJlIHdlIGNhbiBzdG9wIGZyYWdtZW50YXRpb24gaWYgbmVlZGVkICovXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5vblNhbXBsZXMgIT09IG51bGwpIHtcblx0XHQvKiBGb3IgZWFjaCB0cmFjayBtYXJrZWQgZm9yIGRhdGEgZXhwb3J0LFxuXHRcdCAgIGNoZWNrIGlmIHRoZSBuZXh0IHNhbXBsZSBpcyB0aGVyZSAoaS5lLiBoYXMgYmVlbiBkb3dubG9hZGVkKSBhbmQgc2VuZCBpdCAqL1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmV4dHJhY3RlZFRyYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGV4dHJhY3RUcmFrID0gdGhpcy5leHRyYWN0ZWRUcmFja3NbaV07XG5cdFx0XHR0cmFrID0gZXh0cmFjdFRyYWsudHJhaztcblx0XHRcdHdoaWxlICh0cmFrLm5leHRTYW1wbGUgPCB0cmFrLnNhbXBsZXMubGVuZ3RoICYmIHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQpIHtcblx0XHRcdFx0TG9nLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkV4cG9ydGluZyBvbiB0cmFjayAjXCIrZXh0cmFjdFRyYWsuaWQgK1wiIHNhbXBsZSAjXCIrdHJhay5uZXh0U2FtcGxlKTtcblx0XHRcdFx0dmFyIHNhbXBsZSA9IHRoaXMuZ2V0U2FtcGxlKHRyYWssIHRyYWsubmV4dFNhbXBsZSk7XG5cdFx0XHRcdGlmIChzYW1wbGUpIHtcblx0XHRcdFx0XHR0cmFrLm5leHRTYW1wbGUrKztcblx0XHRcdFx0XHRleHRyYWN0VHJhay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHJhay5uZXh0U2FtcGxlICUgZXh0cmFjdFRyYWsubmJfc2FtcGxlcyA9PT0gMCB8fCB0cmFrLm5leHRTYW1wbGUgPj0gdHJhay5zYW1wbGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdExvZy5kZWJ1ZyhcIklTT0ZpbGVcIiwgXCJTZW5kaW5nIHNhbXBsZXMgb24gdHJhY2sgI1wiK2V4dHJhY3RUcmFrLmlkK1wiIGZvciBzYW1wbGUgXCIrdHJhay5uZXh0U2FtcGxlKTtcblx0XHRcdFx0XHRpZiAodGhpcy5vblNhbXBsZXMpIHtcblx0XHRcdFx0XHRcdHRoaXMub25TYW1wbGVzKGV4dHJhY3RUcmFrLmlkLCBleHRyYWN0VHJhay51c2VyLCBleHRyYWN0VHJhay5zYW1wbGVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXh0cmFjdFRyYWsuc2FtcGxlcyA9IFtdO1xuXHRcdFx0XHRcdGlmIChleHRyYWN0VHJhayAhPT0gdGhpcy5leHRyYWN0ZWRUcmFja3NbaV0pIHtcblx0XHRcdFx0XHRcdC8qIGNoZWNrIGlmIHRoZSBleHRyYWN0aW9uIG5lZWRzIHRvIGJlIHN0b3BwZWQgKi9cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLyogRmluZCBhbmQgcmV0dXJuIHNwZWNpZmljIGJveGVzIHVzaW5nIHJlY3Vyc2lvbiBhbmQgZWFybHkgcmV0dXJuICovXG5JU09GaWxlLnByb3RvdHlwZS5nZXRCb3ggPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmdldEJveGVzKHR5cGUsIHRydWUpO1xuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHRbMF0gOiBudWxsKTtcbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmdldEJveGVzID0gZnVuY3Rpb24odHlwZSwgcmV0dXJuRWFybHkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBJU09GaWxlLl9zd2VlcC5jYWxsKHRoaXMsIHR5cGUsIHJlc3VsdCwgcmV0dXJuRWFybHkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSVNPRmlsZS5fc3dlZXAgPSBmdW5jdGlvbih0eXBlLCByZXN1bHQsIHJldHVybkVhcmx5KSB7XG4gIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlID09IHR5cGUpIHJlc3VsdC5wdXNoKHRoaXMpO1xuICBmb3IgKHZhciBib3ggaW4gdGhpcy5ib3hlcykge1xuICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJldHVybkVhcmx5KSByZXR1cm47XG4gICAgSVNPRmlsZS5fc3dlZXAuY2FsbCh0aGlzLmJveGVzW2JveF0sIHR5cGUsIHJlc3VsdCwgcmV0dXJuRWFybHkpO1xuICB9XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5nZXRUcmFja1NhbXBsZXNJbmZvID0gZnVuY3Rpb24odHJhY2tfaWQpIHtcblx0dmFyIHRyYWNrID0gdGhpcy5nZXRUcmFja0J5SWQodHJhY2tfaWQpO1xuXHRpZiAodHJhY2spIHtcblx0XHRyZXR1cm4gdHJhY2suc2FtcGxlcztcblx0fSBlbHNlIHtcblx0XHRyZXR1cm47XG5cdH1cbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmdldFRyYWNrU2FtcGxlID0gZnVuY3Rpb24odHJhY2tfaWQsIG51bWJlcikge1xuXHR2YXIgdHJhY2sgPSB0aGlzLmdldFRyYWNrQnlJZCh0cmFja19pZCk7XG5cdHZhciBzYW1wbGUgPSB0aGlzLmdldFNhbXBsZSh0cmFjaywgbnVtYmVyKTtcblx0cmV0dXJuIHNhbXBsZTtcbn07XG5cbi8qIENhbGxlZCBieSB0aGUgYXBwbGljYXRpb24gdG8gcmVsZWFzZSB0aGUgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gc2FtcGxlcyBhbHJlYWR5IGZvcndhcmRlZCB0byB0aGUgYXBwbGljYXRpb24gKi9cbklTT0ZpbGUucHJvdG90eXBlLnJlbGVhc2VVc2VkU2FtcGxlcyA9IGZ1bmN0aW9uIChpZCwgc2FtcGxlTnVtKSB7XG5cdHZhciBzaXplID0gMDtcblx0dmFyIHRyYWsgPSB0aGlzLmdldFRyYWNrQnlJZChpZCk7XG5cdGlmICghdHJhay5sYXN0VmFsaWRTYW1wbGUpIHRyYWsubGFzdFZhbGlkU2FtcGxlID0gMDtcblx0Zm9yICh2YXIgaSA9IHRyYWsubGFzdFZhbGlkU2FtcGxlOyBpIDwgc2FtcGxlTnVtOyBpKyspIHtcblx0XHRzaXplKz10aGlzLnJlbGVhc2VTYW1wbGUodHJhaywgaSk7XG5cdH1cblx0TG9nLmluZm8oXCJJU09GaWxlXCIsIFwiVHJhY2sgI1wiK2lkK1wiIHJlbGVhc2VkIHNhbXBsZXMgdXAgdG8gXCIrc2FtcGxlTnVtK1wiIChyZWxlYXNlZCBzaXplOiBcIitzaXplK1wiLCByZW1haW5pbmc6IFwiK3RoaXMuc2FtcGxlc0RhdGFTaXplK1wiKVwiKTtcblx0dHJhay5sYXN0VmFsaWRTYW1wbGUgPSBzYW1wbGVOdW07XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnNhbXBsZVByb2Nlc3NpbmdTdGFydGVkID0gdHJ1ZTtcblx0dGhpcy5wcm9jZXNzU2FtcGxlcyhmYWxzZSk7XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2FtcGxlUHJvY2Vzc2luZ1N0YXJ0ZWQgPSBmYWxzZTtcbn07XG5cbi8qIENhbGxlZCBieSB0aGUgYXBwbGljYXRpb24gdG8gZmx1c2ggdGhlIHJlbWFpbmluZyBzYW1wbGVzIChlLmcuIG9uY2UgdGhlIGRvd25sb2FkIGlzIGZpbmlzaGVkIG9yIHdoZW4gbm8gbW9yZSBzYW1wbGVzIHdpbGwgYmUgYWRkZWQpICovXG5JU09GaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuXHRMb2cuaW5mbyhcIklTT0ZpbGVcIiwgXCJGbHVzaGluZyByZW1haW5pbmcgc2FtcGxlc1wiKTtcblx0dGhpcy51cGRhdGVTYW1wbGVMaXN0cygpO1xuXHR0aGlzLnByb2Nlc3NTYW1wbGVzKHRydWUpO1xuXHR0aGlzLnN0cmVhbS5jbGVhbkJ1ZmZlcnMoKTtcblx0dGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwodHJ1ZSk7XG59O1xuXG4vKiBGaW5kcyB0aGUgYnl0ZSBvZmZzZXQgZm9yIGEgZ2l2ZW4gdGltZSBvbiBhIGdpdmVuIHRyYWNrXG4gICBhbHNvIHJldHVybnMgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzIHJhcCAqL1xuSVNPRmlsZS5wcm90b3R5cGUuc2Vla1RyYWNrID0gZnVuY3Rpb24odGltZSwgdXNlUmFwLCB0cmFrKSB7XG5cdHZhciBqO1xuXHR2YXIgc2FtcGxlO1xuXHR2YXIgc2Vla19vZmZzZXQgPSBJbmZpbml0eTtcblx0dmFyIHJhcF9zZWVrX3NhbXBsZV9udW0gPSAwO1xuXHR2YXIgc2Vla19zYW1wbGVfbnVtID0gMDtcblx0dmFyIHRpbWVzY2FsZTtcblxuXHRpZiAodHJhay5zYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdExvZy5pbmZvKFwiSVNPRmlsZVwiLCBcIk5vIHNhbXBsZSBpbiB0cmFjaywgY2Fubm90IHNlZWshIFVzaW5nIHRpbWUgXCIrTG9nLmdldER1cmF0aW9uU3RyaW5nKDAsIDEpICtcIiBhbmQgb2Zmc2V0OiBcIiswKTtcblx0XHRyZXR1cm4geyBvZmZzZXQ6IDAsIHRpbWU6IDAgfTtcblx0fVxuXG5cdGZvciAoaiA9IDA7IGogPCB0cmFrLnNhbXBsZXMubGVuZ3RoOyBqKyspIHtcblx0XHRzYW1wbGUgPSB0cmFrLnNhbXBsZXNbal07XG5cdFx0aWYgKGogPT09IDApIHtcblx0XHRcdHNlZWtfc2FtcGxlX251bSA9IDA7XG5cdFx0XHR0aW1lc2NhbGUgPSBzYW1wbGUudGltZXNjYWxlO1xuXHRcdH0gZWxzZSBpZiAoc2FtcGxlLmN0cyA+IHRpbWUgKiBzYW1wbGUudGltZXNjYWxlKSB7XG5cdFx0XHRzZWVrX3NhbXBsZV9udW0gPSBqLTE7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKHVzZVJhcCAmJiBzYW1wbGUuaXNfc3luYykge1xuXHRcdFx0cmFwX3NlZWtfc2FtcGxlX251bSA9IGo7XG5cdFx0fVxuXHR9XG5cdGlmICh1c2VSYXApIHtcblx0XHRzZWVrX3NhbXBsZV9udW0gPSByYXBfc2Vla19zYW1wbGVfbnVtO1xuXHR9XG5cdHRpbWUgPSB0cmFrLnNhbXBsZXNbc2Vla19zYW1wbGVfbnVtXS5jdHM7XG5cdHRyYWsubmV4dFNhbXBsZSA9IHNlZWtfc2FtcGxlX251bTtcblx0d2hpbGUgKHRyYWsuc2FtcGxlc1tzZWVrX3NhbXBsZV9udW1dLmFscmVhZHlSZWFkID09PSB0cmFrLnNhbXBsZXNbc2Vla19zYW1wbGVfbnVtXS5zaXplKSB7XG5cdFx0Ly8gTm8gcmVtYWluaW5nIHNhbXBsZXMgdG8gbG9vayBmb3IsIGFsbCBhcmUgZG93bmxvYWRlZC5cblx0XHRpZiAoIXRyYWsuc2FtcGxlc1tzZWVrX3NhbXBsZV9udW0gKyAxXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHNlZWtfc2FtcGxlX251bSsrO1xuXHR9XG5cdHNlZWtfb2Zmc2V0ID0gdHJhay5zYW1wbGVzW3NlZWtfc2FtcGxlX251bV0ub2Zmc2V0K3RyYWsuc2FtcGxlc1tzZWVrX3NhbXBsZV9udW1dLmFscmVhZHlSZWFkO1xuXHRMb2cuaW5mbyhcIklTT0ZpbGVcIiwgXCJTZWVraW5nIHRvIFwiKyh1c2VSYXAgPyBcIlJBUFwiOiBcIlwiKStcIiBzYW1wbGUgI1wiK3RyYWsubmV4dFNhbXBsZStcIiBvbiB0cmFjayBcIit0cmFrLnRraGQudHJhY2tfaWQrXCIsIHRpbWUgXCIrTG9nLmdldER1cmF0aW9uU3RyaW5nKHRpbWUsIHRpbWVzY2FsZSkgK1wiIGFuZCBvZmZzZXQ6IFwiK3NlZWtfb2Zmc2V0KTtcblx0cmV0dXJuIHsgb2Zmc2V0OiBzZWVrX29mZnNldCwgdGltZTogdGltZS90aW1lc2NhbGUgfTtcbn07XG5cbi8qIEZpbmRzIHRoZSBieXRlIG9mZnNldCBpbiB0aGUgZmlsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB0aW1lIG9yIHRvIHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91cyBSQVAgKi9cbklTT0ZpbGUucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbih0aW1lLCB1c2VSYXApIHtcblx0dmFyIG1vb3YgPSB0aGlzLm1vb3Y7XG5cdHZhciB0cmFrO1xuXHR2YXIgdHJha19zZWVrX2luZm87XG5cdHZhciBpO1xuXHR2YXIgc2Vla19pbmZvID0geyBvZmZzZXQ6IEluZmluaXR5LCB0aW1lOiBJbmZpbml0eSB9O1xuXHRpZiAoIXRoaXMubW9vdikge1xuXHRcdHRocm93IFwiQ2Fubm90IHNlZWs6IG1vb3Ygbm90IHJlY2VpdmVkIVwiO1xuXHR9IGVsc2Uge1xuXHRcdGZvciAoaSA9IDA7IGk8bW9vdi50cmFrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJhayA9IG1vb3YudHJha3NbaV07XG5cdFx0XHR0cmFrX3NlZWtfaW5mbyA9IHRoaXMuc2Vla1RyYWNrKHRpbWUsIHVzZVJhcCwgdHJhayk7XG5cdFx0XHRpZiAodHJha19zZWVrX2luZm8ub2Zmc2V0IDwgc2Vla19pbmZvLm9mZnNldCkge1xuXHRcdFx0XHRzZWVrX2luZm8ub2Zmc2V0ID0gdHJha19zZWVrX2luZm8ub2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRyYWtfc2Vla19pbmZvLnRpbWUgPCBzZWVrX2luZm8udGltZSkge1xuXHRcdFx0XHRzZWVrX2luZm8udGltZSA9IHRyYWtfc2Vla19pbmZvLnRpbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdExvZy5pbmZvKFwiSVNPRmlsZVwiLCBcIlNlZWtpbmcgYXQgdGltZSBcIitMb2cuZ2V0RHVyYXRpb25TdHJpbmcoc2Vla19pbmZvLnRpbWUsIDEpK1wiIG5lZWRzIGEgYnVmZmVyIHdpdGggYSBmaWxlU3RhcnQgcG9zaXRpb24gb2YgXCIrc2Vla19pbmZvLm9mZnNldCk7XG5cdFx0aWYgKHNlZWtfaW5mby5vZmZzZXQgPT09IEluZmluaXR5KSB7XG5cdFx0XHQvKiBObyBzYW1wbGUgaW5mbywgaW4gYWxsIHRyYWNrcywgY2Fubm90IHNlZWsgKi9cblx0XHRcdHNlZWtfaW5mbyA9IHsgb2Zmc2V0OiB0aGlzLm5leHRQYXJzZVBvc2l0aW9uLCB0aW1lOiAwIH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIGNoZWNrIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIGFscmVhZHkgaW4gc29tZSBidWZmZXIgYW5kXG5cdFx0XHQgaW4gdGhhdCBjYXNlIHJldHVybiB0aGUgZW5kIG9mIHRoYXQgYnVmZmVyIChvciBvZiB0aGUgbGFzdCBjb250aWd1b3VzIGJ1ZmZlcikgKi9cblx0XHRcdC8qIFRPRE86IFNob3VsZCB3YWl0IHVudGlsIGFwcGVuZCBvcGVyYXRpb25zIGFyZSBkb25lICovXG5cdFx0XHRzZWVrX2luZm8ub2Zmc2V0ID0gdGhpcy5zdHJlYW0uZ2V0RW5kRmlsZVBvc2l0aW9uQWZ0ZXIoc2Vla19pbmZvLm9mZnNldCk7XG5cdFx0fVxuXHRcdExvZy5pbmZvKFwiSVNPRmlsZVwiLCBcIkFkanVzdGVkIHNlZWsgcG9zaXRpb24gKGFmdGVyIGNoZWNraW5nIGRhdGEgYWxyZWFkeSBpbiBidWZmZXIpOiBcIitzZWVrX2luZm8ub2Zmc2V0KTtcblx0XHRyZXR1cm4gc2Vla19pbmZvO1xuXHR9XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uKGIpIHtcblx0dmFyIGJveF9pbmRleCA9IDA7XG5cdHdoaWxlIChib3hfaW5kZXggPCB0aGlzLmJveGVzLmxlbmd0aCAmJiBib3hfaW5kZXggPCBiLmJveGVzLmxlbmd0aCkge1xuXHRcdHZhciBhX2JveCA9IHRoaXMuYm94ZXNbYm94X2luZGV4XTtcblx0XHR2YXIgYl9ib3ggPSBiLmJveGVzW2JveF9pbmRleF07XG5cdFx0aWYgKCFCb3hQYXJzZXIuYm94RXF1YWwoYV9ib3gsIGJfYm94KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRib3hfaW5kZXgrKztcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbntcblx0ZXhwb3J0cy5JU09GaWxlID0gSVNPRmlsZTtcbn1cbi8vIGZpbGU6c3JjL2lzb2ZpbGUtYWR2YW5jZWQtcGFyc2luZy5qc1xuLyogcG9zaXRpb24gaW4gdGhlIGN1cnJlbnQgYnVmZmVyIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxhc3QgYm94IHBhcnNlZCAqL1xuSVNPRmlsZS5wcm90b3R5cGUubGFzdEJveFN0YXJ0UG9zaXRpb24gPSAwO1xuLyogaW5kaWNhdG9yIGlmIHRoZSBwYXJzaW5nIGlzIHN0dWNrIGluIHRoZSBtaWRkbGUgb2YgYW4gbWRhdCBib3ggKi9cbklTT0ZpbGUucHJvdG90eXBlLnBhcnNpbmdNZGF0ID0gbnVsbDtcbi8qIG5leHQgZmlsZSBwb3NpdGlvbiB0aGF0IHRoZSBwYXJzZXIgbmVlZHM6XG4gICAgLSAwIHVudGlsIHRoZSBmaXJzdCBidWZmZXIgKGkuZS4gZmlsZVN0YXJ0ID09PTApIGhhcyBiZWVuIHJlY2VpdmVkIFxuICAgIC0gb3RoZXJ3aXNlLCB0aGUgbmV4dCBib3ggc3RhcnQgdW50aWwgdGhlIG1vb3YgYm94IGhhcyBiZWVuIHBhcnNlZFxuICAgIC0gb3RoZXJ3aXNlLCB0aGUgcG9zaXRpb24gb2YgdGhlIG5leHQgc2FtcGxlIHRvIGZldGNoXG4gKi9cbklTT0ZpbGUucHJvdG90eXBlLm5leHRQYXJzZVBvc2l0aW9uID0gMDtcbi8qIGtlZXAgbWRhdCBkYXRhICovXG5JU09GaWxlLnByb3RvdHlwZS5kaXNjYXJkTWRhdERhdGEgPSBmYWxzZTtcblxuSVNPRmlsZS5wcm90b3R5cGUucHJvY2Vzc0luY29tcGxldGVCb3ggPSBmdW5jdGlvbihyZXQpIHtcblx0dmFyIGJveDtcblx0dmFyIG1lcmdlZDtcblx0dmFyIGZvdW5kO1xuXHRcblx0Lyogd2UgZGlkIG5vdCBoYXZlIGVub3VnaCBieXRlcyBpbiB0aGUgY3VycmVudCBidWZmZXIgdG8gcGFyc2UgdGhlIGVudGlyZSBib3ggKi9cblx0aWYgKHJldC50eXBlID09PSBcIm1kYXRcIikgeyBcblx0XHQvKiB3ZSBoYWQgZW5vdWdoIGJ5dGVzIHRvIGdldCBpdHMgdHlwZSBhbmQgc2l6ZSBhbmQgaXQncyBhbiAnbWRhdCcgKi9cblx0XHRcblx0XHQvKiBzcGVjaWFsIGhhbmRsaW5nIGZvciBtZGF0IGJveGVzLCBzaW5jZSB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRvIHBhcnNlIGl0IGxpbmVhcmx5IFxuXHRcdCAgIHdlIGNyZWF0ZSB0aGUgYm94ICovXG5cdFx0Ym94ID0gbmV3IEJveFBhcnNlcltyZXQudHlwZStcIkJveFwiXShyZXQuc2l6ZSk7XHRcblx0XHR0aGlzLnBhcnNpbmdNZGF0ID0gYm94O1xuXHRcdHRoaXMuYm94ZXMucHVzaChib3gpO1xuXHRcdHRoaXMubWRhdHMucHVzaChib3gpO1x0XHRcdFxuXHRcdGJveC5zdGFydCA9IHJldC5zdGFydDtcblx0XHRib3guaGRyX3NpemUgPSByZXQuaGRyX3NpemU7XG5cdFx0dGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzKGJveC5oZHJfc2l6ZSk7XG5cblx0XHQvKiBpbmRpY2F0ZSB0aGF0IHRoZSBwYXJzaW5nIHNob3VsZCBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJveCAqL1xuXHRcdHRoaXMubGFzdEJveFN0YXJ0UG9zaXRpb24gPSBib3guc3RhcnQgKyBib3guc2l6ZTtcbiBcdFx0LyogbGV0J3Mgc2VlIGlmIHdlIGhhdmUgdGhlIGVuZCBvZiB0aGUgYm94IGluIHRoZSBvdGhlciBidWZmZXJzICovXG5cdFx0Zm91bmQgPSB0aGlzLnN0cmVhbS5zZWVrKGJveC5zdGFydCArIGJveC5zaXplLCBmYWxzZSwgdGhpcy5kaXNjYXJkTWRhdERhdGEpO1xuXHRcdGlmIChmb3VuZCkge1xuXHRcdFx0LyogZm91bmQgdGhlIGVuZCBvZiB0aGUgYm94ICovXG5cdFx0XHR0aGlzLnBhcnNpbmdNZGF0ID0gbnVsbDtcblx0XHRcdC8qIGxldCdzIHNlZSBpZiB3ZSBjYW4gcGFyc2UgbW9yZSBpbiB0aGlzIGJ1ZmZlciAqL1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qICdtZGF0JyBlbmQgbm90IGZvdW5kIGluIHRoZSBleGlzdGluZyBidWZmZXJzICovXG5cdFx0XHQvKiBkZXRlcm1pbmUgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGZpbGUgdG8gc3RhcnQgcGFyc2luZyBmcm9tICovXG5cdFx0XHRpZiAoIXRoaXMubW9vdlN0YXJ0Rm91bmQpIHtcblx0XHRcdFx0LyogbW9vdiBub3QgZmluZCB5ZXQsIFxuXHRcdFx0XHQgICB0aGUgZmlsZSBwcm9iYWJseSBoYXMgJ21kYXQnIGF0IHRoZSBiZWdpbm5pbmcsIGFuZCAnbW9vdicgYXQgdGhlIGVuZCwgXG5cdFx0XHRcdCAgIGluZGljYXRlIHRoYXQgdGhlIGRvd25sb2FkZXIgc2hvdWxkIG5vdCB0cnkgdG8gZG93bmxvYWQgdGhvc2UgYnl0ZXMgbm93ICovXG5cdFx0XHRcdHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSBib3guc3RhcnQgKyBib3guc2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIHdlIGhhdmUgdGhlIHN0YXJ0IG9mIHRoZSBtb292IGJveCwgXG5cdFx0XHRcdCAgIHRoZSBuZXh0IGJ5dGVzIHNob3VsZCB0cnkgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgJ21kYXQnICovXG5cdFx0XHRcdHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSB0aGlzLnN0cmVhbS5maW5kRW5kQ29udGlndW91c0J1ZigpO1xuXHRcdFx0fVxuXHRcdFx0Lyogbm90IG11Y2ggd2UgY2FuIGRvLCB3YWl0IGZvciBtb3JlIGJ1ZmZlcnMgdG8gYXJyaXZlICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8qIGJveCBpcyBpbmNvbXBsZXRlLCB3ZSBtYXkgbm90IGV2ZW4ga25vdyBpdHMgdHlwZSAqL1xuXHRcdGlmIChyZXQudHlwZSA9PT0gXCJtb292XCIpIHsgXG5cdFx0XHQvKiB0aGUgaW5jb21wbGV0ZSBib3ggaXMgYSAnbW9vdicgYm94ICovXG5cdFx0XHR0aGlzLm1vb3ZTdGFydEZvdW5kID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLm1kYXRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLmlzUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKiBlaXRoZXIgaXQncyBub3QgYW4gbWRhdCBib3ggKGFuZCB3ZSBuZWVkIHRvIHBhcnNlIGl0LCB3ZSBjYW5ub3Qgc2tpcCBpdClcblx0XHQgICAoVE9ETzogd2UgY291bGQgc2tpcCAnZnJlZScgYm94ZXMgLi4uKVxuXHRcdFx0ICAgb3Igd2UgZGlkIG5vdCBoYXZlIGVub3VnaCBkYXRhIHRvIHBhcnNlIHRoZSB0eXBlIGFuZCBzaXplIG9mIHRoZSBib3gsIFxuXHRcdCAgIHdlIHRyeSB0byBjb25jYXRlbmF0ZSB0aGUgY3VycmVudCBidWZmZXIgd2l0aCB0aGUgbmV4dCBidWZmZXIgdG8gcmVzdGFydCBwYXJzaW5nICovXG5cdFx0bWVyZ2VkID0gKHRoaXMuc3RyZWFtLm1lcmdlTmV4dEJ1ZmZlciA/IHRoaXMuc3RyZWFtLm1lcmdlTmV4dEJ1ZmZlcigpIDogZmFsc2UpO1xuXHRcdGlmIChtZXJnZWQpIHtcblx0XHRcdC8qIFRoZSBuZXh0IGJ1ZmZlciB3YXMgY29udGlndW91cywgdGhlIG1lcmdpbmcgc3VjY2VlZGVkLFxuXHRcdFx0ICAgd2UgY2FuIG5vdyBjb250aW51ZSBwYXJzaW5nLCBcblx0XHRcdCAgIHRoZSBuZXh0IGJlc3QgcG9zaXRpb24gdG8gcGFyc2UgaXMgYXQgdGhlIGVuZCBvZiB0aGlzIG5ldyBidWZmZXIgKi9cblx0XHRcdHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSB0aGlzLnN0cmVhbS5nZXRFbmRQb3NpdGlvbigpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIHdlIGNhbm5vdCBjb25jYXRlbmF0ZSBleGlzdGluZyBidWZmZXJzIGJlY2F1c2UgdGhleSBhcmUgbm90IGNvbnRpZ3VvdXMgb3IgYmVjYXVzZSB0aGVyZSBpcyBubyBhZGRpdGlvbmFsIGJ1ZmZlciAqL1xuXHRcdFx0LyogVGhlIG5leHQgYmVzdCBwb3NpdGlvbiB0byBwYXJzZSBpcyBzdGlsbCBhdCB0aGUgZW5kIG9mIHRoaXMgb2xkIGJ1ZmZlciAqL1xuXHRcdFx0aWYgKCFyZXQudHlwZSkge1xuXHRcdFx0XHQvKiBUaGVyZSB3ZXJlIG5vdCBlbm91Z2ggYnl0ZXMgaW4gdGhlIGJ1ZmZlciB0byBwYXJzZSB0aGUgYm94IHR5cGUgYW5kIGxlbmd0aCxcblx0XHRcdFx0ICAgdGhlIG5leHQgZmV0Y2ggc2hvdWxkIHJldHJpZXZlIHRob3NlIG1pc3NpbmcgYnl0ZXMsIGkuZS4gdGhlIG5leHQgYnl0ZXMgYWZ0ZXIgdGhpcyBidWZmZXIgKi9cblx0XHRcdFx0dGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldEVuZFBvc2l0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiB3ZSBoYWQgZW5vdWdoIGJ5dGVzIHRvIHBhcnNlIHNpemUgYW5kIHR5cGUgb2YgdGhlIGluY29tcGxldGUgYm94XG5cdFx0XHRcdCAgIGlmIHdlIGhhdmVuJ3QgZm91bmQgeWV0IHRoZSBtb292IGJveCwgc2tpcCB0aGlzIG9uZSBhbmQgdHJ5IHRoZSBuZXh0IG9uZSBcblx0XHRcdFx0ICAgaWYgd2UgaGF2ZSBmb3VuZCB0aGUgbW9vdiBib3gsIGxldCdzIGNvbnRpbnVlIGxpbmVhciBwYXJzaW5nICovXG5cdFx0XHRcdGlmICh0aGlzLm1vb3ZTdGFydEZvdW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldEVuZFBvc2l0aW9uKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5uZXh0UGFyc2VQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldFBvc2l0aW9uKCkgKyByZXQuc2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuaGFzSW5jb21wbGV0ZU1kYXQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5wYXJzaW5nTWRhdCAhPT0gbnVsbCk7XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5wcm9jZXNzSW5jb21wbGV0ZU1kYXQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBib3g7XG5cdHZhciBmb3VuZDtcblx0XG5cdC8qIHdlIGFyZSBpbiB0aGUgcGFyc2luZyBvZiBhbiBpbmNvbXBsZXRlIG1kYXQgYm94ICovXG5cdGJveCA9IHRoaXMucGFyc2luZ01kYXQ7XG5cblx0Zm91bmQgPSB0aGlzLnN0cmVhbS5zZWVrKGJveC5zdGFydCArIGJveC5zaXplLCBmYWxzZSwgdGhpcy5kaXNjYXJkTWRhdERhdGEpO1xuXHRpZiAoZm91bmQpIHtcblx0XHRMb2cuZGVidWcoXCJJU09GaWxlXCIsIFwiRm91bmQgJ21kYXQnIGVuZCBpbiBidWZmZXJlZCBkYXRhXCIpO1xuXHRcdC8qIHRoZSBlbmQgb2YgdGhlIG1kYXQgaGFzIGJlZW4gZm91bmQgKi8gXG5cdFx0dGhpcy5wYXJzaW5nTWRhdCA9IG51bGw7XG5cdFx0Lyogd2UgY2FuIHBhcnNlIG1vcmUgaW4gdGhpcyBidWZmZXIgKi9cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIHtcblx0XHQvKiB3ZSBkb24ndCBoYXZlIHRoZSBlbmQgb2YgdGhpcyBtZGF0IHlldCwgXG5cdFx0ICAgaW5kaWNhdGUgdGhhdCB0aGUgbmV4dCBieXRlIHRvIGZldGNoIGlzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlcnMgd2UgaGF2ZSBzbyBmYXIsIFxuXHRcdCAgIHJldHVybiBhbmQgd2FpdCBmb3IgbW9yZSBidWZmZXIgdG8gY29tZSAqL1xuXHRcdHRoaXMubmV4dFBhcnNlUG9zaXRpb24gPSB0aGlzLnN0cmVhbS5maW5kRW5kQ29udGlndW91c0J1ZigpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUucmVzdG9yZVBhcnNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0LyogUmVwb3NpdGlvbiBhdCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIGJveCBub3QgZW50aXJlbHkgcGFyc2VkICovXG5cdHJldHVybiB0aGlzLnN0cmVhbS5zZWVrKHRoaXMubGFzdEJveFN0YXJ0UG9zaXRpb24sIHRydWUsIHRoaXMuZGlzY2FyZE1kYXREYXRhKTtcbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLnNhdmVQYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdC8qIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm94IHN0YXJ0IGluIGNhc2Ugd2UgbmVlZCB0byByb2xsIGJhY2sgKGlmIHRoZSBib3ggaXMgaW5jb21wbGV0ZSkgKi9cblx0dGhpcy5sYXN0Qm94U3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RyZWFtLmdldFBvc2l0aW9uKCk7XHRcbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLnVwZGF0ZVVzZWRCeXRlcyA9IGZ1bmN0aW9uKGJveCwgcmV0KSB7XG5cdGlmICh0aGlzLnN0cmVhbS5hZGRVc2VkQnl0ZXMpIHtcblx0XHRpZiAoYm94LnR5cGUgPT09IFwibWRhdFwiKSB7XG5cdFx0XHQvKiBmb3IgYW4gbWRhdCBib3gsIG9ubHkgaXRzIGhlYWRlciBpcyBjb25zaWRlcmVkIHVzZWQsIG90aGVyIGJ5dGVzIHdpbGwgYmUgdXNlZCB3aGVuIHNhbXBsZSBkYXRhIGlzIHJlcXVlc3RlZCAqL1xuXHRcdFx0dGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzKGJveC5oZHJfc2l6ZSk7XG5cdFx0XHRpZiAodGhpcy5kaXNjYXJkTWRhdERhdGEpIHtcblx0XHRcdFx0dGhpcy5zdHJlYW0uYWRkVXNlZEJ5dGVzKGJveC5zaXplLWJveC5oZHJfc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIGZvciBhbGwgb3RoZXIgYm94ZXMsIHRoZSBlbnRpcmUgYm94IGRhdGEgaXMgY29uc2lkZXJlZCB1c2VkICovXG5cdFx0XHR0aGlzLnN0cmVhbS5hZGRVc2VkQnl0ZXMoYm94LnNpemUpO1xuXHRcdH1cdFxuXHR9XG59O1xuLy8gZmlsZTpzcmMvaXNvZmlsZS1hZHZhbmNlZC1jcmVhdGlvbi5qc1xuSVNPRmlsZS5wcm90b3R5cGUuYWRkID0gQm94UGFyc2VyLkJveC5wcm90b3R5cGUuYWRkO1xuSVNPRmlsZS5wcm90b3R5cGUuYWRkQm94ID0gQm94UGFyc2VyLkJveC5wcm90b3R5cGUuYWRkQm94O1xuXG5JU09GaWxlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKF9vcHRpb25zKSB7XG5cdHZhciBvcHRpb25zID0gX29wdGlvbnMgfHwge307IFxuXHR0aGlzLmFkZChcImZ0eXBcIikuc2V0KFwibWFqb3JfYnJhbmRcIiwgKG9wdGlvbnMuYnJhbmRzICYmIG9wdGlvbnMuYnJhbmRzWzBdKSB8fCBcImlzbzRcIilcblx0XHRcdFx0XHRcdFx0ICAgLnNldChcIm1pbm9yX3ZlcnNpb25cIiwgMClcblx0XHRcdFx0XHRcdFx0ICAgLnNldChcImNvbXBhdGlibGVfYnJhbmRzXCIsIG9wdGlvbnMuYnJhbmRzIHx8IFtcImlzbzRcIl0pO1xuXHR2YXIgbW9vdiA9IHRoaXMuYWRkKFwibW9vdlwiKTtcblx0bW9vdi5hZGQoXCJtdmhkXCIpLnNldChcInRpbWVzY2FsZVwiLCBvcHRpb25zLnRpbWVzY2FsZSB8fCA2MDApXG5cdFx0XHRcdFx0LnNldChcInJhdGVcIiwgb3B0aW9ucy5yYXRlIHx8IDE8PDE2KVxuXHRcdFx0XHRcdC5zZXQoXCJjcmVhdGlvbl90aW1lXCIsIDApXG5cdFx0XHRcdFx0LnNldChcIm1vZGlmaWNhdGlvbl90aW1lXCIsIDApXG5cdFx0XHRcdFx0LnNldChcImR1cmF0aW9uXCIsIG9wdGlvbnMuZHVyYXRpb24gfHwgMClcblx0XHRcdFx0XHQuc2V0KFwidm9sdW1lXCIsIChvcHRpb25zLndpZHRoKSA/IDAgOiAweDAxMDApXG5cdFx0XHRcdFx0LnNldChcIm1hdHJpeFwiLCBbIDE8PDE2LCAwLCAwLCAwLCAxPDwxNiwgMCwgMCwgMCwgMHg0MDAwMDAwMF0pXG5cdFx0XHRcdFx0LnNldChcIm5leHRfdHJhY2tfaWRcIiwgMSk7XG5cdG1vb3YuYWRkKFwibXZleFwiKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIChfb3B0aW9ucykge1xuXHRpZiAoIXRoaXMubW9vdikge1xuXHRcdHRoaXMuaW5pdChfb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9OyBcblx0b3B0aW9ucy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMzIwO1xuXHRvcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDMyMDtcblx0b3B0aW9ucy5pZCA9IG9wdGlvbnMuaWQgfHwgdGhpcy5tb292Lm12aGQubmV4dF90cmFja19pZDtcblx0b3B0aW9ucy50eXBlID0gb3B0aW9ucy50eXBlIHx8IFwiYXZjMVwiO1xuXG5cdHZhciB0cmFrID0gdGhpcy5tb292LmFkZChcInRyYWtcIik7XG5cdHRoaXMubW9vdi5tdmhkLm5leHRfdHJhY2tfaWQgPSBvcHRpb25zLmlkKzE7XG5cdHRyYWsuYWRkKFwidGtoZFwiKS5zZXQoXCJmbGFnc1wiLEJveFBhcnNlci5US0hEX0ZMQUdfRU5BQkxFRCB8IFxuXHRcdFx0XHRcdFx0XHRcdCBCb3hQYXJzZXIuVEtIRF9GTEFHX0lOX01PVklFIHwgXG5cdFx0XHRcdFx0XHRcdFx0IEJveFBhcnNlci5US0hEX0ZMQUdfSU5fUFJFVklFVylcblx0XHRcdFx0XHQuc2V0KFwiY3JlYXRpb25fdGltZVwiLDApXG5cdFx0XHRcdFx0LnNldChcIm1vZGlmaWNhdGlvbl90aW1lXCIsIDApXG5cdFx0XHRcdFx0LnNldChcInRyYWNrX2lkXCIsIG9wdGlvbnMuaWQpXG5cdFx0XHRcdFx0LnNldChcImR1cmF0aW9uXCIsIG9wdGlvbnMuZHVyYXRpb24gfHwgMClcblx0XHRcdFx0XHQuc2V0KFwibGF5ZXJcIiwgb3B0aW9ucy5sYXllciB8fCAwKVxuXHRcdFx0XHRcdC5zZXQoXCJhbHRlcm5hdGVfZ3JvdXBcIiwgMClcblx0XHRcdFx0XHQuc2V0KFwidm9sdW1lXCIsIDEpXG5cdFx0XHRcdFx0LnNldChcIm1hdHJpeFwiLCBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXSlcblx0XHRcdFx0XHQuc2V0KFwid2lkdGhcIiwgb3B0aW9ucy53aWR0aClcblx0XHRcdFx0XHQuc2V0KFwiaGVpZ2h0XCIsIG9wdGlvbnMuaGVpZ2h0KTtcblxuXHR2YXIgbWRpYSA9IHRyYWsuYWRkKFwibWRpYVwiKTtcblx0bWRpYS5hZGQoXCJtZGhkXCIpLnNldChcImNyZWF0aW9uX3RpbWVcIiwgMClcblx0XHRcdFx0XHQuc2V0KFwibW9kaWZpY2F0aW9uX3RpbWVcIiwgMClcblx0XHRcdFx0XHQuc2V0KFwidGltZXNjYWxlXCIsIG9wdGlvbnMudGltZXNjYWxlIHx8IDEpXG5cdFx0XHRcdFx0LnNldChcImR1cmF0aW9uXCIsIG9wdGlvbnMubWVkaWFfZHVyYXRpb24gfHwgMClcblx0XHRcdFx0XHQuc2V0KFwibGFuZ3VhZ2VcIiwgb3B0aW9ucy5sYW5ndWFnZSB8fCBcInVuZFwiKTtcblxuXHRtZGlhLmFkZChcImhkbHJcIikuc2V0KFwiaGFuZGxlclwiLCBvcHRpb25zLmhkbHIgfHwgXCJ2aWRlXCIpXG5cdFx0XHRcdFx0LnNldChcIm5hbWVcIiwgb3B0aW9ucy5uYW1lIHx8IFwiVHJhY2sgY3JlYXRlZCB3aXRoIE1QNEJveC5qc1wiKTtcblxuXHRtZGlhLmFkZChcImVsbmdcIikuc2V0KFwiZXh0ZW5kZWRfbGFuZ3VhZ2VcIiwgb3B0aW9ucy5sYW5ndWFnZSB8fCBcImZyLUZSXCIpO1xuXG5cdHZhciBtaW5mID0gbWRpYS5hZGQoXCJtaW5mXCIpO1xuXHRpZiAoQm94UGFyc2VyW29wdGlvbnMudHlwZStcIlNhbXBsZUVudHJ5XCJdID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0dmFyIHNhbXBsZV9kZXNjcmlwdGlvbl9lbnRyeSA9IG5ldyBCb3hQYXJzZXJbb3B0aW9ucy50eXBlK1wiU2FtcGxlRW50cnlcIl0oKTtcblx0c2FtcGxlX2Rlc2NyaXB0aW9uX2VudHJ5LmRhdGFfcmVmZXJlbmNlX2luZGV4ID0gMTtcblx0dmFyIG1lZGlhX3R5cGUgPSBcIlwiO1xuXHRmb3IgKHZhciBtZWRpYVR5cGUgaW4gQm94UGFyc2VyLnNhbXBsZUVudHJ5Q29kZXMpIHtcblx0XHR2YXIgY29kZXMgPSBCb3hQYXJzZXIuc2FtcGxlRW50cnlDb2Rlc1ttZWRpYVR5cGVdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChjb2Rlcy5pbmRleE9mKG9wdGlvbnMudHlwZSkgPiAtMSkge1xuXHRcdFx0XHRtZWRpYV90eXBlID0gbWVkaWFUeXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0c3dpdGNoKG1lZGlhX3R5cGUpIHtcblx0XHRjYXNlIFwiVmlzdWFsXCI6XG5cdFx0XHRtaW5mLmFkZChcInZtaGRcIikuc2V0KFwiZ3JhcGhpY3Ntb2RlXCIsMCkuc2V0KFwib3Bjb2xvclwiLCBbIDAsIDAsIDAgXSk7XG5cdFx0XHRzYW1wbGVfZGVzY3JpcHRpb25fZW50cnkuc2V0KFwid2lkdGhcIiwgb3B0aW9ucy53aWR0aClcblx0XHRcdFx0XHRcdC5zZXQoXCJoZWlnaHRcIiwgb3B0aW9ucy5oZWlnaHQpXG5cdFx0XHRcdFx0XHQuc2V0KFwiaG9yaXpyZXNvbHV0aW9uXCIsIDB4NDg8PDE2KVxuXHRcdFx0XHRcdFx0LnNldChcInZlcnRyZXNvbHV0aW9uXCIsIDB4NDg8PDE2KVxuXHRcdFx0XHRcdFx0LnNldChcImZyYW1lX2NvdW50XCIsIDEpXG5cdFx0XHRcdFx0XHQuc2V0KFwiY29tcHJlc3Nvcm5hbWVcIiwgb3B0aW9ucy50eXBlK1wiIENvbXByZXNzb3JcIilcblx0XHRcdFx0XHRcdC5zZXQoXCJkZXB0aFwiLCAweDE4KTtcblx0XHRcdGlmIChvcHRpb25zLmF2Y0RlY29kZXJDb25maWdSZWNvcmQpIHtcblx0XHRcdFx0dmFyIGF2Y0MgPSBuZXcgQm94UGFyc2VyLmF2Y0NCb3goKTtcblx0XHRcdFx0dmFyIHN0cmVhbSA9IG5ldyBNUDRCb3hTdHJlYW0ob3B0aW9ucy5hdmNEZWNvZGVyQ29uZmlnUmVjb3JkKTtcblx0XHRcdFx0YXZjQy5wYXJzZShzdHJlYW0pO1xuXHRcdFx0XHRzYW1wbGVfZGVzY3JpcHRpb25fZW50cnkuYWRkQm94KGF2Y0MpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIkF1ZGlvXCI6XG5cdFx0XHRtaW5mLmFkZChcInNtaGRcIikuc2V0KFwiYmFsYW5jZVwiLCBvcHRpb25zLmJhbGFuY2UgfHwgMCk7XG5cdFx0XHRzYW1wbGVfZGVzY3JpcHRpb25fZW50cnkuc2V0KFwiY2hhbm5lbF9jb3VudFwiLCBvcHRpb25zLmNoYW5uZWxfY291bnQgfHwgMilcblx0XHRcdFx0XHRcdC5zZXQoXCJzYW1wbGVzaXplXCIsIG9wdGlvbnMuc2FtcGxlc2l6ZSB8fCAxNilcblx0XHRcdFx0XHRcdC5zZXQoXCJzYW1wbGVyYXRlXCIsIG9wdGlvbnMuc2FtcGxlcmF0ZSB8fCAxPDwxNik7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiSGludFwiOlxuXHRcdFx0bWluZi5hZGQoXCJobWhkXCIpOyAvLyBUT0RPOiBhZGQgcHJvcGVydGllc1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIlN1YnRpdGxlXCI6XG5cdFx0XHRtaW5mLmFkZChcInN0aGRcIik7XG5cdFx0XHRzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuXHRcdFx0XHRjYXNlIFwic3RwcFwiOlxuXHRcdFx0XHRcdHNhbXBsZV9kZXNjcmlwdGlvbl9lbnRyeS5zZXQoXCJuYW1lc3BhY2VcIiwgb3B0aW9ucy5uYW1lc3BhY2UgfHwgXCJub25hbWVzcGFjZVwiKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXQoXCJzY2hlbWFfbG9jYXRpb25cIiwgb3B0aW9ucy5zY2hlbWFfbG9jYXRpb24gfHwgXCJcIilcblx0XHRcdFx0XHRcdFx0XHQuc2V0KFwiYXV4aWxpYXJ5X21pbWVfdHlwZXNcIiwgb3B0aW9ucy5hdXhpbGlhcnlfbWltZV90eXBlcyB8fCBcIlwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJNZXRhZGF0YVwiOlxuXHRcdFx0bWluZi5hZGQoXCJubWhkXCIpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIlN5c3RlbVwiOlxuXHRcdFx0bWluZi5hZGQoXCJubWhkXCIpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdG1pbmYuYWRkKFwibm1oZFwiKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cdGlmIChvcHRpb25zLmRlc2NyaXB0aW9uKSB7XG5cdFx0c2FtcGxlX2Rlc2NyaXB0aW9uX2VudHJ5LmFkZEJveChvcHRpb25zLmRlc2NyaXB0aW9uKTtcblx0fVxuXHRpZiAob3B0aW9ucy5kZXNjcmlwdGlvbl9ib3hlcykge1xuXHRcdG9wdGlvbnMuZGVzY3JpcHRpb25fYm94ZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuXHRcdFx0c2FtcGxlX2Rlc2NyaXB0aW9uX2VudHJ5LmFkZEJveChiKTtcblx0XHR9KTtcblx0fVxuXHRtaW5mLmFkZChcImRpbmZcIikuYWRkKFwiZHJlZlwiKS5hZGRFbnRyeSgobmV3IEJveFBhcnNlcltcInVybCBCb3hcIl0oKSkuc2V0KFwiZmxhZ3NcIiwgMHgxKSk7XG5cdHZhciBzdGJsID0gbWluZi5hZGQoXCJzdGJsXCIpO1xuXHRzdGJsLmFkZChcInN0c2RcIikuYWRkRW50cnkoc2FtcGxlX2Rlc2NyaXB0aW9uX2VudHJ5KTtcblx0c3RibC5hZGQoXCJzdHRzXCIpLnNldChcInNhbXBsZV9jb3VudHNcIiwgW10pXG5cdFx0XHRcdFx0LnNldChcInNhbXBsZV9kZWx0YXNcIiwgW10pO1xuXHRzdGJsLmFkZChcInN0c2NcIikuc2V0KFwiZmlyc3RfY2h1bmtcIiwgW10pXG5cdFx0XHRcdFx0LnNldChcInNhbXBsZXNfcGVyX2NodW5rXCIsIFtdKVxuXHRcdFx0XHRcdC5zZXQoXCJzYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgW10pO1xuXHRzdGJsLmFkZChcInN0Y29cIikuc2V0KFwiY2h1bmtfb2Zmc2V0c1wiLCBbXSk7XG5cdHN0YmwuYWRkKFwic3RzelwiKS5zZXQoXCJzYW1wbGVfc2l6ZXNcIiwgW10pO1xuXG5cdHRoaXMubW9vdi5tdmV4LmFkZChcInRyZXhcIikuc2V0KFwidHJhY2tfaWRcIiwgb3B0aW9ucy5pZClcblx0XHRcdFx0XHRcdFx0ICAuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgb3B0aW9ucy5kZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCB8fCAxKVxuXHRcdFx0XHRcdFx0XHQgIC5zZXQoXCJkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblwiLCBvcHRpb25zLmRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIHx8IDApXG5cdFx0XHRcdFx0XHRcdCAgLnNldChcImRlZmF1bHRfc2FtcGxlX3NpemVcIiwgb3B0aW9ucy5kZWZhdWx0X3NhbXBsZV9zaXplIHx8IDApXG5cdFx0XHRcdFx0XHRcdCAgLnNldChcImRlZmF1bHRfc2FtcGxlX2ZsYWdzXCIsIG9wdGlvbnMuZGVmYXVsdF9zYW1wbGVfZmxhZ3MgfHwgMCk7XG5cdHRoaXMuYnVpbGRUcmFrU2FtcGxlTGlzdHModHJhayk7XG5cdHJldHVybiBvcHRpb25zLmlkO1xufTtcblxuQm94UGFyc2VyLkJveC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbihzdHJlYW1fKSB7XG5cdHZhciBzdHJlYW0gPSBzdHJlYW1fIHx8IG5ldyBEYXRhU3RyZWFtKCk7XG5cdHN0cmVhbS5lbmRpYW5uZXNzID0gRGF0YVN0cmVhbS5CSUdfRU5ESUFOO1xuXHR0aGlzLndyaXRlKHN0cmVhbSk7XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5hZGRTYW1wbGUgPSBmdW5jdGlvbiAodHJhY2tfaWQsIGRhdGEsIF9vcHRpb25zKSB7XG5cdHZhciBvcHRpb25zID0gX29wdGlvbnMgfHwge307XG5cdHZhciBzYW1wbGUgPSB7fTtcblx0dmFyIHRyYWsgPSB0aGlzLmdldFRyYWNrQnlJZCh0cmFja19pZCk7XG5cdGlmICh0cmFrID09PSBudWxsKSByZXR1cm47XG4gICAgc2FtcGxlLm51bWJlciA9IHRyYWsuc2FtcGxlcy5sZW5ndGg7XG5cdHNhbXBsZS50cmFja19pZCA9IHRyYWsudGtoZC50cmFja19pZDtcblx0c2FtcGxlLnRpbWVzY2FsZSA9IHRyYWsubWRpYS5tZGhkLnRpbWVzY2FsZTtcblx0c2FtcGxlLmRlc2NyaXB0aW9uX2luZGV4ID0gKG9wdGlvbnMuc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4ID8gb3B0aW9ucy5zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggLSAxOiAwKTtcblx0c2FtcGxlLmRlc2NyaXB0aW9uID0gdHJhay5tZGlhLm1pbmYuc3RibC5zdHNkLmVudHJpZXNbc2FtcGxlLmRlc2NyaXB0aW9uX2luZGV4XTtcblx0c2FtcGxlLmRhdGEgPSBkYXRhO1xuXHRzYW1wbGUuc2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDtcblx0c2FtcGxlLmFscmVhZHlSZWFkID0gc2FtcGxlLnNpemU7XG5cdHNhbXBsZS5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgMTtcblx0c2FtcGxlLmN0cyA9IG9wdGlvbnMuY3RzIHx8IDA7XG5cdHNhbXBsZS5kdHMgPSBvcHRpb25zLmR0cyB8fCAwO1xuXHRzYW1wbGUuaXNfc3luYyA9IG9wdGlvbnMuaXNfc3luYyB8fCBmYWxzZTtcblx0c2FtcGxlLmlzX2xlYWRpbmcgPSBvcHRpb25zLmlzX2xlYWRpbmcgfHwgMDtcblx0c2FtcGxlLmRlcGVuZHNfb24gPSBvcHRpb25zLmRlcGVuZHNfb24gfHwgMDtcblx0c2FtcGxlLmlzX2RlcGVuZGVkX29uID0gb3B0aW9ucy5pc19kZXBlbmRlZF9vbiB8fCAwO1xuXHRzYW1wbGUuaGFzX3JlZHVuZGFuY3kgPSBvcHRpb25zLmhhc19yZWR1bmRhbmN5IHx8IDA7XG5cdHNhbXBsZS5kZWdyYWRhdGlvbl9wcmlvcml0eSA9IG9wdGlvbnMuZGVncmFkYXRpb25fcHJpb3JpdHkgfHwgMDtcblx0c2FtcGxlLm9mZnNldCA9IDA7XG5cdHNhbXBsZS5zdWJzYW1wbGVzID0gb3B0aW9ucy5zdWJzYW1wbGVzO1xuXHR0cmFrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuXHR0cmFrLnNhbXBsZXNfc2l6ZSArPSBzYW1wbGUuc2l6ZTtcblx0dHJhay5zYW1wbGVzX2R1cmF0aW9uICs9IHNhbXBsZS5kdXJhdGlvbjtcblx0aWYgKCF0cmFrLmZpcnN0X2R0cykge1xuXHRcdHRyYWsuZmlyc3RfZHRzID0gb3B0aW9ucy5kdHM7XG5cdH1cblxuXHR0aGlzLnByb2Nlc3NTYW1wbGVzKCk7XG5cdFxuXHR2YXIgbW9vZiA9IHRoaXMuY3JlYXRlU2luZ2xlU2FtcGxlTW9vZihzYW1wbGUpO1xuXHR0aGlzLmFkZEJveChtb29mKTtcblx0bW9vZi5jb21wdXRlU2l6ZSgpO1xuXHQvKiBhZGp1c3RpbmcgdGhlIGRhdGFfb2Zmc2V0IG5vdyB0aGF0IHRoZSBtb29mIHNpemUgaXMga25vd24qL1xuXHRtb29mLnRyYWZzWzBdLnRydW5zWzBdLmRhdGFfb2Zmc2V0ID0gbW9vZi5zaXplKzg7IC8vOCBpcyBtZGF0IGhlYWRlclxuXHR0aGlzLmFkZChcIm1kYXRcIikuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHRyZXR1cm4gc2FtcGxlO1xufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuY3JlYXRlU2luZ2xlU2FtcGxlTW9vZiA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuXHR2YXIgc2FtcGxlX2ZsYWdzID0gMDtcblx0aWYgKHNhbXBsZS5pc19zeW5jKVxuXHRcdHNhbXBsZV9mbGFncyA9ICgxIDw8IDI1KTsgIC8vIHNhbXBsZV9kZXBlbmRzX29uX25vbmUgKEkgcGljdHVyZSlcblx0ZWxzZVxuXHRcdHNhbXBsZV9mbGFncyA9ICgxIDw8IDE2KTsgIC8vIG5vbi1zeW5jXG5cblx0dmFyIG1vb2YgPSBuZXcgQm94UGFyc2VyLm1vb2ZCb3goKTtcblx0bW9vZi5hZGQoXCJtZmhkXCIpLnNldChcInNlcXVlbmNlX251bWJlclwiLCB0aGlzLm5leHRNb29mTnVtYmVyKTtcblx0dGhpcy5uZXh0TW9vZk51bWJlcisrO1xuXHR2YXIgdHJhZiA9IG1vb2YuYWRkKFwidHJhZlwiKTtcblx0dmFyIHRyYWsgPSB0aGlzLmdldFRyYWNrQnlJZChzYW1wbGUudHJhY2tfaWQpO1xuXHR0cmFmLmFkZChcInRmaGRcIikuc2V0KFwidHJhY2tfaWRcIiwgc2FtcGxlLnRyYWNrX2lkKVxuXHRcdFx0XHRcdC5zZXQoXCJmbGFnc1wiLCBCb3hQYXJzZXIuVEZIRF9GTEFHX0RFRkFVTFRfQkFTRV9JU19NT09GKTtcblx0dHJhZi5hZGQoXCJ0ZmR0XCIpLnNldChcImJhc2VNZWRpYURlY29kZVRpbWVcIiwgKHNhbXBsZS5kdHMgLSB0cmFrLmZpcnN0X2R0cykpO1xuXHR0cmFmLmFkZChcInRydW5cIikuc2V0KFwiZmxhZ3NcIiwgQm94UGFyc2VyLlRSVU5fRkxBR1NfREFUQV9PRkZTRVQgfCBCb3hQYXJzZXIuVFJVTl9GTEFHU19EVVJBVElPTiB8IFxuXHRcdFx0XHQgXHRcdFx0XHQgIEJveFBhcnNlci5UUlVOX0ZMQUdTX1NJWkUgfCBCb3hQYXJzZXIuVFJVTl9GTEFHU19GTEFHUyB8IFxuXHRcdFx0XHQgXHRcdFx0XHQgIEJveFBhcnNlci5UUlVOX0ZMQUdTX0NUU19PRkZTRVQpXG5cdFx0XHRcdFx0LnNldChcImRhdGFfb2Zmc2V0XCIsMClcblx0XHRcdFx0XHQuc2V0KFwiZmlyc3Rfc2FtcGxlX2ZsYWdzXCIsMClcblx0XHRcdFx0XHQuc2V0KFwic2FtcGxlX2NvdW50XCIsMSlcblx0XHRcdFx0XHQuc2V0KFwic2FtcGxlX2R1cmF0aW9uXCIsW3NhbXBsZS5kdXJhdGlvbl0pXG5cdFx0XHRcdFx0LnNldChcInNhbXBsZV9zaXplXCIsW3NhbXBsZS5zaXplXSlcblx0XHRcdFx0XHQuc2V0KFwic2FtcGxlX2ZsYWdzXCIsW3NhbXBsZV9mbGFnc10pXG5cdFx0XHRcdFx0LnNldChcInNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFwiLCBbc2FtcGxlLmN0cyAtIHNhbXBsZS5kdHNdKTtcblx0cmV0dXJuIG1vb2Y7XG59O1xuXG4vLyBmaWxlOnNyYy9pc29maWxlLXNhbXBsZS1wcm9jZXNzaW5nLmpzXG4vKiBJbmRleCBvZiB0aGUgbGFzdCBtb29mIGJveCByZWNlaXZlZCAqL1xuSVNPRmlsZS5wcm90b3R5cGUubGFzdE1vb2ZJbmRleCA9IDA7XG5cbi8qIHNpemUgb2YgdGhlIGJ1ZmZlcnMgYWxsb2NhdGVkIGZvciBzYW1wbGVzICovXG5JU09GaWxlLnByb3RvdHlwZS5zYW1wbGVzRGF0YVNpemUgPSAwO1xuXG4vKiBSZXNldHMgYWxsIHNhbXBsZSB0YWJsZXMgKi9cbklTT0ZpbGUucHJvdG90eXBlLnJlc2V0VGFibGVzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaTtcblx0dmFyIHRyYWssIHN0Y28sIHN0c2MsIHN0c3osIHN0dHMsIGN0dHMsIHN0c3M7XG5cdHRoaXMuaW5pdGlhbF9kdXJhdGlvbiA9IHRoaXMubW9vdi5tdmhkLmR1cmF0aW9uO1xuXHR0aGlzLm1vb3YubXZoZC5kdXJhdGlvbiA9IDA7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLm1vb3YudHJha3MubGVuZ3RoOyBpKyspIHtcblx0XHR0cmFrID0gdGhpcy5tb292LnRyYWtzW2ldO1xuXHRcdHRyYWsudGtoZC5kdXJhdGlvbiA9IDA7XG5cdFx0dHJhay5tZGlhLm1kaGQuZHVyYXRpb24gPSAwO1xuXHRcdHN0Y28gPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0Y28gfHwgdHJhay5tZGlhLm1pbmYuc3RibC5jbzY0O1xuXHRcdHN0Y28uY2h1bmtfb2Zmc2V0cyA9IFtdO1xuXHRcdHN0c2MgPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0c2M7XG5cdFx0c3RzYy5maXJzdF9jaHVuayA9IFtdO1xuXHRcdHN0c2Muc2FtcGxlc19wZXJfY2h1bmsgPSBbXTtcblx0XHRzdHNjLnNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCA9IFtdO1xuXHRcdHN0c3ogPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0c3ogfHwgdHJhay5tZGlhLm1pbmYuc3RibC5zdHoyO1xuXHRcdHN0c3ouc2FtcGxlX3NpemVzID0gW107XG5cdFx0c3R0cyA9IHRyYWsubWRpYS5taW5mLnN0Ymwuc3R0cztcblx0XHRzdHRzLnNhbXBsZV9jb3VudHMgPSBbXTtcblx0XHRzdHRzLnNhbXBsZV9kZWx0YXMgPSBbXTtcblx0XHRjdHRzID0gdHJhay5tZGlhLm1pbmYuc3RibC5jdHRzO1xuXHRcdGlmIChjdHRzKSB7XG5cdFx0XHRjdHRzLnNhbXBsZV9jb3VudHMgPSBbXTtcblx0XHRcdGN0dHMuc2FtcGxlX29mZnNldHMgPSBbXTtcblx0XHR9XG5cdFx0c3RzcyA9IHRyYWsubWRpYS5taW5mLnN0Ymwuc3Rzcztcblx0XHR2YXIgayA9IHRyYWsubWRpYS5taW5mLnN0YmwuYm94ZXMuaW5kZXhPZihzdHNzKTtcblx0XHRpZiAoayAhPSAtMSkgdHJhay5tZGlhLm1pbmYuc3RibC5ib3hlc1trXSA9IG51bGw7XG5cdH1cbn07XG5cbklTT0ZpbGUuaW5pdFNhbXBsZUdyb3VwcyA9IGZ1bmN0aW9uKHRyYWssIHRyYWYsIHNiZ3BzLCB0cmFrX3NncGRzLCB0cmFmX3NncGRzKSB7XG5cdHZhciBsO1xuXHR2YXIgaztcblx0dmFyIHNhbXBsZV9ncm91cF9pbmZvO1xuXHR2YXIgc2FtcGxlX2dyb3VwX2tleTtcblx0ZnVuY3Rpb24gU2FtcGxlR3JvdXBJbmZvKF90eXBlLCBfcGFyYW1ldGVyLCBfc2JncCkge1xuXHRcdHRoaXMuZ3JvdXBpbmdfdHlwZSA9IF90eXBlO1xuXHRcdHRoaXMuZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSBfcGFyYW1ldGVyO1xuXHRcdHRoaXMuc2JncCA9IF9zYmdwO1xuXHRcdHRoaXMubGFzdF9zYW1wbGVfaW5fcnVuID0gLTE7XG5cdFx0dGhpcy5lbnRyeV9pbmRleCA9IC0xO1x0XHRcblx0fVxuXHRpZiAodHJhZikge1xuXHRcdHRyYWYuc2FtcGxlX2dyb3Vwc19pbmZvID0gW107XG5cdH0gXG5cdGlmICghdHJhay5zYW1wbGVfZ3JvdXBzX2luZm8pIHtcblx0XHR0cmFrLnNhbXBsZV9ncm91cHNfaW5mbyA9IFtdO1xuXHR9XG5cdGZvciAoayA9IDA7IGsgPCBzYmdwcy5sZW5ndGg7IGsrKykge1xuXHRcdHNhbXBsZV9ncm91cF9rZXkgPSBzYmdwc1trXS5ncm91cGluZ190eXBlICtcIi9cIisgc2JncHNba10uZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXI7XG5cdFx0c2FtcGxlX2dyb3VwX2luZm8gPSBuZXcgU2FtcGxlR3JvdXBJbmZvKHNiZ3BzW2tdLmdyb3VwaW5nX3R5cGUsIHNiZ3BzW2tdLmdyb3VwaW5nX3R5cGVfcGFyYW1ldGVyLCBzYmdwc1trXSk7XG5cdFx0aWYgKHRyYWYpIHtcblx0XHRcdHRyYWYuc2FtcGxlX2dyb3Vwc19pbmZvW3NhbXBsZV9ncm91cF9rZXldID0gc2FtcGxlX2dyb3VwX2luZm87XG5cdFx0fVxuXHRcdGlmICghdHJhay5zYW1wbGVfZ3JvdXBzX2luZm9bc2FtcGxlX2dyb3VwX2tleV0pIHtcblx0XHRcdHRyYWsuc2FtcGxlX2dyb3Vwc19pbmZvW3NhbXBsZV9ncm91cF9rZXldID0gc2FtcGxlX2dyb3VwX2luZm87XG5cdFx0fVxuXHRcdGZvciAobD0wOyBsIDx0cmFrX3NncGRzLmxlbmd0aDsgbCsrKSB7XG5cdFx0XHRpZiAodHJha19zZ3Bkc1tsXS5ncm91cGluZ190eXBlID09PSBzYmdwc1trXS5ncm91cGluZ190eXBlKSB7XG5cdFx0XHRcdHNhbXBsZV9ncm91cF9pbmZvLmRlc2NyaXB0aW9uID0gdHJha19zZ3Bkc1tsXTtcblx0XHRcdFx0c2FtcGxlX2dyb3VwX2luZm8uZGVzY3JpcHRpb24udXNlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0cmFmX3NncGRzKSB7XG5cdFx0XHRmb3IgKGw9MDsgbCA8dHJhZl9zZ3Bkcy5sZW5ndGg7IGwrKykge1xuXHRcdFx0XHRpZiAodHJhZl9zZ3Bkc1tsXS5ncm91cGluZ190eXBlID09PSBzYmdwc1trXS5ncm91cGluZ190eXBlKSB7XG5cdFx0XHRcdFx0c2FtcGxlX2dyb3VwX2luZm8uZnJhZ21lbnRfZGVzY3JpcHRpb24gPSB0cmFmX3NncGRzW2xdO1xuXHRcdFx0XHRcdHNhbXBsZV9ncm91cF9pbmZvLmZyYWdtZW50X2Rlc2NyaXB0aW9uLnVzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNhbXBsZV9ncm91cF9pbmZvLmlzX2ZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVx0XHRcdFxuXHRcdH1cblx0fVxuXHRpZiAoIXRyYWYpIHtcblx0XHRmb3IgKGsgPSAwOyBrIDwgdHJha19zZ3Bkcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0aWYgKCF0cmFrX3NncGRzW2tdLnVzZWQgJiYgdHJha19zZ3Bkc1trXS52ZXJzaW9uID49IDIpIHtcblx0XHRcdFx0c2FtcGxlX2dyb3VwX2tleSA9IHRyYWtfc2dwZHNba10uZ3JvdXBpbmdfdHlwZSArXCIvMFwiO1xuXHRcdFx0XHRzYW1wbGVfZ3JvdXBfaW5mbyA9IG5ldyBTYW1wbGVHcm91cEluZm8odHJha19zZ3Bkc1trXS5ncm91cGluZ190eXBlLCAwKTtcblx0XHRcdFx0aWYgKCF0cmFrLnNhbXBsZV9ncm91cHNfaW5mb1tzYW1wbGVfZ3JvdXBfa2V5XSkge1xuXHRcdFx0XHRcdHRyYWsuc2FtcGxlX2dyb3Vwc19pbmZvW3NhbXBsZV9ncm91cF9rZXldID0gc2FtcGxlX2dyb3VwX2luZm87XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKHRyYWZfc2dwZHMpIHtcblx0XHRcdGZvciAoayA9IDA7IGsgPCB0cmFmX3NncGRzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdGlmICghdHJhZl9zZ3Bkc1trXS51c2VkICYmIHRyYWZfc2dwZHNba10udmVyc2lvbiA+PSAyKSB7XG5cdFx0XHRcdFx0c2FtcGxlX2dyb3VwX2tleSA9IHRyYWZfc2dwZHNba10uZ3JvdXBpbmdfdHlwZSArXCIvMFwiO1xuXHRcdFx0XHRcdHNhbXBsZV9ncm91cF9pbmZvID0gbmV3IFNhbXBsZUdyb3VwSW5mbyh0cmFmX3NncGRzW2tdLmdyb3VwaW5nX3R5cGUsIDApO1xuXHRcdFx0XHRcdHNhbXBsZV9ncm91cF9pbmZvLmlzX2ZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAoIXRyYWYuc2FtcGxlX2dyb3Vwc19pbmZvW3NhbXBsZV9ncm91cF9rZXldKSB7XG5cdFx0XHRcdFx0XHR0cmFmLnNhbXBsZV9ncm91cHNfaW5mb1tzYW1wbGVfZ3JvdXBfa2V5XSA9IHNhbXBsZV9ncm91cF9pbmZvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuSVNPRmlsZS5zZXRTYW1wbGVHcm91cFByb3BlcnRpZXMgPSBmdW5jdGlvbih0cmFrLCBzYW1wbGUsIHNhbXBsZV9udW1iZXIsIHNhbXBsZV9ncm91cHNfaW5mbykge1xuXHR2YXIgaztcblx0dmFyIGluZGV4O1xuXHRzYW1wbGUuc2FtcGxlX2dyb3VwcyA9IFtdO1xuXHRmb3IgKGsgaW4gc2FtcGxlX2dyb3Vwc19pbmZvKSB7XG5cdFx0c2FtcGxlLnNhbXBsZV9ncm91cHNba10gPSB7fTtcblx0XHRzYW1wbGUuc2FtcGxlX2dyb3Vwc1trXS5ncm91cGluZ190eXBlID0gc2FtcGxlX2dyb3Vwc19pbmZvW2tdLmdyb3VwaW5nX3R5cGU7XG5cdFx0c2FtcGxlLnNhbXBsZV9ncm91cHNba10uZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXIgPSBzYW1wbGVfZ3JvdXBzX2luZm9ba10uZ3JvdXBpbmdfdHlwZV9wYXJhbWV0ZXI7XG5cdFx0aWYgKHNhbXBsZV9udW1iZXIgPj0gc2FtcGxlX2dyb3Vwc19pbmZvW2tdLmxhc3Rfc2FtcGxlX2luX3J1bikge1xuXHRcdFx0aWYgKHNhbXBsZV9ncm91cHNfaW5mb1trXS5sYXN0X3NhbXBsZV9pbl9ydW4gPCAwKSB7XG5cdFx0XHRcdHNhbXBsZV9ncm91cHNfaW5mb1trXS5sYXN0X3NhbXBsZV9pbl9ydW4gPSAwO1xuXHRcdFx0fVxuXHRcdFx0c2FtcGxlX2dyb3Vwc19pbmZvW2tdLmVudHJ5X2luZGV4Kys7XHRcblx0XHRcdGlmIChzYW1wbGVfZ3JvdXBzX2luZm9ba10uZW50cnlfaW5kZXggPD0gc2FtcGxlX2dyb3Vwc19pbmZvW2tdLnNiZ3AuZW50cmllcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHNhbXBsZV9ncm91cHNfaW5mb1trXS5sYXN0X3NhbXBsZV9pbl9ydW4gKz0gc2FtcGxlX2dyb3Vwc19pbmZvW2tdLnNiZ3AuZW50cmllc1tzYW1wbGVfZ3JvdXBzX2luZm9ba10uZW50cnlfaW5kZXhdLnNhbXBsZV9jb3VudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNhbXBsZV9ncm91cHNfaW5mb1trXS5lbnRyeV9pbmRleCA8PSBzYW1wbGVfZ3JvdXBzX2luZm9ba10uc2JncC5lbnRyaWVzLmxlbmd0aCAtIDEpIHtcblx0XHRcdHNhbXBsZS5zYW1wbGVfZ3JvdXBzW2tdLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID0gc2FtcGxlX2dyb3Vwc19pbmZvW2tdLnNiZ3AuZW50cmllc1tzYW1wbGVfZ3JvdXBzX2luZm9ba10uZW50cnlfaW5kZXhdLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzYW1wbGUuc2FtcGxlX2dyb3Vwc1trXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA9IC0xOyAvLyBzcGVjaWFsIHZhbHVlIGZvciBub3QgZGVmaW5lZFxuXHRcdH1cblx0XHRpZiAoc2FtcGxlLnNhbXBsZV9ncm91cHNba10uZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggIT09IDApIHtcblx0XHRcdHZhciBkZXNjcmlwdGlvbjtcblx0XHRcdGlmIChzYW1wbGVfZ3JvdXBzX2luZm9ba10uZnJhZ21lbnRfZGVzY3JpcHRpb24pIHtcblx0XHRcdFx0ZGVzY3JpcHRpb24gPSBzYW1wbGVfZ3JvdXBzX2luZm9ba10uZnJhZ21lbnRfZGVzY3JpcHRpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXNjcmlwdGlvbiA9IHNhbXBsZV9ncm91cHNfaW5mb1trXS5kZXNjcmlwdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmIChzYW1wbGUuc2FtcGxlX2dyb3Vwc1trXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA+IDApIHtcblx0XHRcdFx0aWYgKHNhbXBsZS5zYW1wbGVfZ3JvdXBzW2tdLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4ID4gNjU1MzUpIHtcblx0XHRcdFx0XHRpbmRleCA9IChzYW1wbGUuc2FtcGxlX2dyb3Vwc1trXS5ncm91cF9kZXNjcmlwdGlvbl9pbmRleCA+PiAxNiktMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbmRleCA9IHNhbXBsZS5zYW1wbGVfZ3JvdXBzW2tdLmdyb3VwX2Rlc2NyaXB0aW9uX2luZGV4LTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRlc2NyaXB0aW9uICYmIGluZGV4ID49IDApIHtcblx0XHRcdFx0XHRzYW1wbGUuc2FtcGxlX2dyb3Vwc1trXS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLmVudHJpZXNbaW5kZXhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZGVzY3JpcHRpb24gJiYgZGVzY3JpcHRpb24udmVyc2lvbiA+PSAyKSB7XG5cdFx0XHRcdFx0aWYgKGRlc2NyaXB0aW9uLmRlZmF1bHRfZ3JvdXBfZGVzY3JpcHRpb25faW5kZXggPiAwKSB7XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0c2FtcGxlLnNhbXBsZV9ncm91cHNba10uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5lbnRyaWVzW2Rlc2NyaXB0aW9uLmRlZmF1bHRfZ3JvdXBfZGVzY3JpcHRpb25faW5kZXgtMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5JU09GaWxlLnByb2Nlc3Nfc2R0cCA9IGZ1bmN0aW9uIChzZHRwLCBzYW1wbGUsIG51bWJlcikge1xuXHRpZiAoIXNhbXBsZSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc2R0cCkge1xuXHRcdHNhbXBsZS5pc19sZWFkaW5nID0gc2R0cC5pc19sZWFkaW5nW251bWJlcl07XG5cdFx0c2FtcGxlLmRlcGVuZHNfb24gPSBzZHRwLnNhbXBsZV9kZXBlbmRzX29uW251bWJlcl07XG5cdFx0c2FtcGxlLmlzX2RlcGVuZGVkX29uID0gc2R0cC5zYW1wbGVfaXNfZGVwZW5kZWRfb25bbnVtYmVyXTtcblx0XHRzYW1wbGUuaGFzX3JlZHVuZGFuY3kgPSBzZHRwLnNhbXBsZV9oYXNfcmVkdW5kYW5jeVtudW1iZXJdO1xuXHR9IGVsc2Uge1xuXHRcdHNhbXBsZS5pc19sZWFkaW5nID0gMDtcblx0XHRzYW1wbGUuZGVwZW5kc19vbiA9IDA7XG5cdFx0c2FtcGxlLmlzX2RlcGVuZGVkX29uID0gMDtcblx0XHRzYW1wbGUuaGFzX3JlZHVuZGFuY3kgPSAwO1xuXHR9XHRcbn07XG5cbi8qIEJ1aWxkIGluaXRpYWwgc2FtcGxlIGxpc3QgZnJvbSAgc2FtcGxlIHRhYmxlcyAqL1xuSVNPRmlsZS5wcm90b3R5cGUuYnVpbGRTYW1wbGVMaXN0cyA9IGZ1bmN0aW9uKCkge1x0XG5cdHZhciBpO1xuXHR2YXIgdHJhaztcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMubW9vdi50cmFrcy5sZW5ndGg7IGkrKykge1xuXHRcdHRyYWsgPSB0aGlzLm1vb3YudHJha3NbaV07XG5cdFx0dGhpcy5idWlsZFRyYWtTYW1wbGVMaXN0cyh0cmFrKTtcblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuYnVpbGRUcmFrU2FtcGxlTGlzdHMgPSBmdW5jdGlvbih0cmFrKSB7XHRcblx0dmFyIGo7XG5cdHZhciBzdGNvLCBzdHNjLCBzdHN6LCBzdHRzLCBjdHRzLCBzdHNzLCBzdHNkLCBzdWJzLCBzYmdwcywgc2dwZHMsIHN0ZHA7XG5cdHZhciBjaHVua19ydW5faW5kZXgsIGNodW5rX2luZGV4LCBsYXN0X2NodW5rX2luX3J1biwgb2Zmc2V0X2luX2NodW5rLCBsYXN0X3NhbXBsZV9pbl9jaHVuaztcblx0dmFyIGxhc3Rfc2FtcGxlX2luX3N0dHNfcnVuLCBzdHRzX3J1bl9pbmRleCwgbGFzdF9zYW1wbGVfaW5fY3R0c19ydW4sIGN0dHNfcnVuX2luZGV4LCBsYXN0X3N0c3NfaW5kZXgsIHN1YnNfZW50cnlfaW5kZXgsIGxhc3Rfc3Vic19zYW1wbGVfaW5kZXg7XG5cblx0dHJhay5zYW1wbGVzID0gW107XG5cdHRyYWsuc2FtcGxlc19kdXJhdGlvbiA9IDA7XG5cdHRyYWsuc2FtcGxlc19zaXplID0gMDtcblx0c3RjbyA9IHRyYWsubWRpYS5taW5mLnN0Ymwuc3RjbyB8fCB0cmFrLm1kaWEubWluZi5zdGJsLmNvNjQ7XG5cdHN0c2MgPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0c2M7XG5cdHN0c3ogPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0c3ogfHwgdHJhay5tZGlhLm1pbmYuc3RibC5zdHoyO1xuXHRzdHRzID0gdHJhay5tZGlhLm1pbmYuc3RibC5zdHRzO1xuXHRjdHRzID0gdHJhay5tZGlhLm1pbmYuc3RibC5jdHRzO1xuXHRzdHNzID0gdHJhay5tZGlhLm1pbmYuc3RibC5zdHNzO1xuXHRzdHNkID0gdHJhay5tZGlhLm1pbmYuc3RibC5zdHNkO1xuXHRzdWJzID0gdHJhay5tZGlhLm1pbmYuc3RibC5zdWJzO1xuXHRzdGRwID0gdHJhay5tZGlhLm1pbmYuc3RibC5zdGRwO1xuXHRzYmdwcyA9IHRyYWsubWRpYS5taW5mLnN0Ymwuc2JncHM7XG5cdHNncGRzID0gdHJhay5tZGlhLm1pbmYuc3RibC5zZ3Bkcztcblx0XG5cdGxhc3Rfc2FtcGxlX2luX3N0dHNfcnVuID0gLTE7XG5cdHN0dHNfcnVuX2luZGV4ID0gLTE7XG5cdGxhc3Rfc2FtcGxlX2luX2N0dHNfcnVuID0gLTE7XG5cdGN0dHNfcnVuX2luZGV4ID0gLTE7XG5cdGxhc3Rfc3Rzc19pbmRleCA9IDA7XG5cdHN1YnNfZW50cnlfaW5kZXggPSAwO1xuXHRsYXN0X3N1YnNfc2FtcGxlX2luZGV4ID0gMDtcdFx0XG5cblx0SVNPRmlsZS5pbml0U2FtcGxlR3JvdXBzKHRyYWssIG51bGwsIHNiZ3BzLCBzZ3Bkcyk7XG5cblx0aWYgKHR5cGVvZiBzdHN6ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Lyogd2UgYnVpbGQgdGhlIHNhbXBsZXMgb25lIGJ5IG9uZSBhbmQgY29tcHV0ZSB0aGVpciBwcm9wZXJ0aWVzICovXG5cdGZvciAoaiA9IDA7IGogPCBzdHN6LnNhbXBsZV9zaXplcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBzYW1wbGUgPSB7fTtcblx0XHRzYW1wbGUubnVtYmVyID0gajtcblx0XHRzYW1wbGUudHJhY2tfaWQgPSB0cmFrLnRraGQudHJhY2tfaWQ7XG5cdFx0c2FtcGxlLnRpbWVzY2FsZSA9IHRyYWsubWRpYS5tZGhkLnRpbWVzY2FsZTtcblx0XHRzYW1wbGUuYWxyZWFkeVJlYWQgPSAwO1xuXHRcdHRyYWsuc2FtcGxlc1tqXSA9IHNhbXBsZTtcblx0XHQvKiBzaXplIGNhbiBiZSBrbm93biBkaXJlY3RseSAqL1xuXHRcdHNhbXBsZS5zaXplID0gc3Rzei5zYW1wbGVfc2l6ZXNbal07XG5cdFx0dHJhay5zYW1wbGVzX3NpemUgKz0gc2FtcGxlLnNpemU7XG5cdFx0LyogY29tcHV0aW5nIGNodW5rLWJhc2VkIHByb3BlcnRpZXMgKG9mZnNldCwgc2FtcGxlIGRlc2NyaXB0aW9uIGluZGV4KSovXG5cdFx0aWYgKGogPT09IDApIHtcdFx0XHRcdFxuXHRcdFx0Y2h1bmtfaW5kZXggPSAxOyAvKiB0aGUgZmlyc3Qgc2FtcGxlIGlzIGluIHRoZSBmaXJzdCBjaHVuayAoY2h1bmsgaW5kZXhlcyBhcmUgMS1iYXNlZCkgKi9cblx0XHRcdGNodW5rX3J1bl9pbmRleCA9IDA7IC8qIHRoZSBmaXJzdCBjaHVuayBpcyB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIGZpcnN0X2NodW5rIHRhYmxlICovXG5cdFx0XHRzYW1wbGUuY2h1bmtfaW5kZXggPSBjaHVua19pbmRleDtcblx0XHRcdHNhbXBsZS5jaHVua19ydW5faW5kZXggPSBjaHVua19ydW5faW5kZXg7XG5cdFx0XHRsYXN0X3NhbXBsZV9pbl9jaHVuayA9IHN0c2Muc2FtcGxlc19wZXJfY2h1bmtbY2h1bmtfcnVuX2luZGV4XTtcblx0XHRcdG9mZnNldF9pbl9jaHVuayA9IDA7XG5cblx0XHRcdC8qIElzIHRoZXJlIGFub3RoZXIgZW50cnkgaW4gdGhlIGZpcnN0X2NodW5rIHRhYmxlID8gKi9cblx0XHRcdGlmIChjaHVua19ydW5faW5kZXggKyAxIDwgc3RzYy5maXJzdF9jaHVuay5sZW5ndGgpIHtcblx0XHRcdFx0LyogVGhlIGxhc3QgY2h1bmsgaW4gdGhlIHJ1biBpcyB0aGUgY2h1bmsgYmVmb3JlIHRoZSBuZXh0IGZpcnN0IGNodW5rICovXG5cdFx0XHRcdGxhc3RfY2h1bmtfaW5fcnVuID0gc3RzYy5maXJzdF9jaHVua1tjaHVua19ydW5faW5kZXgrMV0tMTsgXHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIFRoZXJlIGlzIG9ubHkgb25lIGVudHJ5IGluIHRoZSB0YWJsZSwgaXQgaXMgdmFsaWQgZm9yIGFsbCBmdXR1cmUgY2h1bmtzKi9cblx0XHRcdFx0bGFzdF9jaHVua19pbl9ydW4gPSBJbmZpbml0eTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGogPCBsYXN0X3NhbXBsZV9pbl9jaHVuaykge1xuXHRcdFx0XHQvKiB0aGUgc2FtcGxlIGlzIHN0aWxsIGluIHRoZSBjdXJyZW50IGNodW5rICovXG5cdFx0XHRcdHNhbXBsZS5jaHVua19pbmRleCA9IGNodW5rX2luZGV4O1xuXHRcdFx0XHRzYW1wbGUuY2h1bmtfcnVuX2luZGV4ID0gY2h1bmtfcnVuX2luZGV4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogdGhlIHNhbXBsZSBpcyBpbiB0aGUgbmV4dCBjaHVuayAqL1xuXHRcdFx0XHRjaHVua19pbmRleCsrO1xuXHRcdFx0XHRzYW1wbGUuY2h1bmtfaW5kZXggPSBjaHVua19pbmRleDtcblx0XHRcdFx0LyogcmVzZXQgdGhlIGFjY3VtdWxhdGVkIG9mZnNldCBpbiB0aGUgY2h1bmsgKi9cblx0XHRcdFx0b2Zmc2V0X2luX2NodW5rID0gMDtcblx0XHRcdFx0aWYgKGNodW5rX2luZGV4IDw9IGxhc3RfY2h1bmtfaW5fcnVuKSA7IGVsc2Uge1xuXHRcdFx0XHRcdGNodW5rX3J1bl9pbmRleCsrO1xuXHRcdFx0XHRcdC8qIElzIHRoZXJlIGFub3RoZXIgZW50cnkgaW4gdGhlIGZpcnN0X2NodW5rIHRhYmxlID8gKi9cblx0XHRcdFx0XHRpZiAoY2h1bmtfcnVuX2luZGV4ICsgMSA8IHN0c2MuZmlyc3RfY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvKiBUaGUgbGFzdCBjaHVuayBpbiB0aGUgcnVuIGlzIHRoZSBjaHVuayBiZWZvcmUgdGhlIG5leHQgZmlyc3QgY2h1bmsgKi9cblx0XHRcdFx0XHRcdGxhc3RfY2h1bmtfaW5fcnVuID0gc3RzYy5maXJzdF9jaHVua1tjaHVua19ydW5faW5kZXgrMV0tMTsgXHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogVGhlcmUgaXMgb25seSBvbmUgZW50cnkgaW4gdGhlIHRhYmxlLCBpdCBpcyB2YWxpZCBmb3IgYWxsIGZ1dHVyZSBjaHVua3MqL1xuXHRcdFx0XHRcdFx0bGFzdF9jaHVua19pbl9ydW4gPSBJbmZpbml0eTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0c2FtcGxlLmNodW5rX3J1bl9pbmRleCA9IGNodW5rX3J1bl9pbmRleDtcblx0XHRcdFx0bGFzdF9zYW1wbGVfaW5fY2h1bmsgKz0gc3RzYy5zYW1wbGVzX3Blcl9jaHVua1tjaHVua19ydW5faW5kZXhdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNhbXBsZS5kZXNjcmlwdGlvbl9pbmRleCA9IHN0c2Muc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4W3NhbXBsZS5jaHVua19ydW5faW5kZXhdLTE7XG5cdFx0c2FtcGxlLmRlc2NyaXB0aW9uID0gc3RzZC5lbnRyaWVzW3NhbXBsZS5kZXNjcmlwdGlvbl9pbmRleF07XG5cdFx0c2FtcGxlLm9mZnNldCA9IHN0Y28uY2h1bmtfb2Zmc2V0c1tzYW1wbGUuY2h1bmtfaW5kZXgtMV0gKyBvZmZzZXRfaW5fY2h1bms7IC8qIGNodW5rIGluZGV4ZXMgYXJlIDEtYmFzZWQgKi9cblx0XHRvZmZzZXRfaW5fY2h1bmsgKz0gc2FtcGxlLnNpemU7XG5cblx0XHQvKiBzZXR0aW5nIGR0cywgY3RzLCBkdXJhdGlvbiBhbmQgcmFwIGZsYWdzICovXG5cdFx0aWYgKGogPiBsYXN0X3NhbXBsZV9pbl9zdHRzX3J1bikge1xuXHRcdFx0c3R0c19ydW5faW5kZXgrKztcblx0XHRcdGlmIChsYXN0X3NhbXBsZV9pbl9zdHRzX3J1biA8IDApIHtcblx0XHRcdFx0bGFzdF9zYW1wbGVfaW5fc3R0c19ydW4gPSAwO1xuXHRcdFx0fVxuXHRcdFx0bGFzdF9zYW1wbGVfaW5fc3R0c19ydW4gKz0gc3R0cy5zYW1wbGVfY291bnRzW3N0dHNfcnVuX2luZGV4XTtcdFx0XHRcdFxuXHRcdH1cblx0XHRpZiAoaiA+IDApIHtcblx0XHRcdHRyYWsuc2FtcGxlc1tqLTFdLmR1cmF0aW9uID0gc3R0cy5zYW1wbGVfZGVsdGFzW3N0dHNfcnVuX2luZGV4XTtcblx0XHRcdHRyYWsuc2FtcGxlc19kdXJhdGlvbiArPSB0cmFrLnNhbXBsZXNbai0xXS5kdXJhdGlvbjtcblx0XHRcdHNhbXBsZS5kdHMgPSB0cmFrLnNhbXBsZXNbai0xXS5kdHMgKyB0cmFrLnNhbXBsZXNbai0xXS5kdXJhdGlvbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2FtcGxlLmR0cyA9IDA7XG5cdFx0fVxuXHRcdGlmIChjdHRzKSB7XG5cdFx0XHRpZiAoaiA+PSBsYXN0X3NhbXBsZV9pbl9jdHRzX3J1bikge1xuXHRcdFx0XHRjdHRzX3J1bl9pbmRleCsrO1xuXHRcdFx0XHRpZiAobGFzdF9zYW1wbGVfaW5fY3R0c19ydW4gPCAwKSB7XG5cdFx0XHRcdFx0bGFzdF9zYW1wbGVfaW5fY3R0c19ydW4gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3Rfc2FtcGxlX2luX2N0dHNfcnVuICs9IGN0dHMuc2FtcGxlX2NvdW50c1tjdHRzX3J1bl9pbmRleF07XHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHNhbXBsZS5jdHMgPSB0cmFrLnNhbXBsZXNbal0uZHRzICsgY3R0cy5zYW1wbGVfb2Zmc2V0c1tjdHRzX3J1bl9pbmRleF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNhbXBsZS5jdHMgPSBzYW1wbGUuZHRzO1xuXHRcdH1cblx0XHRpZiAoc3Rzcykge1xuXHRcdFx0aWYgKGogPT0gc3Rzcy5zYW1wbGVfbnVtYmVyc1tsYXN0X3N0c3NfaW5kZXhdIC0gMSkgeyAvLyBzYW1wbGUgbnVtYmVycyBhcmUgMS1iYXNlZFxuXHRcdFx0XHRzYW1wbGUuaXNfc3luYyA9IHRydWU7XG5cdFx0XHRcdGxhc3Rfc3Rzc19pbmRleCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2FtcGxlLmlzX3N5bmMgPSBmYWxzZTtcdFx0XHRcdFxuXHRcdFx0XHRzYW1wbGUuZGVncmFkYXRpb25fcHJpb3JpdHkgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN1YnMpIHtcblx0XHRcdFx0aWYgKHN1YnMuZW50cmllc1tzdWJzX2VudHJ5X2luZGV4XS5zYW1wbGVfZGVsdGEgKyBsYXN0X3N1YnNfc2FtcGxlX2luZGV4ID09IGorMSkge1xuXHRcdFx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzID0gc3Vicy5lbnRyaWVzW3N1YnNfZW50cnlfaW5kZXhdLnN1YnNhbXBsZXM7XG5cdFx0XHRcdFx0bGFzdF9zdWJzX3NhbXBsZV9pbmRleCArPSBzdWJzLmVudHJpZXNbc3Vic19lbnRyeV9pbmRleF0uc2FtcGxlX2RlbHRhO1xuXHRcdFx0XHRcdHN1YnNfZW50cnlfaW5kZXgrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzYW1wbGUuaXNfc3luYyA9IHRydWU7XG5cdFx0fVxuXHRcdElTT0ZpbGUucHJvY2Vzc19zZHRwKHRyYWsubWRpYS5taW5mLnN0Ymwuc2R0cCwgc2FtcGxlLCBzYW1wbGUubnVtYmVyKTtcblx0XHRpZiAoc3RkcCkge1xuXHRcdFx0c2FtcGxlLmRlZ3JhZGF0aW9uX3ByaW9yaXR5ID0gc3RkcC5wcmlvcml0eVtqXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2FtcGxlLmRlZ3JhZGF0aW9uX3ByaW9yaXR5ID0gMDtcblx0XHR9XG5cdFx0aWYgKHN1YnMpIHtcblx0XHRcdGlmIChzdWJzLmVudHJpZXNbc3Vic19lbnRyeV9pbmRleF0uc2FtcGxlX2RlbHRhICsgbGFzdF9zdWJzX3NhbXBsZV9pbmRleCA9PSBqKSB7XG5cdFx0XHRcdHNhbXBsZS5zdWJzYW1wbGVzID0gc3Vicy5lbnRyaWVzW3N1YnNfZW50cnlfaW5kZXhdLnN1YnNhbXBsZXM7XG5cdFx0XHRcdGxhc3Rfc3Vic19zYW1wbGVfaW5kZXggKz0gc3Vicy5lbnRyaWVzW3N1YnNfZW50cnlfaW5kZXhdLnNhbXBsZV9kZWx0YTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNiZ3BzLmxlbmd0aCA+IDAgfHwgc2dwZHMubGVuZ3RoID4gMCkge1xuXHRcdFx0SVNPRmlsZS5zZXRTYW1wbGVHcm91cFByb3BlcnRpZXModHJhaywgc2FtcGxlLCBqLCB0cmFrLnNhbXBsZV9ncm91cHNfaW5mbyk7XG5cdFx0fVxuXHR9XG5cdGlmIChqPjApIHtcblx0XHR0cmFrLnNhbXBsZXNbai0xXS5kdXJhdGlvbiA9IE1hdGgubWF4KHRyYWsubWRpYS5tZGhkLmR1cmF0aW9uIC0gdHJhay5zYW1wbGVzW2otMV0uZHRzLCAwKTtcblx0XHR0cmFrLnNhbXBsZXNfZHVyYXRpb24gKz0gdHJhay5zYW1wbGVzW2otMV0uZHVyYXRpb247XG5cdH1cbn07XG5cbi8qIFVwZGF0ZSBzYW1wbGUgbGlzdCB3aGVuIG5ldyAnbW9vZicgYm94ZXMgYXJlIHJlY2VpdmVkICovXG5JU09GaWxlLnByb3RvdHlwZS51cGRhdGVTYW1wbGVMaXN0cyA9IGZ1bmN0aW9uKCkge1x0XG5cdHZhciBpLCBqLCBrO1xuXHR2YXIgZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgsIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uLCBkZWZhdWx0X3NhbXBsZV9zaXplLCBkZWZhdWx0X3NhbXBsZV9mbGFncztcblx0dmFyIGxhc3RfcnVuX3Bvc2l0aW9uO1xuXHR2YXIgYm94LCBtb29mLCB0cmFmLCB0cmFrLCB0cmV4O1xuXHR2YXIgc2FtcGxlO1xuXHR2YXIgc2FtcGxlX2ZsYWdzO1xuXHRcblx0aWYgKHRoaXMubW9vdiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8qIGlmIHRoZSBpbnB1dCBmaWxlIGlzIGZyYWdtZW50ZWQgYW5kIGZldGNoZWQgaW4gbXVsdGlwbGUgZG93bmxvYWRzLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbGlzdCBvZiBzYW1wbGVzICovXG5cdHdoaWxlICh0aGlzLmxhc3RNb29mSW5kZXggPCB0aGlzLm1vb2ZzLmxlbmd0aCkge1xuXHRcdGJveCA9IHRoaXMubW9vZnNbdGhpcy5sYXN0TW9vZkluZGV4XTtcblx0XHR0aGlzLmxhc3RNb29mSW5kZXgrKztcblx0XHRpZiAoYm94LnR5cGUgPT0gXCJtb29mXCIpIHtcblx0XHRcdG1vb2YgPSBib3g7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbW9vZi50cmFmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0cmFmID0gbW9vZi50cmFmc1tpXTtcblx0XHRcdFx0dHJhayA9IHRoaXMuZ2V0VHJhY2tCeUlkKHRyYWYudGZoZC50cmFja19pZCk7XG5cdFx0XHRcdHRyZXggPSB0aGlzLmdldFRyZXhCeUlkKHRyYWYudGZoZC50cmFja19pZCk7XG5cdFx0XHRcdGlmICh0cmFmLnRmaGQuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9ERVNDKSB7XG5cdFx0XHRcdFx0ZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggPSB0cmFmLnRmaGQuZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXggPSAodHJleCA/IHRyZXguZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXg6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0cmFmLnRmaGQuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9EVVIpIHtcblx0XHRcdFx0XHRkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA9IHRyYWYudGZoZC5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA9ICh0cmV4ID8gdHJleC5kZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiA6IDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0cmFmLnRmaGQuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9TSVpFKSB7XG5cdFx0XHRcdFx0ZGVmYXVsdF9zYW1wbGVfc2l6ZSA9IHRyYWYudGZoZC5kZWZhdWx0X3NhbXBsZV9zaXplO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmF1bHRfc2FtcGxlX3NpemUgPSAodHJleCA/IHRyZXguZGVmYXVsdF9zYW1wbGVfc2l6ZSA6IDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0cmFmLnRmaGQuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX1NBTVBMRV9GTEFHUykge1xuXHRcdFx0XHRcdGRlZmF1bHRfc2FtcGxlX2ZsYWdzID0gdHJhZi50ZmhkLmRlZmF1bHRfc2FtcGxlX2ZsYWdzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmF1bHRfc2FtcGxlX2ZsYWdzID0gKHRyZXggPyB0cmV4LmRlZmF1bHRfc2FtcGxlX2ZsYWdzIDogMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhZi5zYW1wbGVfbnVtYmVyID0gMDtcblx0XHRcdFx0LyogcHJvY2VzcyBzYW1wbGUgZ3JvdXBzICovXG5cdFx0XHRcdGlmICh0cmFmLnNiZ3BzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRJU09GaWxlLmluaXRTYW1wbGVHcm91cHModHJhaywgdHJhZiwgdHJhZi5zYmdwcywgdHJhay5tZGlhLm1pbmYuc3RibC5zZ3BkcywgdHJhZi5zZ3Bkcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IHRyYWYudHJ1bnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgdHJ1biA9IHRyYWYudHJ1bnNbal07XG5cdFx0XHRcdFx0Zm9yIChrID0gMDsgayA8IHRydW4uc2FtcGxlX2NvdW50OyBrKyspIHtcblx0XHRcdFx0XHRcdHNhbXBsZSA9IHt9O1xuXHRcdFx0XHRcdFx0c2FtcGxlLm1vb2ZfbnVtYmVyID0gdGhpcy5sYXN0TW9vZkluZGV4O1xuXHRcdFx0XHRcdFx0c2FtcGxlLm51bWJlcl9pbl90cmFmID0gdHJhZi5zYW1wbGVfbnVtYmVyO1xuXHRcdFx0XHRcdFx0dHJhZi5zYW1wbGVfbnVtYmVyKys7XG5cdFx0XHQgICAgICAgICAgICBzYW1wbGUubnVtYmVyID0gdHJhay5zYW1wbGVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHRyYWYuZmlyc3Rfc2FtcGxlX2luZGV4ID0gdHJhay5zYW1wbGVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHRyYWsuc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG5cdFx0XHRcdFx0XHRzYW1wbGUudHJhY2tfaWQgPSB0cmFrLnRraGQudHJhY2tfaWQ7XG5cdFx0XHRcdFx0XHRzYW1wbGUudGltZXNjYWxlID0gdHJhay5tZGlhLm1kaGQudGltZXNjYWxlO1xuXHRcdFx0XHRcdFx0c2FtcGxlLmRlc2NyaXB0aW9uX2luZGV4ID0gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXgtMTtcblx0XHRcdFx0XHRcdHNhbXBsZS5kZXNjcmlwdGlvbiA9IHRyYWsubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzW3NhbXBsZS5kZXNjcmlwdGlvbl9pbmRleF07XG5cdFx0XHRcdFx0XHRzYW1wbGUuc2l6ZSA9IGRlZmF1bHRfc2FtcGxlX3NpemU7XG5cdFx0XHRcdFx0XHRpZiAodHJ1bi5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX1NJWkUpIHtcblx0XHRcdFx0XHRcdFx0c2FtcGxlLnNpemUgPSB0cnVuLnNhbXBsZV9zaXplW2tdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhay5zYW1wbGVzX3NpemUgKz0gc2FtcGxlLnNpemU7XG5cdFx0XHRcdFx0XHRzYW1wbGUuZHVyYXRpb24gPSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcblx0XHRcdFx0XHRcdGlmICh0cnVuLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfRFVSQVRJT04pIHtcblx0XHRcdFx0XHRcdFx0c2FtcGxlLmR1cmF0aW9uID0gdHJ1bi5zYW1wbGVfZHVyYXRpb25ba107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmFrLnNhbXBsZXNfZHVyYXRpb24gKz0gc2FtcGxlLmR1cmF0aW9uO1xuXHRcdFx0XHRcdFx0aWYgKHRyYWsuZmlyc3RfdHJhZl9tZXJnZWQgfHwgayA+IDApIHtcblx0XHRcdFx0XHRcdFx0c2FtcGxlLmR0cyA9IHRyYWsuc2FtcGxlc1t0cmFrLnNhbXBsZXMubGVuZ3RoLTJdLmR0cyt0cmFrLnNhbXBsZXNbdHJhay5zYW1wbGVzLmxlbmd0aC0yXS5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0cmFmLnRmZHQpIHtcblx0XHRcdFx0XHRcdFx0XHRzYW1wbGUuZHRzID0gdHJhZi50ZmR0LmJhc2VNZWRpYURlY29kZVRpbWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2FtcGxlLmR0cyA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhay5maXJzdF90cmFmX21lcmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzYW1wbGUuY3RzID0gc2FtcGxlLmR0cztcblx0XHRcdFx0XHRcdGlmICh0cnVuLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfQ1RTX09GRlNFVCkge1xuXHRcdFx0XHRcdFx0XHRzYW1wbGUuY3RzID0gc2FtcGxlLmR0cyArIHRydW4uc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0W2tdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2FtcGxlX2ZsYWdzID0gZGVmYXVsdF9zYW1wbGVfZmxhZ3M7XG5cdFx0XHRcdFx0XHRpZiAodHJ1bi5mbGFncyAmIEJveFBhcnNlci5UUlVOX0ZMQUdTX0ZMQUdTKSB7XG5cdFx0XHRcdFx0XHRcdHNhbXBsZV9mbGFncyA9IHRydW4uc2FtcGxlX2ZsYWdzW2tdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChrID09PSAwICYmICh0cnVuLmZsYWdzICYgQm94UGFyc2VyLlRSVU5fRkxBR1NfRklSU1RfRkxBRykpIHtcblx0XHRcdFx0XHRcdFx0c2FtcGxlX2ZsYWdzID0gdHJ1bi5maXJzdF9zYW1wbGVfZmxhZ3M7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzYW1wbGUuaXNfc3luYyA9ICgoc2FtcGxlX2ZsYWdzID4+IDE2ICYgMHgxKSA/IGZhbHNlIDogdHJ1ZSk7XG5cdFx0XHRcdFx0XHRzYW1wbGUuaXNfbGVhZGluZyA9IChzYW1wbGVfZmxhZ3MgPj4gMjYgJiAweDMpO1xuXHRcdFx0XHRcdFx0c2FtcGxlLmRlcGVuZHNfb24gPSAoc2FtcGxlX2ZsYWdzID4+IDI0ICYgMHgzKTtcblx0XHRcdFx0XHRcdHNhbXBsZS5pc19kZXBlbmRlZF9vbiA9IChzYW1wbGVfZmxhZ3MgPj4gMjIgJiAweDMpO1xuXHRcdFx0XHRcdFx0c2FtcGxlLmhhc19yZWR1bmRhbmN5ID0gKHNhbXBsZV9mbGFncyA+PiAyMCAmIDB4Myk7XG5cdFx0XHRcdFx0XHRzYW1wbGUuZGVncmFkYXRpb25fcHJpb3JpdHkgPSAoc2FtcGxlX2ZsYWdzICYgMHhGRkZGKTtcblx0XHRcdFx0XHRcdC8vSVNPRmlsZS5wcm9jZXNzX3NkdHAodHJhZi5zZHRwLCBzYW1wbGUsIHNhbXBsZS5udW1iZXJfaW5fdHJhZik7XG5cdFx0XHRcdFx0XHR2YXIgYmRvcCA9ICh0cmFmLnRmaGQuZmxhZ3MgJiBCb3hQYXJzZXIuVEZIRF9GTEFHX0JBU0VfREFUQV9PRkZTRVQpID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdFx0XHRcdFx0dmFyIGRiaW0gPSAodHJhZi50ZmhkLmZsYWdzICYgQm94UGFyc2VyLlRGSERfRkxBR19ERUZBVUxUX0JBU0VfSVNfTU9PRikgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdFx0XHR2YXIgZG9wID0gKHRydW4uZmxhZ3MgJiBCb3hQYXJzZXIuVFJVTl9GTEFHU19EQVRBX09GRlNFVCkgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdFx0XHR2YXIgYmRvID0gMDtcblx0XHRcdFx0XHRcdGlmICghYmRvcCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWRiaW0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaiA9PT0gMCkgeyAvLyB0aGUgZmlyc3QgdHJhY2sgaW4gdGhlIG1vdmllIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRiZG8gPSBtb29mLnN0YXJ0OyAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGVuY2xvc2luZyBNb3ZpZSBGcmFnbWVudCBCb3hcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0YmRvID0gbGFzdF9ydW5fcG9zaXRpb247IC8vIGVuZCBvZiB0aGUgZGF0YSBkZWZpbmVkIGJ5IHRoZSBwcmVjZWRpbmcgKnRyYWNrKiAoaXJyZXNwZWN0aXZlIG9mIHRoZSB0cmFjayBpZCkgZnJhZ21lbnQgaW4gdGhlIG1vb2Zcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0YmRvID0gbW9vZi5zdGFydDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YmRvID0gdHJhZi50ZmhkLmJhc2VfZGF0YV9vZmZzZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaiA9PT0gMCAmJiBrID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChkb3ApIHtcblx0XHRcdFx0XHRcdFx0XHRzYW1wbGUub2Zmc2V0ID0gYmRvICsgdHJ1bi5kYXRhX29mZnNldDsgLy8gSWYgdGhlIGRhdGEtb2Zmc2V0IGlzIHByZXNlbnQsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBiYXNlLWRhdGEtb2Zmc2V0IGVzdGFibGlzaGVkIGluIHRoZSB0cmFjayBmcmFnbWVudCBoZWFkZXJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzYW1wbGUub2Zmc2V0ID0gYmRvOyAvLyB0aGUgZGF0YSBmb3IgdGhpcyBydW4gc3RhcnRzIHRoZSBiYXNlLWRhdGEtb2Zmc2V0IGRlZmluZWQgYnkgdGhlIHRyYWNrIGZyYWdtZW50IGhlYWRlclxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzYW1wbGUub2Zmc2V0ID0gbGFzdF9ydW5fcG9zaXRpb247IC8vIHRoaXMgcnVuIHN0YXJ0cyBpbW1lZGlhdGVseSBhZnRlciB0aGUgZGF0YSBvZiB0aGUgcHJldmlvdXMgcnVuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsYXN0X3J1bl9wb3NpdGlvbiA9IHNhbXBsZS5vZmZzZXQgKyBzYW1wbGUuc2l6ZTtcblx0XHRcdFx0XHRcdGlmICh0cmFmLnNiZ3BzLmxlbmd0aCA+IDAgfHwgdHJhZi5zZ3Bkcy5sZW5ndGggPiAwIHx8XG5cdFx0XHRcdFx0XHRcdHRyYWsubWRpYS5taW5mLnN0Ymwuc2JncHMubGVuZ3RoID4gMCB8fCB0cmFrLm1kaWEubWluZi5zdGJsLnNncGRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0SVNPRmlsZS5zZXRTYW1wbGVHcm91cFByb3BlcnRpZXModHJhaywgc2FtcGxlLCBzYW1wbGUubnVtYmVyX2luX3RyYWYsIHRyYWYuc2FtcGxlX2dyb3Vwc19pbmZvKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRyYWYuc3Vicykge1xuXHRcdFx0XHRcdHRyYWsuaGFzX2ZyYWdtZW50X3N1YnNhbXBsZXMgPSB0cnVlO1xuXHRcdFx0XHRcdHZhciBzYW1wbGVfaW5kZXggPSB0cmFmLmZpcnN0X3NhbXBsZV9pbmRleDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgdHJhZi5zdWJzLmVudHJpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHNhbXBsZV9pbmRleCArPSB0cmFmLnN1YnMuZW50cmllc1tqXS5zYW1wbGVfZGVsdGE7XG5cdFx0XHRcdFx0XHRzYW1wbGUgPSB0cmFrLnNhbXBsZXNbc2FtcGxlX2luZGV4LTFdO1xuXHRcdFx0XHRcdFx0c2FtcGxlLnN1YnNhbXBsZXMgPSB0cmFmLnN1YnMuZW50cmllc1tqXS5zdWJzYW1wbGVzO1xuXHRcdFx0XHRcdH1cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cdFxufTtcblxuLyogVHJ5IHRvIGdldCBzYW1wbGUgZGF0YSBmb3IgYSBnaXZlbiBzYW1wbGU6XG4gICByZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kXG4gICByZXR1cm5zIHRoZSBzYW1lIHNhbXBsZSBpZiBhbHJlYWR5IHJlcXVlc3RlZFxuICovXG5JU09GaWxlLnByb3RvdHlwZS5nZXRTYW1wbGUgPSBmdW5jdGlvbih0cmFrLCBzYW1wbGVOdW0pIHtcdFxuXHR2YXIgYnVmZmVyO1xuXHR2YXIgc2FtcGxlID0gdHJhay5zYW1wbGVzW3NhbXBsZU51bV07XG5cdFxuXHRpZiAoIXRoaXMubW9vdikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKCFzYW1wbGUuZGF0YSkge1xuXHRcdC8qIE5vdCB5ZXQgZmV0Y2hlZCAqL1xuXHRcdHNhbXBsZS5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2FtcGxlLnNpemUpO1xuXHRcdHNhbXBsZS5hbHJlYWR5UmVhZCA9IDA7XG5cdFx0dGhpcy5zYW1wbGVzRGF0YVNpemUgKz0gc2FtcGxlLnNpemU7XG5cdFx0TG9nLmRlYnVnKFwiSVNPRmlsZVwiLCBcIkFsbG9jYXRpbmcgc2FtcGxlICNcIitzYW1wbGVOdW0rXCIgb24gdHJhY2sgI1wiK3RyYWsudGtoZC50cmFja19pZCtcIiBvZiBzaXplIFwiK3NhbXBsZS5zaXplK1wiICh0b3RhbDogXCIrdGhpcy5zYW1wbGVzRGF0YVNpemUrXCIpXCIpO1xuXHR9IGVsc2UgaWYgKHNhbXBsZS5hbHJlYWR5UmVhZCA9PSBzYW1wbGUuc2l6ZSkge1xuXHRcdC8qIEFscmVhZHkgZmV0Y2hlZCBlbnRpcmVseSAqL1xuXHRcdHJldHVybiBzYW1wbGU7XG5cdH1cblxuXHQvKiBUaGUgc2FtcGxlIGhhcyBvbmx5IGJlZW4gcGFydGlhbGx5IGZldGNoZWQsIHdlIG5lZWQgdG8gY2hlY2sgaW4gYWxsIGJ1ZmZlcnMgKi9cblx0d2hpbGUodHJ1ZSkge1xuXHRcdHZhciBpbmRleCA9XHR0aGlzLnN0cmVhbS5maW5kUG9zaXRpb24odHJ1ZSwgc2FtcGxlLm9mZnNldCArIHNhbXBsZS5hbHJlYWR5UmVhZCwgZmFsc2UpO1xuXHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRidWZmZXIgPSB0aGlzLnN0cmVhbS5idWZmZXJzW2luZGV4XTtcblx0XHRcdHZhciBsZW5ndGhBZnRlclN0YXJ0ID0gYnVmZmVyLmJ5dGVMZW5ndGggLSAoc2FtcGxlLm9mZnNldCArIHNhbXBsZS5hbHJlYWR5UmVhZCAtIGJ1ZmZlci5maWxlU3RhcnQpO1xuXHRcdFx0aWYgKHNhbXBsZS5zaXplIC0gc2FtcGxlLmFscmVhZHlSZWFkIDw9IGxlbmd0aEFmdGVyU3RhcnQpIHtcblx0XHRcdFx0LyogdGhlIChyZXN0IG9mIHRoZSkgc2FtcGxlIGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiB0aGlzIGJ1ZmZlciAqL1xuXG5cdFx0XHRcdExvZy5kZWJ1ZyhcIklTT0ZpbGVcIixcIkdldHRpbmcgc2FtcGxlICNcIitzYW1wbGVOdW0rXCIgZGF0YSAoYWxyZWFkeVJlYWQ6IFwiK3NhbXBsZS5hbHJlYWR5UmVhZCtcIiBvZmZzZXQ6IFwiK1xuXHRcdFx0XHRcdChzYW1wbGUub2Zmc2V0K3NhbXBsZS5hbHJlYWR5UmVhZCAtIGJ1ZmZlci5maWxlU3RhcnQpK1wiIHJlYWQgc2l6ZTogXCIrKHNhbXBsZS5zaXplIC0gc2FtcGxlLmFscmVhZHlSZWFkKStcIiBmdWxsIHNpemU6IFwiK3NhbXBsZS5zaXplK1wiKVwiKTtcblxuXHRcdFx0XHREYXRhU3RyZWFtLm1lbWNweShzYW1wbGUuZGF0YS5idWZmZXIsIHNhbXBsZS5hbHJlYWR5UmVhZCxcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgYnVmZmVyLCBzYW1wbGUub2Zmc2V0K3NhbXBsZS5hbHJlYWR5UmVhZCAtIGJ1ZmZlci5maWxlU3RhcnQsIHNhbXBsZS5zaXplIC0gc2FtcGxlLmFscmVhZHlSZWFkKTtcblxuXHRcdFx0XHQvKiB1cGRhdGUgdGhlIG51bWJlciBvZiBieXRlcyB1c2VkIGluIHRoaXMgYnVmZmVyIGFuZCBjaGVjayBpZiBpdCBuZWVkcyB0byBiZSByZW1vdmVkICovXG5cdFx0XHRcdGJ1ZmZlci51c2VkQnl0ZXMgKz0gc2FtcGxlLnNpemUgLSBzYW1wbGUuYWxyZWFkeVJlYWQ7XG5cdFx0XHRcdHRoaXMuc3RyZWFtLmxvZ0J1ZmZlckxldmVsKCk7XG5cblx0XHRcdFx0c2FtcGxlLmFscmVhZHlSZWFkID0gc2FtcGxlLnNpemU7XG5cblx0XHRcdFx0cmV0dXJuIHNhbXBsZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIHRoZSBzYW1wbGUgZG9lcyBub3QgZW5kIGluIHRoaXMgYnVmZmVyICovXG5cblx0XHRcdFx0aWYgKGxlbmd0aEFmdGVyU3RhcnQgPT09IDApIHJldHVybiBudWxsO1xuXG5cdFx0XHRcdExvZy5kZWJ1ZyhcIklTT0ZpbGVcIixcIkdldHRpbmcgc2FtcGxlICNcIitzYW1wbGVOdW0rXCIgcGFydGlhbCBkYXRhIChhbHJlYWR5UmVhZDogXCIrc2FtcGxlLmFscmVhZHlSZWFkK1wiIG9mZnNldDogXCIrXG5cdFx0XHRcdFx0KHNhbXBsZS5vZmZzZXQrc2FtcGxlLmFscmVhZHlSZWFkIC0gYnVmZmVyLmZpbGVTdGFydCkrXCIgcmVhZCBzaXplOiBcIitsZW5ndGhBZnRlclN0YXJ0K1wiIGZ1bGwgc2l6ZTogXCIrc2FtcGxlLnNpemUrXCIpXCIpO1xuXG5cdFx0XHRcdERhdGFTdHJlYW0ubWVtY3B5KHNhbXBsZS5kYXRhLmJ1ZmZlciwgc2FtcGxlLmFscmVhZHlSZWFkLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICBidWZmZXIsIHNhbXBsZS5vZmZzZXQrc2FtcGxlLmFscmVhZHlSZWFkIC0gYnVmZmVyLmZpbGVTdGFydCwgbGVuZ3RoQWZ0ZXJTdGFydCk7XG5cdFx0XHRcdHNhbXBsZS5hbHJlYWR5UmVhZCArPSBsZW5ndGhBZnRlclN0YXJ0O1xuXG5cdFx0XHRcdC8qIHVwZGF0ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHVzZWQgaW4gdGhpcyBidWZmZXIgYW5kIGNoZWNrIGlmIGl0IG5lZWRzIHRvIGJlIHJlbW92ZWQgKi9cblx0XHRcdFx0YnVmZmVyLnVzZWRCeXRlcyArPSBsZW5ndGhBZnRlclN0YXJ0O1xuXHRcdFx0XHR0aGlzLnN0cmVhbS5sb2dCdWZmZXJMZXZlbCgpO1xuXG5cdFx0XHRcdC8qIGtlZXAgbG9va2luZyBpbiB0aGUgbmV4dCBidWZmZXIgKi9cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBSZWxlYXNlIHRoZSBtZW1vcnkgdXNlZCB0byBzdG9yZSB0aGUgZGF0YSBvZiB0aGUgc2FtcGxlICovXG5JU09GaWxlLnByb3RvdHlwZS5yZWxlYXNlU2FtcGxlID0gZnVuY3Rpb24odHJhaywgc2FtcGxlTnVtKSB7XHRcblx0dmFyIHNhbXBsZSA9IHRyYWsuc2FtcGxlc1tzYW1wbGVOdW1dO1xuXHRpZiAoc2FtcGxlLmRhdGEpIHtcblx0XHR0aGlzLnNhbXBsZXNEYXRhU2l6ZSAtPSBzYW1wbGUuc2l6ZTtcblx0XHRzYW1wbGUuZGF0YSA9IG51bGw7XG5cdFx0c2FtcGxlLmFscmVhZHlSZWFkID0gMDtcblx0XHRyZXR1cm4gc2FtcGxlLnNpemU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmdldEFsbG9jYXRlZFNhbXBsZURhdGFTaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNhbXBsZXNEYXRhU2l6ZTtcbn07XG5cbi8qIEJ1aWxkcyB0aGUgTUlNRSBUeXBlICdjb2RlY3MnIHN1Yi1wYXJhbWV0ZXJzIGZvciB0aGUgd2hvbGUgZmlsZSAqL1xuSVNPRmlsZS5wcm90b3R5cGUuZ2V0Q29kZWNzID0gZnVuY3Rpb24oKSB7XHRcblx0dmFyIGk7XG5cdHZhciBjb2RlY3MgPSBcIlwiO1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5tb292LnRyYWtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRyYWsgPSB0aGlzLm1vb3YudHJha3NbaV07XG5cdFx0aWYgKGk+MCkge1xuXHRcdFx0Y29kZWNzKz1cIixcIjsgXG5cdFx0fVxuXHRcdGNvZGVjcyArPSB0cmFrLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllc1swXS5nZXRDb2RlYygpO1x0XHRcblx0fVxuXHRyZXR1cm4gY29kZWNzO1xufTtcblxuLyogSGVscGVyIGZ1bmN0aW9uICovXG5JU09GaWxlLnByb3RvdHlwZS5nZXRUcmV4QnlJZCA9IGZ1bmN0aW9uKGlkKSB7XHRcblx0dmFyIGk7XG5cdGlmICghdGhpcy5tb292IHx8ICF0aGlzLm1vb3YubXZleCkgcmV0dXJuIG51bGw7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLm1vb3YubXZleC50cmV4cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0cmV4ID0gdGhpcy5tb292Lm12ZXgudHJleHNbaV07XG5cdFx0aWYgKHRyZXgudHJhY2tfaWQgPT0gaWQpIHJldHVybiB0cmV4O1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuLyogSGVscGVyIGZ1bmN0aW9uICovXG5JU09GaWxlLnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbihpZCkge1xuXHRpZiAodGhpcy5tb292ID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubW9vdi50cmFrcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciB0cmFrID0gdGhpcy5tb292LnRyYWtzW2pdO1xuXHRcdGlmICh0cmFrLnRraGQudHJhY2tfaWQgPT0gaWQpIHJldHVybiB0cmFrO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcbi8vIGZpbGU6c3JjL2lzb2ZpbGUtaXRlbS1wcm9jZXNzaW5nLmpzXG5JU09GaWxlLnByb3RvdHlwZS5pdGVtcyA9IFtdO1xuLyogc2l6ZSBvZiB0aGUgYnVmZmVycyBhbGxvY2F0ZWQgZm9yIHNhbXBsZXMgKi9cbklTT0ZpbGUucHJvdG90eXBlLml0ZW1zRGF0YVNpemUgPSAwO1xuXG5JU09GaWxlLnByb3RvdHlwZS5mbGF0dGVuSXRlbUluZm8gPSBmdW5jdGlvbigpIHtcdFxuXHR2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuXHR2YXIgaSwgajtcblx0dmFyIGl0ZW07XG5cdHZhciBtZXRhID0gdGhpcy5tZXRhO1xuXHRpZiAobWV0YSA9PT0gbnVsbCB8fCBtZXRhID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0aWYgKG1ldGEuaGRsciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdGlmIChtZXRhLmlpbmYgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRmb3IgKGkgPSAwOyBpIDwgbWV0YS5paW5mLml0ZW1faW5mb3MubGVuZ3RoOyBpKyspIHtcblx0XHRpdGVtID0ge307XG5cdFx0aXRlbS5pZCA9IG1ldGEuaWluZi5pdGVtX2luZm9zW2ldLml0ZW1fSUQ7XG5cdFx0aXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuXHRcdGl0ZW0ucmVmX3RvID0gW107XG5cdFx0aXRlbS5uYW1lID0gbWV0YS5paW5mLml0ZW1faW5mb3NbaV0uaXRlbV9uYW1lO1xuXHRcdGlmIChtZXRhLmlpbmYuaXRlbV9pbmZvc1tpXS5wcm90ZWN0aW9uX2luZGV4ID4gMCkge1xuXHRcdFx0aXRlbS5wcm90ZWN0aW9uID0gbWV0YS5pcHJvLnByb3RlY3Rpb25zW21ldGEuaWluZi5pdGVtX2luZm9zW2ldLnByb3RlY3Rpb25faW5kZXgtMV07XG5cdFx0fVxuXHRcdGlmIChtZXRhLmlpbmYuaXRlbV9pbmZvc1tpXS5pdGVtX3R5cGUpIHtcblx0XHRcdGl0ZW0udHlwZSA9IG1ldGEuaWluZi5pdGVtX2luZm9zW2ldLml0ZW1fdHlwZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbS50eXBlID0gXCJtaW1lXCI7XG5cdFx0fVxuXHRcdGl0ZW0uY29udGVudF90eXBlID0gbWV0YS5paW5mLml0ZW1faW5mb3NbaV0uY29udGVudF90eXBlO1xuXHRcdGl0ZW0uY29udGVudF9lbmNvZGluZyA9IG1ldGEuaWluZi5pdGVtX2luZm9zW2ldLmNvbnRlbnRfZW5jb2Rpbmc7XG5cdH1cblx0aWYgKG1ldGEuaWxvYykge1xuXHRcdGZvcihpID0gMDsgaSA8IG1ldGEuaWxvYy5pdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW1sb2MgPSBtZXRhLmlsb2MuaXRlbXNbaV07XG5cdFx0XHRpdGVtID0gaXRlbXNbaXRlbWxvYy5pdGVtX0lEXTtcblx0XHRcdGlmIChpdGVtbG9jLmRhdGFfcmVmZXJlbmNlX2luZGV4ICE9PSAwKSB7XG5cdFx0XHRcdExvZy53YXJuKFwiSXRlbSBzdG9yYWdlIHdpdGggcmVmZXJlbmNlIHRvIG90aGVyIGZpbGVzOiBub3Qgc3VwcG9ydGVkXCIpO1xuXHRcdFx0XHRpdGVtLnNvdXJjZSA9IG1ldGEuZGluZi5ib3hlc1tpdGVtbG9jLmRhdGFfcmVmZXJlbmNlX2luZGV4LTFdO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKGl0ZW1sb2MuY29uc3RydWN0aW9uX21ldGhvZCkge1xuXHRcdFx0XHRjYXNlIDA6IC8vIG9mZnNldCBpbnRvIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIGRhdGEgcmVmZXJlbmNlIGluZGV4XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6IC8vIG9mZnNldCBpbnRvIHRoZSBpZGF0IGJveCBvZiB0aGlzIG1ldGEgYm94XG5cdFx0XHRcdExvZy53YXJuKFwiSXRlbSBzdG9yYWdlIHdpdGggY29uc3RydWN0aW9uX21ldGhvZCA6IG5vdCBzdXBwb3J0ZWRcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6IC8vIG9mZnNldCBpbnRvIGFub3RoZXIgaXRlbVxuXHRcdFx0XHRMb2cud2FybihcIkl0ZW0gc3RvcmFnZSB3aXRoIGNvbnN0cnVjdGlvbl9tZXRob2QgOiBub3Qgc3VwcG9ydGVkXCIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGl0ZW0uZXh0ZW50cyA9IFtdO1xuXHRcdFx0aXRlbS5zaXplID0gMDtcblx0XHRcdGZvciAoaiA9IDA7IGogPCBpdGVtbG9jLmV4dGVudHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aXRlbS5leHRlbnRzW2pdID0ge307XG5cdFx0XHRcdGl0ZW0uZXh0ZW50c1tqXS5vZmZzZXQgPSBpdGVtbG9jLmV4dGVudHNbal0uZXh0ZW50X29mZnNldCArIGl0ZW1sb2MuYmFzZV9vZmZzZXQ7XG5cdFx0XHRcdGl0ZW0uZXh0ZW50c1tqXS5sZW5ndGggPSBpdGVtbG9jLmV4dGVudHNbal0uZXh0ZW50X2xlbmd0aDtcblx0XHRcdFx0aXRlbS5leHRlbnRzW2pdLmFscmVhZHlSZWFkID0gMDtcblx0XHRcdFx0aXRlbS5zaXplICs9IGl0ZW0uZXh0ZW50c1tqXS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChtZXRhLnBpdG0pIHtcblx0XHRpdGVtc1ttZXRhLnBpdG0uaXRlbV9pZF0ucHJpbWFyeSA9IHRydWU7XG5cdH1cblx0aWYgKG1ldGEuaXJlZikge1xuXHRcdGZvciAoaT0wOyBpIDxtZXRhLmlyZWYucmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHJlZiA9IG1ldGEuaXJlZi5yZWZlcmVuY2VzW2ldO1xuXHRcdFx0Zm9yIChqPTA7IGo8cmVmLnJlZmVyZW5jZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aXRlbXNbcmVmLmZyb21faXRlbV9JRF0ucmVmX3RvLnB1c2goe3R5cGU6IHJlZi50eXBlLCBpZDogcmVmLnJlZmVyZW5jZXNbal19KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKG1ldGEuaXBycCkge1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbWV0YS5pcHJwLmlwbWFzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHR2YXIgaXBtYSA9IG1ldGEuaXBycC5pcG1hc1trXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBpcG1hLmFzc29jaWF0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgYXNzb2NpYXRpb24gPSBpcG1hLmFzc29jaWF0aW9uc1tpXTtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zW2Fzc29jaWF0aW9uLmlkXTtcblx0XHRcdFx0aWYgKGl0ZW0ucHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aXRlbS5wcm9wZXJ0aWVzID0ge307XG5cdFx0XHRcdFx0aXRlbS5wcm9wZXJ0aWVzLmJveGVzID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGFzc29jaWF0aW9uLnByb3BzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0dmFyIHByb3BFbnRyeSA9IGFzc29jaWF0aW9uLnByb3BzW2pdO1xuXHRcdFx0XHRcdGlmIChwcm9wRW50cnkucHJvcGVydHlfaW5kZXggPiAwICYmIHByb3BFbnRyeS5wcm9wZXJ0eV9pbmRleC0xIDwgbWV0YS5pcHJwLmlwY28uYm94ZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGJveCA9IG1ldGEuaXBycC5pcGNvLmJveGVzW3Byb3BFbnRyeS5wcm9wZXJ0eV9pbmRleC0xXTtcblx0XHRcdFx0XHRcdGl0ZW0ucHJvcGVydGllc1twcm9wYm94LnR5cGVdID0gcHJvcGJveDtcblx0XHRcdFx0XHRcdGl0ZW0ucHJvcGVydGllcy5ib3hlcy5wdXNoKHByb3Bib3gpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKGl0ZW1faWQpIHtcdFxuXHR2YXIgYnVmZmVyO1xuXHR2YXIgaXRlbTtcblx0XG5cdGlmICghdGhpcy5tZXRhKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuIFx0aXRlbSA9IHRoaXMuaXRlbXNbaXRlbV9pZF07XG5cdGlmICghaXRlbS5kYXRhICYmIGl0ZW0uc2l6ZSkge1xuXHRcdC8qIE5vdCB5ZXQgZmV0Y2hlZCAqL1xuXHRcdGl0ZW0uZGF0YSA9IG5ldyBVaW50OEFycmF5KGl0ZW0uc2l6ZSk7XG5cdFx0aXRlbS5hbHJlYWR5UmVhZCA9IDA7XG5cdFx0dGhpcy5pdGVtc0RhdGFTaXplICs9IGl0ZW0uc2l6ZTtcblx0XHRMb2cuZGVidWcoXCJJU09GaWxlXCIsIFwiQWxsb2NhdGluZyBpdGVtICNcIitpdGVtX2lkK1wiIG9mIHNpemUgXCIraXRlbS5zaXplK1wiICh0b3RhbDogXCIrdGhpcy5pdGVtc0RhdGFTaXplK1wiKVwiKTtcblx0fSBlbHNlIGlmIChpdGVtLmFscmVhZHlSZWFkID09PSBpdGVtLnNpemUpIHtcblx0XHQvKiBBbHJlYWR5IGZldGNoZWQgZW50aXJlbHkgKi9cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdC8qIFRoZSBpdGVtIGhhcyBvbmx5IGJlZW4gcGFydGlhbGx5IGZldGNoZWQsIHdlIG5lZWQgdG8gY2hlY2sgaW4gYWxsIGJ1ZmZlcnMgdG8gZmluZCB0aGUgcmVtYWluaW5nIGV4dGVudHMqL1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbS5leHRlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGV4dGVudCA9IGl0ZW0uZXh0ZW50c1tpXTtcblx0XHRpZiAoZXh0ZW50LmFscmVhZHlSZWFkID09PSBleHRlbnQubGVuZ3RoKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGluZGV4ID1cdHRoaXMuc3RyZWFtLmZpbmRQb3NpdGlvbih0cnVlLCBleHRlbnQub2Zmc2V0ICsgZXh0ZW50LmFscmVhZHlSZWFkLCBmYWxzZSk7XG5cdFx0XHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRidWZmZXIgPSB0aGlzLnN0cmVhbS5idWZmZXJzW2luZGV4XTtcblx0XHRcdFx0dmFyIGxlbmd0aEFmdGVyU3RhcnQgPSBidWZmZXIuYnl0ZUxlbmd0aCAtIChleHRlbnQub2Zmc2V0ICsgZXh0ZW50LmFscmVhZHlSZWFkIC0gYnVmZmVyLmZpbGVTdGFydCk7XG5cdFx0XHRcdGlmIChleHRlbnQubGVuZ3RoIC0gZXh0ZW50LmFscmVhZHlSZWFkIDw9IGxlbmd0aEFmdGVyU3RhcnQpIHtcblx0XHRcdFx0XHQvKiB0aGUgKHJlc3Qgb2YgdGhlKSBleHRlbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIHRoaXMgYnVmZmVyICovXG5cblx0XHRcdFx0XHRMb2cuZGVidWcoXCJJU09GaWxlXCIsXCJHZXR0aW5nIGl0ZW0gI1wiK2l0ZW1faWQrXCIgZXh0ZW50ICNcIitpK1wiIGRhdGEgKGFscmVhZHlSZWFkOiBcIitleHRlbnQuYWxyZWFkeVJlYWQrXG5cdFx0XHRcdFx0XHRcIiBvZmZzZXQ6IFwiKyhleHRlbnQub2Zmc2V0K2V4dGVudC5hbHJlYWR5UmVhZCAtIGJ1ZmZlci5maWxlU3RhcnQpK1wiIHJlYWQgc2l6ZTogXCIrKGV4dGVudC5sZW5ndGggLSBleHRlbnQuYWxyZWFkeVJlYWQpK1xuXHRcdFx0XHRcdFx0XCIgZnVsbCBleHRlbnQgc2l6ZTogXCIrZXh0ZW50Lmxlbmd0aCtcIiBmdWxsIGl0ZW0gc2l6ZTogXCIraXRlbS5zaXplK1wiKVwiKTtcblxuXHRcdFx0XHRcdERhdGFTdHJlYW0ubWVtY3B5KGl0ZW0uZGF0YS5idWZmZXIsIGl0ZW0uYWxyZWFkeVJlYWQsIFxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgIGJ1ZmZlciwgZXh0ZW50Lm9mZnNldCtleHRlbnQuYWxyZWFkeVJlYWQgLSBidWZmZXIuZmlsZVN0YXJ0LCBleHRlbnQubGVuZ3RoIC0gZXh0ZW50LmFscmVhZHlSZWFkKTtcblxuXHRcdFx0XHRcdC8qIHVwZGF0ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHVzZWQgaW4gdGhpcyBidWZmZXIgYW5kIGNoZWNrIGlmIGl0IG5lZWRzIHRvIGJlIHJlbW92ZWQgKi9cblx0XHRcdFx0XHRidWZmZXIudXNlZEJ5dGVzICs9IGV4dGVudC5sZW5ndGggLSBleHRlbnQuYWxyZWFkeVJlYWQ7XG5cdFx0XHRcdFx0dGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoKTtcblxuXHRcdFx0XHRcdGl0ZW0uYWxyZWFkeVJlYWQgKz0gKGV4dGVudC5sZW5ndGggLSBleHRlbnQuYWxyZWFkeVJlYWQpO1xuXHRcdFx0XHRcdGV4dGVudC5hbHJlYWR5UmVhZCA9IGV4dGVudC5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogdGhlIHNhbXBsZSBkb2VzIG5vdCBlbmQgaW4gdGhpcyBidWZmZXIgKi9cblxuXHRcdFx0XHRcdExvZy5kZWJ1ZyhcIklTT0ZpbGVcIixcIkdldHRpbmcgaXRlbSAjXCIraXRlbV9pZCtcIiBleHRlbnQgI1wiK2krXCIgcGFydGlhbCBkYXRhIChhbHJlYWR5UmVhZDogXCIrZXh0ZW50LmFscmVhZHlSZWFkK1wiIG9mZnNldDogXCIrXG5cdFx0XHRcdFx0XHQoZXh0ZW50Lm9mZnNldCtleHRlbnQuYWxyZWFkeVJlYWQgLSBidWZmZXIuZmlsZVN0YXJ0KStcIiByZWFkIHNpemU6IFwiK2xlbmd0aEFmdGVyU3RhcnQrXG5cdFx0XHRcdFx0XHRcIiBmdWxsIGV4dGVudCBzaXplOiBcIitleHRlbnQubGVuZ3RoK1wiIGZ1bGwgaXRlbSBzaXplOiBcIitpdGVtLnNpemUrXCIpXCIpO1xuXG5cdFx0XHRcdFx0RGF0YVN0cmVhbS5tZW1jcHkoaXRlbS5kYXRhLmJ1ZmZlciwgaXRlbS5hbHJlYWR5UmVhZCwgXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgYnVmZmVyLCBleHRlbnQub2Zmc2V0K2V4dGVudC5hbHJlYWR5UmVhZCAtIGJ1ZmZlci5maWxlU3RhcnQsIGxlbmd0aEFmdGVyU3RhcnQpO1xuXHRcdFx0XHRcdGV4dGVudC5hbHJlYWR5UmVhZCArPSBsZW5ndGhBZnRlclN0YXJ0O1xuXHRcdFx0XHRcdGl0ZW0uYWxyZWFkeVJlYWQgKz0gbGVuZ3RoQWZ0ZXJTdGFydDtcblxuXHRcdFx0XHRcdC8qIHVwZGF0ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHVzZWQgaW4gdGhpcyBidWZmZXIgYW5kIGNoZWNrIGlmIGl0IG5lZWRzIHRvIGJlIHJlbW92ZWQgKi9cblx0XHRcdFx0XHRidWZmZXIudXNlZEJ5dGVzICs9IGxlbmd0aEFmdGVyU3RhcnQ7XG5cdFx0XHRcdFx0dGhpcy5zdHJlYW0ubG9nQnVmZmVyTGV2ZWwoKTtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChpdGVtLmFscmVhZHlSZWFkID09PSBpdGVtLnNpemUpIHtcblx0XHQvKiBmZXRjaGVkIGVudGlyZWx5ICovXG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn07XG5cbi8qIFJlbGVhc2UgdGhlIG1lbW9yeSB1c2VkIHRvIHN0b3JlIHRoZSBkYXRhIG9mIHRoZSBpdGVtICovXG5JU09GaWxlLnByb3RvdHlwZS5yZWxlYXNlSXRlbSA9IGZ1bmN0aW9uKGl0ZW1faWQpIHtcdFxuXHR2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaXRlbV9pZF07XG5cdGlmIChpdGVtLmRhdGEpIHtcblx0XHR0aGlzLml0ZW1zRGF0YVNpemUgLT0gaXRlbS5zaXplO1xuXHRcdGl0ZW0uZGF0YSA9IG51bGw7XG5cdFx0aXRlbS5hbHJlYWR5UmVhZCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtLmV4dGVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBleHRlbnQgPSBpdGVtLmV4dGVudHNbaV07XG5cdFx0XHRleHRlbnQuYWxyZWFkeVJlYWQgPSAwO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbS5zaXplO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAwO1xuXHR9XG59O1xuXG5cbklTT0ZpbGUucHJvdG90eXBlLnByb2Nlc3NJdGVtcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdGZvcih2YXIgaSBpbiB0aGlzLml0ZW1zKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXHRcdHRoaXMuZ2V0SXRlbShpdGVtLmlkKTtcblx0XHRpZiAoY2FsbGJhY2sgJiYgIWl0ZW0uc2VudCkge1xuXHRcdFx0Y2FsbGJhY2soaXRlbSk7XG5cdFx0XHRpdGVtLnNlbnQgPSB0cnVlO1xuXHRcdFx0aXRlbS5kYXRhID0gbnVsbDtcblx0XHR9XG5cdH1cbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmhhc0l0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG5cdGZvcih2YXIgaSBpbiB0aGlzLml0ZW1zKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXHRcdGlmIChpdGVtLm5hbWUgPT09IG5hbWUpIHtcblx0XHRcdHJldHVybiBpdGVtLmlkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG5JU09GaWxlLnByb3RvdHlwZS5nZXRNZXRhSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMubWV0YSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLm1ldGEuaGRsci5oYW5kbGVyO1x0XHRcblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuZ2V0UHJpbWFyeUl0ZW0gPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLm1ldGEgfHwgIXRoaXMubWV0YS5waXRtKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0SXRlbSh0aGlzLm1ldGEucGl0bS5pdGVtX2lkKTtcblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuaXRlbVRvRnJhZ21lbnRlZFRyYWNrRmlsZSA9IGZ1bmN0aW9uKF9vcHRpb25zKSB7XG5cdHZhciBvcHRpb25zID0gX29wdGlvbnMgfHwge307XG5cdHZhciBpdGVtID0gbnVsbDtcblx0aWYgKG9wdGlvbnMuaXRlbUlkKSB7XG5cdFx0aXRlbSA9IHRoaXMuZ2V0SXRlbShvcHRpb25zLml0ZW1JZCk7XG5cdH0gZWxzZSB7XG5cdFx0aXRlbSA9IHRoaXMuZ2V0UHJpbWFyeUl0ZW0oKTtcblx0fVxuXHRpZiAoaXRlbSA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuXHR2YXIgZmlsZSA9IG5ldyBJU09GaWxlKCk7XG5cdGZpbGUuZGlzY2FyZE1kYXREYXRhID0gZmFsc2U7XG5cdC8vIGFzc3VtaW5nIHRoZSB0cmFjayB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSBpdGVtIHR5cGVcblx0dmFyIHRyYWNrT3B0aW9ucyA9IHsgdHlwZTogaXRlbS50eXBlLCBkZXNjcmlwdGlvbl9ib3hlczogaXRlbS5wcm9wZXJ0aWVzLmJveGVzfTtcblx0aWYgKGl0ZW0ucHJvcGVydGllcy5pc3BlKSB7XG5cdFx0dHJhY2tPcHRpb25zLndpZHRoID0gaXRlbS5wcm9wZXJ0aWVzLmlzcGUuaW1hZ2Vfd2lkdGg7XG5cdFx0dHJhY2tPcHRpb25zLmhlaWdodCA9IGl0ZW0ucHJvcGVydGllcy5pc3BlLmltYWdlX2hlaWdodDtcblx0fVxuXHR2YXIgdHJhY2tJZCA9IGZpbGUuYWRkVHJhY2sodHJhY2tPcHRpb25zKTtcblx0aWYgKHRyYWNrSWQpIHtcblx0XHRmaWxlLmFkZFNhbXBsZSh0cmFja0lkLCBpdGVtLmRhdGEpO1xuXHRcdHJldHVybiBmaWxlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xuXG4vLyBmaWxlOnNyYy9pc29maWxlLXdyaXRlLmpzXG4vKiBSZXdyaXRlIHRoZSBlbnRpcmUgZmlsZSAqL1xuSVNPRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvdXRzdHJlYW0pIHtcblx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuYm94ZXMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLmJveGVzW2ldLndyaXRlKG91dHN0cmVhbSk7XG5cdH1cbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmNyZWF0ZUZyYWdtZW50ID0gZnVuY3Rpb24odHJhY2tfaWQsIHNhbXBsZU51bWJlciwgc3RyZWFtXykge1xuXHR2YXIgdHJhayA9IHRoaXMuZ2V0VHJhY2tCeUlkKHRyYWNrX2lkKTtcblx0dmFyIHNhbXBsZSA9IHRoaXMuZ2V0U2FtcGxlKHRyYWssIHNhbXBsZU51bWJlcik7XG5cdGlmIChzYW1wbGUgPT0gbnVsbCkge1xuXHRcdHNhbXBsZSA9IHRyYWsuc2FtcGxlc1tzYW1wbGVOdW1iZXJdO1xuXHRcdGlmICh0aGlzLm5leHRTZWVrUG9zaXRpb24pIHtcblx0XHRcdHRoaXMubmV4dFNlZWtQb3NpdGlvbiA9IE1hdGgubWluKHNhbXBsZS5vZmZzZXQrc2FtcGxlLmFscmVhZHlSZWFkLHRoaXMubmV4dFNlZWtQb3NpdGlvbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubmV4dFNlZWtQb3NpdGlvbiA9IHRyYWsuc2FtcGxlc1tzYW1wbGVOdW1iZXJdLm9mZnNldCtzYW1wbGUuYWxyZWFkeVJlYWQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdFxuXHR2YXIgc3RyZWFtID0gc3RyZWFtXyB8fCBuZXcgRGF0YVN0cmVhbSgpO1xuXHRzdHJlYW0uZW5kaWFubmVzcyA9IERhdGFTdHJlYW0uQklHX0VORElBTjtcblxuXHR2YXIgbW9vZiA9IHRoaXMuY3JlYXRlU2luZ2xlU2FtcGxlTW9vZihzYW1wbGUpO1xuXHRtb29mLndyaXRlKHN0cmVhbSk7XG5cblx0LyogYWRqdXN0aW5nIHRoZSBkYXRhX29mZnNldCBub3cgdGhhdCB0aGUgbW9vZiBzaXplIGlzIGtub3duKi9cblx0bW9vZi50cmFmc1swXS50cnVuc1swXS5kYXRhX29mZnNldCA9IG1vb2Yuc2l6ZSs4OyAvLzggaXMgbWRhdCBoZWFkZXJcblx0TG9nLmRlYnVnKFwiTVA0Qm94XCIsIFwiQWRqdXN0aW5nIGRhdGFfb2Zmc2V0IHdpdGggbmV3IHZhbHVlIFwiK21vb2YudHJhZnNbMF0udHJ1bnNbMF0uZGF0YV9vZmZzZXQpO1xuXHRzdHJlYW0uYWRqdXN0VWludDMyKG1vb2YudHJhZnNbMF0udHJ1bnNbMF0uZGF0YV9vZmZzZXRfcG9zaXRpb24sIG1vb2YudHJhZnNbMF0udHJ1bnNbMF0uZGF0YV9vZmZzZXQpO1xuXHRcdFxuXHR2YXIgbWRhdCA9IG5ldyBCb3hQYXJzZXIubWRhdEJveCgpO1xuXHRtZGF0LmRhdGEgPSBzYW1wbGUuZGF0YTtcblx0bWRhdC53cml0ZShzdHJlYW0pO1xuXHRyZXR1cm4gc3RyZWFtO1xufTtcblxuLyogTW9kaWZ5IHRoZSBmaWxlIGFuZCBjcmVhdGUgdGhlIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgKi9cbklTT0ZpbGUud3JpdGVJbml0aWFsaXphdGlvblNlZ21lbnQgPSBmdW5jdGlvbihmdHlwLCBtb292LCB0b3RhbF9kdXJhdGlvbiwgc2FtcGxlX2R1cmF0aW9uKSB7XG5cdHZhciBpO1xuXHRMb2cuZGVidWcoXCJJU09GaWxlXCIsIFwiR2VuZXJhdGluZyBpbml0aWFsaXphdGlvbiBzZWdtZW50XCIpO1xuXG5cdHZhciBzdHJlYW0gPSBuZXcgRGF0YVN0cmVhbSgpO1xuXHRzdHJlYW0uZW5kaWFubmVzcyA9IERhdGFTdHJlYW0uQklHX0VORElBTjtcblx0ZnR5cC53cml0ZShzdHJlYW0pO1xuXHRcblx0Lyogd2UgY2FuIG5vdyBjcmVhdGUgdGhlIG5ldyBtdmV4IGJveCAqL1xuXHR2YXIgbXZleCA9IG1vb3YuYWRkKFwibXZleFwiKTtcblx0aWYgKHRvdGFsX2R1cmF0aW9uKSB7XG5cdFx0bXZleC5hZGQoXCJtZWhkXCIpLnNldChcImZyYWdtZW50X2R1cmF0aW9uXCIsIHRvdGFsX2R1cmF0aW9uKTtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgbW9vdi50cmFrcy5sZW5ndGg7IGkrKykge1xuXHRcdG12ZXguYWRkKFwidHJleFwiKS5zZXQoXCJ0cmFja19pZFwiLCBtb292LnRyYWtzW2ldLnRraGQudHJhY2tfaWQpXG5cdFx0XHRcdFx0XHQuc2V0KFwiZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcIiwgMSlcblx0XHRcdFx0XHRcdC5zZXQoXCJkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblwiLCBzYW1wbGVfZHVyYXRpb24pXG5cdFx0XHRcdFx0XHQuc2V0KFwiZGVmYXVsdF9zYW1wbGVfc2l6ZVwiLCAwKVxuXHRcdFx0XHRcdFx0LnNldChcImRlZmF1bHRfc2FtcGxlX2ZsYWdzXCIsIDE8PDE2KTtcblx0fVxuXHRtb292LndyaXRlKHN0cmVhbSk7XG5cblx0cmV0dXJuIHN0cmVhbS5idWZmZXI7XG5cbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBzdHJlYW0gPSBuZXcgRGF0YVN0cmVhbSgpO1xuXHRzdHJlYW0uZW5kaWFubmVzcyA9IERhdGFTdHJlYW0uQklHX0VORElBTjtcblx0dGhpcy53cml0ZShzdHJlYW0pO1xuXHRzdHJlYW0uc2F2ZShuYW1lKTtcdFxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzdHJlYW0gPSBuZXcgRGF0YVN0cmVhbSgpO1xuXHRzdHJlYW0uZW5kaWFubmVzcyA9IERhdGFTdHJlYW0uQklHX0VORElBTjtcblx0dGhpcy53cml0ZShzdHJlYW0pO1xuXHRyZXR1cm4gc3RyZWFtLmJ1ZmZlcjtcbn07XG5cbklTT0ZpbGUucHJvdG90eXBlLmluaXRpYWxpemVTZWdtZW50YXRpb24gPSBmdW5jdGlvbigpIHtcblx0dmFyIGk7XG5cdHZhciBpbml0U2Vncztcblx0dmFyIHRyYWs7XG5cdHZhciBzZWc7XG5cdGlmICh0aGlzLm9uU2VnbWVudCA9PT0gbnVsbCkge1xuXHRcdExvZy53YXJuKFwiTVA0Qm94XCIsIFwiTm8gc2VnbWVudGF0aW9uIGNhbGxiYWNrIHNldCFcIik7XG5cdH1cblx0aWYgKCF0aGlzLmlzRnJhZ21lbnRhdGlvbkluaXRpYWxpemVkKSB7XG5cdFx0dGhpcy5pc0ZyYWdtZW50YXRpb25Jbml0aWFsaXplZCA9IHRydWU7XHRcdFxuXHRcdHRoaXMubmV4dE1vb2ZOdW1iZXIgPSAwO1xuXHRcdHRoaXMucmVzZXRUYWJsZXMoKTtcblx0fVx0XG5cdGluaXRTZWdzID0gW107XHRcblx0Zm9yIChpID0gMDsgaSA8IHRoaXMuZnJhZ21lbnRlZFRyYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBtb292ID0gbmV3IEJveFBhcnNlci5tb292Qm94KCk7XG5cdFx0bW9vdi5tdmhkID0gdGhpcy5tb292Lm12aGQ7XG5cdCAgICBtb292LmJveGVzLnB1c2gobW9vdi5tdmhkKTtcblx0XHR0cmFrID0gdGhpcy5nZXRUcmFja0J5SWQodGhpcy5mcmFnbWVudGVkVHJhY2tzW2ldLmlkKTtcblx0XHRtb292LmJveGVzLnB1c2godHJhayk7XG5cdFx0bW9vdi50cmFrcy5wdXNoKHRyYWspO1xuXHRcdHNlZyA9IHt9O1xuXHRcdHNlZy5pZCA9IHRyYWsudGtoZC50cmFja19pZDtcblx0XHRzZWcudXNlciA9IHRoaXMuZnJhZ21lbnRlZFRyYWNrc1tpXS51c2VyO1xuXHRcdHNlZy5idWZmZXIgPSBJU09GaWxlLndyaXRlSW5pdGlhbGl6YXRpb25TZWdtZW50KHRoaXMuZnR5cCwgbW9vdiwgKHRoaXMubW9vdi5tdmV4ICYmIHRoaXMubW9vdi5tdmV4Lm1laGQgPyB0aGlzLm1vb3YubXZleC5tZWhkLmZyYWdtZW50X2R1cmF0aW9uOiB1bmRlZmluZWQpLCAodGhpcy5tb292LnRyYWtzW2ldLnNhbXBsZXMubGVuZ3RoPjAgPyB0aGlzLm1vb3YudHJha3NbaV0uc2FtcGxlc1swXS5kdXJhdGlvbjogMCkpO1xuXHRcdGluaXRTZWdzLnB1c2goc2VnKTtcblx0fVxuXHRyZXR1cm4gaW5pdFNlZ3M7XG59O1xuXG4vLyBmaWxlOnNyYy9ib3gtcHJpbnQuanNcbi8qIFxuICogQ29weXJpZ2h0IChjKSBUZWxlY29tIFBhcmlzVGVjaC9UU0kvTU0vR1BBQyBDeXJpbCBDb25jb2xhdG9cbiAqIExpY2Vuc2U6IEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgZmlsZSlcbiAqL1xuQm94UGFyc2VyLkJveC5wcm90b3R5cGUucHJpbnRIZWFkZXIgPSBmdW5jdGlvbihvdXRwdXQpIHtcblx0dGhpcy5zaXplICs9IDg7XG5cdGlmICh0aGlzLnNpemUgPiBNQVhfU0laRSkge1xuXHRcdHRoaXMuc2l6ZSArPSA4O1xuXHR9XG5cdGlmICh0aGlzLnR5cGUgPT09IFwidXVpZFwiKSB7XG5cdFx0dGhpcy5zaXplICs9IDE2O1xuXHR9XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcInNpemU6XCIrdGhpcy5zaXplKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1widHlwZTpcIit0aGlzLnR5cGUpO1xufTtcblxuQm94UGFyc2VyLkZ1bGxCb3gucHJvdG90eXBlLnByaW50SGVhZGVyID0gZnVuY3Rpb24ob3V0cHV0KSB7XG5cdHRoaXMuc2l6ZSArPSA0O1xuXHRCb3hQYXJzZXIuQm94LnByb3RvdHlwZS5wcmludEhlYWRlci5jYWxsKHRoaXMsIG91dHB1dCk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcInZlcnNpb246XCIrdGhpcy52ZXJzaW9uKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1wiZmxhZ3M6XCIrdGhpcy5mbGFncyk7XG59O1xuXG5Cb3hQYXJzZXIuQm94LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuXHR0aGlzLnByaW50SGVhZGVyKG91dHB1dCk7XG59O1xuXG5Cb3hQYXJzZXIuQ29udGFpbmVyQm94LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuXHR0aGlzLnByaW50SGVhZGVyKG91dHB1dCk7XG5cdGZvciAodmFyIGk9MDsgaTx0aGlzLmJveGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHRoaXMuYm94ZXNbaV0pIHtcblx0XHRcdHZhciBwcmV2X2luZGVudCA9IG91dHB1dC5pbmRlbnQ7XG5cdFx0XHRvdXRwdXQuaW5kZW50ICs9IFwiIFwiO1xuXHRcdFx0dGhpcy5ib3hlc1tpXS5wcmludChvdXRwdXQpO1xuXHRcdFx0b3V0cHV0LmluZGVudCA9IHByZXZfaW5kZW50O1xuXHRcdH1cblx0fVxufTtcblxuSVNPRmlsZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbihvdXRwdXQpIHtcblx0b3V0cHV0LmluZGVudCA9IFwiXCI7XG5cdGZvciAodmFyIGk9MDsgaTx0aGlzLmJveGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHRoaXMuYm94ZXNbaV0pIHtcblx0XHRcdHRoaXMuYm94ZXNbaV0ucHJpbnQob3V0cHV0KTtcblx0XHR9XG5cdH1cdFxufTtcblxuQm94UGFyc2VyLm12aGRCb3gucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24ob3V0cHV0KSB7XG5cdEJveFBhcnNlci5GdWxsQm94LnByb3RvdHlwZS5wcmludEhlYWRlci5jYWxsKHRoaXMsIG91dHB1dCk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcImNyZWF0aW9uX3RpbWU6IFwiK3RoaXMuY3JlYXRpb25fdGltZSk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcIm1vZGlmaWNhdGlvbl90aW1lOiBcIit0aGlzLm1vZGlmaWNhdGlvbl90aW1lKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1widGltZXNjYWxlOiBcIit0aGlzLnRpbWVzY2FsZSk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcImR1cmF0aW9uOiBcIit0aGlzLmR1cmF0aW9uKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1wicmF0ZTogXCIrdGhpcy5yYXRlKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1widm9sdW1lOiBcIisodGhpcy52b2x1bWU+PjgpKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1wibWF0cml4OiBcIit0aGlzLm1hdHJpeC5qb2luKFwiLCBcIikpO1xuXHRvdXRwdXQubG9nKG91dHB1dC5pbmRlbnQrXCJuZXh0X3RyYWNrX2lkOiBcIit0aGlzLm5leHRfdHJhY2tfaWQpO1xufTtcblxuQm94UGFyc2VyLnRraGRCb3gucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24ob3V0cHV0KSB7XG5cdEJveFBhcnNlci5GdWxsQm94LnByb3RvdHlwZS5wcmludEhlYWRlci5jYWxsKHRoaXMsIG91dHB1dCk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcImNyZWF0aW9uX3RpbWU6IFwiK3RoaXMuY3JlYXRpb25fdGltZSk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcIm1vZGlmaWNhdGlvbl90aW1lOiBcIit0aGlzLm1vZGlmaWNhdGlvbl90aW1lKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1widHJhY2tfaWQ6IFwiK3RoaXMudHJhY2tfaWQpO1xuXHRvdXRwdXQubG9nKG91dHB1dC5pbmRlbnQrXCJkdXJhdGlvbjogXCIrdGhpcy5kdXJhdGlvbik7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcInZvbHVtZTogXCIrKHRoaXMudm9sdW1lPj44KSk7XG5cdG91dHB1dC5sb2cob3V0cHV0LmluZGVudCtcIm1hdHJpeDogXCIrdGhpcy5tYXRyaXguam9pbihcIiwgXCIpKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1wibGF5ZXI6IFwiK3RoaXMubGF5ZXIpO1xuXHRvdXRwdXQubG9nKG91dHB1dC5pbmRlbnQrXCJhbHRlcm5hdGVfZ3JvdXA6IFwiK3RoaXMuYWx0ZXJuYXRlX2dyb3VwKTtcblx0b3V0cHV0LmxvZyhvdXRwdXQuaW5kZW50K1wid2lkdGg6IFwiK3RoaXMud2lkdGgpO1xuXHRvdXRwdXQubG9nKG91dHB1dC5pbmRlbnQrXCJoZWlnaHQ6IFwiK3RoaXMuaGVpZ2h0KTtcbn07Ly8gZmlsZTpzcmMvbXA0Ym94LmpzXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTMuIFRlbGVjb20gUGFyaXNUZWNoL1RTSS9NTS9HUEFDIEN5cmlsIENvbmNvbGF0b1xuICogTGljZW5zZTogQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBmaWxlKVxuICovXG52YXIgTVA0Qm94ID0ge307XG5cbk1QNEJveC5jcmVhdGVGaWxlID0gZnVuY3Rpb24gKF9rZWVwTWRhdERhdGEsIF9zdHJlYW0pIHtcblx0LyogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIGJ5dGVzIGNvbnRhaW5pbmcgbWVkaWEgZGF0YSBzaG91bGQgYmUga2VwdCBpbiBtZW1vcnkgKi9cblx0dmFyIGtlZXBNZGF0RGF0YSA9IChfa2VlcE1kYXREYXRhICE9PSB1bmRlZmluZWQgPyBfa2VlcE1kYXREYXRhIDogdHJ1ZSk7XG5cdHZhciBmaWxlID0gbmV3IElTT0ZpbGUoX3N0cmVhbSk7XG5cdGZpbGUuZGlzY2FyZE1kYXREYXRhID0gKGtlZXBNZGF0RGF0YSA/IGZhbHNlIDogdHJ1ZSk7XG5cdHJldHVybiBmaWxlO1xufTtcblxue1xuXHRleHBvcnRzLmNyZWF0ZUZpbGUgPSBNUDRCb3guY3JlYXRlRmlsZTtcbn1cbn0obXA0Ym94X2FsbCkpO1xuXG4vKipcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJjb2RlY3MvYmxvYi9tYWluL3NhbXBsZXMvbXA0LWRlY29kZS9tcDRfZGVtdXhlci5qc1xuICovXG52YXIgV3JpdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV3JpdGVyKHNpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV3JpdGVyKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB0aGlzLmlkeCA9IDA7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoV3JpdGVyLCBbe1xuICAgIGtleTogXCJnZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgICBpZiAodGhpcy5pZHggIT09IHRoaXMuc2l6ZSkgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaCBiZXR3ZWVuIHNpemUgcmVzZXJ2ZWQgYW5kIHNpemVkIHVzZWQnKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2UoMCwgdGhpcy5pZHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVVpbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlVWludDgodmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3ZhbHVlXSwgdGhpcy5pZHgpO1xuICAgICAgdGhpcy5pZHggKz0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVVaW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50MTYodmFsdWUpIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDE2QXJyYXkoMSk7XG4gICAgICBhcnJbMF0gPSB2YWx1ZTtcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyKTtcbiAgICAgIHRoaXMuZGF0YS5zZXQoW2J1ZmZlclsxXSwgYnVmZmVyWzBdXSwgdGhpcy5pZHgpO1xuICAgICAgdGhpcy5pZHggKz0gMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVVaW50OEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheSh2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhLnNldCh2YWx1ZSwgdGhpcy5pZHgpO1xuICAgICAgdGhpcy5pZHggKz0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV3JpdGVyO1xufSgpO1xuLyoqXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2ViY29kZWNzL2Jsb2IvbWFpbi9zYW1wbGVzL21wNC1kZWNvZGUvbXA0X2RlbXV4ZXIuanNcbiAqXG4gKiBAcGFyYW0gYXZjY0JveFxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBnZXRFeHRyYWRhdGEgPSBmdW5jdGlvbiBnZXRFeHRyYWRhdGEoYXZjY0JveCkge1xuICB2YXIgaTtcbiAgdmFyIHNpemUgPSA3O1xuICBmb3IgKGkgPSAwOyBpIDwgYXZjY0JveC5TUFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAvLyBuYWx1IGxlbmd0aCBpcyBlbmNvZGVkIGFzIGEgdWludDE2LlxuICAgIHNpemUgKz0gMiArIGF2Y2NCb3guU1BTW2ldLmxlbmd0aDtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgYXZjY0JveC5QUFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAvLyBuYWx1IGxlbmd0aCBpcyBlbmNvZGVkIGFzIGEgdWludDE2LlxuICAgIHNpemUgKz0gMiArIGF2Y2NCb3guUFBTW2ldLmxlbmd0aDtcbiAgfVxuICB2YXIgd3JpdGVyID0gbmV3IFdyaXRlcihzaXplKTtcbiAgd3JpdGVyLndyaXRlVWludDgoYXZjY0JveC5jb25maWd1cmF0aW9uVmVyc2lvbik7XG4gIHdyaXRlci53cml0ZVVpbnQ4KGF2Y2NCb3guQVZDUHJvZmlsZUluZGljYXRpb24pO1xuICB3cml0ZXIud3JpdGVVaW50OChhdmNjQm94LnByb2ZpbGVfY29tcGF0aWJpbGl0eSk7XG4gIHdyaXRlci53cml0ZVVpbnQ4KGF2Y2NCb3guQVZDTGV2ZWxJbmRpY2F0aW9uKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgd3JpdGVyLndyaXRlVWludDgoYXZjY0JveC5sZW5ndGhTaXplTWludXNPbmUgKyAoNjMgPDwgMikpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIHdyaXRlci53cml0ZVVpbnQ4KGF2Y2NCb3gubmJfU1BTX25hbHVzICsgKDcgPDwgNSkpO1xuICBmb3IgKGkgPSAwOyBpIDwgYXZjY0JveC5TUFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB3cml0ZXIud3JpdGVVaW50MTYoYXZjY0JveC5TUFNbaV0ubGVuZ3RoKTtcbiAgICB3cml0ZXIud3JpdGVVaW50OEFycmF5KGF2Y2NCb3guU1BTW2ldLm5hbHUpO1xuICB9XG4gIHdyaXRlci53cml0ZVVpbnQ4KGF2Y2NCb3gubmJfUFBTX25hbHVzKTtcbiAgZm9yIChpID0gMDsgaSA8IGF2Y2NCb3guUFBTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgd3JpdGVyLndyaXRlVWludDE2KGF2Y2NCb3guUFBTW2ldLmxlbmd0aCk7XG4gICAgd3JpdGVyLndyaXRlVWludDhBcnJheShhdmNjQm94LlBQU1tpXS5uYWx1KTtcbiAgfVxuICByZXR1cm4gd3JpdGVyLmdldERhdGEoKTtcbn07XG5cbi8qKlxuICogZGVjb2RlVmlkZW8gdGFrZXMgYW4gdXJsIHRvIGEgbXA0IGZpbGUgYW5kIGNvbnZlcnRzIGl0IGludG8gZnJhbWVzLlxuICpcbiAqIFRoZSBzdGVwcyBmb3IgdGhpcyBhcmU6XG4gKiAgMS4gRGV0ZXJtaW5lIHRoZSBjb2RlYyBmb3IgdGhpcyB2aWRlbyBmaWxlIGFuZCBkZW11eCBpdCBpbnRvIGNodW5rcy5cbiAqICAyLiBSZWFkIHRoZSBjaHVua3Mgd2l0aCBWaWRlb0RlY29kZXIgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAqICAzLiBSZXR1cm4gYW4gYXJyYXkgb2YgZnJhbWVzIHRoYXQgd2UgY2FuIGVmZmljaWVudGx5IGRyYXcgdG8gYSBjYW52YXMuXG4gKlxuICogQHBhcmFtIHNyY1xuICogQHBhcmFtIFZpZGVvRGVjb2RlclxuICogQHBhcmFtIEVuY29kZWRWaWRlb0NodW5rXG4gKiBAcGFyYW0gZW1pdEZyYW1lXG4gKiBAcGFyYW0gZGVidWdcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICovXG52YXIgZGVjb2RlVmlkZW8gPSBmdW5jdGlvbiBkZWNvZGVWaWRlbyhzcmMsIGVtaXRGcmFtZSwgX3JlZikge1xuICB2YXIgVmlkZW9EZWNvZGVyID0gX3JlZi5WaWRlb0RlY29kZXIsXG4gICAgRW5jb2RlZFZpZGVvQ2h1bmsgPSBfcmVmLkVuY29kZWRWaWRlb0NodW5rLFxuICAgIGRlYnVnID0gX3JlZi5kZWJ1ZztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoZGVidWcpIGNvbnNvbGUuaW5mbygnRGVjb2RpbmcgdmlkZW8gZnJvbScsIHNyYyk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZXMgbXA0Ym94IGZvciBkZW11eGluZ1xuICAgICAgdmFyIG1wNGJveGZpbGUgPSBtcDRib3hfYWxsLmNyZWF0ZUZpbGUoKTtcblxuICAgICAgLy8gSG9sZHMgdGhlIGNvZGVjIHZhbHVlXG4gICAgICB2YXIgY29kZWM7XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBWaWRlb0RlY29kZXIgaW5zdGFuY2VcbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IFZpZGVvRGVjb2Rlcih7XG4gICAgICAgIG91dHB1dDogZnVuY3Rpb24gb3V0cHV0KGZyYW1lKSB7XG4gICAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoZnJhbWUsIHtcbiAgICAgICAgICAgIHJlc2l6ZVF1YWxpdHk6ICdsb3cnXG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYml0bWFwKSB7XG4gICAgICAgICAgICBlbWl0RnJhbWUoYml0bWFwKTtcbiAgICAgICAgICAgIGZyYW1lLmNsb3NlKCk7XG4gICAgICAgICAgICBpZiAoZGVjb2Rlci5kZWNvZGVRdWV1ZVNpemUgPD0gMCkge1xuICAgICAgICAgICAgICAvLyBHaXZlIGl0IGFuIGV4dHJhIGhhbGYgc2Vjb25kIHRvIGZpbmlzaCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNvZGVyLnN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgICAgZGVjb2Rlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1wNGJveGZpbGUub25SZWFkeSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIGlmIChpbmZvICYmIGluZm8udmlkZW9UcmFja3MgJiYgaW5mby52aWRlb1RyYWNrc1swXSkge1xuICAgICAgICAgIHZhciBfaW5mbyR2aWRlb1RyYWNrcyA9IF9zbGljZWRUb0FycmF5KGluZm8udmlkZW9UcmFja3MsIDEpO1xuICAgICAgICAgIGNvZGVjID0gX2luZm8kdmlkZW9UcmFja3NbMF0uY29kZWM7XG4gICAgICAgICAgaWYgKGRlYnVnKSBjb25zb2xlLmluZm8oJ1ZpZGVvIHdpdGggY29kZWM6JywgY29kZWMpO1xuXG4gICAgICAgICAgLy8gR2V0cyB0aGUgYXZjY2JveCB1c2VkIGZvciByZWFkaW5nIGV4dHJhZGF0YVxuICAgICAgICAgIHZhciBhdmNjQm94ID0gbXA0Ym94ZmlsZS5tb292LnRyYWtzWzBdLm1kaWEubWluZi5zdGJsLnN0c2QuZW50cmllc1swXS5hdmNDO1xuICAgICAgICAgIHZhciBleHRyYWRhdGEgPSBnZXRFeHRyYWRhdGEoYXZjY0JveCk7XG5cbiAgICAgICAgICAvLyBjb25maWd1cmUgZGVjb2RlclxuICAgICAgICAgIGRlY29kZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBleHRyYWRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFNldHVwIG1wNGJveCBmaWxlIGZvciBicmVha2luZyBpdCBpbnRvIGNodW5rc1xuICAgICAgICAgIG1wNGJveGZpbGUuc2V0RXh0cmFjdGlvbk9wdGlvbnMoaW5mby52aWRlb1RyYWNrc1swXS5pZCk7XG4gICAgICAgICAgbXA0Ym94ZmlsZS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KG5ldyBFcnJvcignVVJMIHByb3ZpZGVkIGlzIG5vdCBhIHZhbGlkIG1wNCB2aWRlbyBmaWxlLicpKTtcbiAgICAgIH07XG4gICAgICBtcDRib3hmaWxlLm9uU2FtcGxlcyA9IGZ1bmN0aW9uICh0cmFja19pZCwgcmVmLCBzYW1wbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgICAgIHZhciB0eXBlID0gc2FtcGxlLmlzX3N5bmMgPyAna2V5JyA6ICdkZWx0YSc7XG4gICAgICAgICAgdmFyIGNodW5rID0gbmV3IEVuY29kZWRWaWRlb0NodW5rKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHNhbXBsZS5jdHMsXG4gICAgICAgICAgICBkdXJhdGlvbjogc2FtcGxlLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGF0YTogc2FtcGxlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEZldGNoZXMgdGhlIGZpbGUgaW50byBhcnJheWJ1ZmZlcnNcbiAgICAgIGZldGNoKHNyYykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZEJ1ZmZlcnMoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgZG9uZSA9IF9yZWYyLmRvbmUsXG4gICAgICAgICAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBtcDRib3hmaWxlLmZsdXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ1ZiA9IHZhbHVlLmJ1ZmZlcjtcbiAgICAgICAgICBidWYuZmlsZVN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBtcDRib3hmaWxlLmFwcGVuZEJ1ZmZlcihidWYpO1xuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oYXBwZW5kQnVmZmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbihhcHBlbmRCdWZmZXJzKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbiBmb3IgZGVjb2RpbmcgdmlkZW8uIERlYWxzIHdpdGggdGhlIHBvbHlmaWxsIGNhc2VzIGZpcnN0LFxuICogdGhlbiBjYWxscyBvdXIgZGVjb2RlVmlkZW8uXG4gKlxuICogQHBhcmFtIHNyY1xuICogQHBhcmFtIGVtaXRGcmFtZVxuICogQHBhcmFtIGRlYnVnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxuZXZlcj58UHJvbWlzZTx2b2lkPnwqfVxuICovXG52YXIgdmlkZW9EZWNvZGVyID0gKGZ1bmN0aW9uIChzcmMsIGVtaXRGcmFtZSwgZGVidWcpIHtcbiAgLy8gSWYgb3VyIGJyb3dzZXIgc3VwcG9ydHMgV2ViQ29kZWNzIG5hdGl2ZWx5XG4gIGlmICh0eXBlb2YgVmlkZW9EZWNvZGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBFbmNvZGVkVmlkZW9DaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5pbmZvKCdXZWJDb2RlY3MgaXMgbmF0aXZlbHkgc3VwcG9ydGVkLCB1c2luZyBuYXRpdmUgdmVyc2lvbi4uLicpO1xuICAgIHJldHVybiBkZWNvZGVWaWRlbyhzcmMsIGVtaXRGcmFtZSwge1xuICAgICAgVmlkZW9EZWNvZGVyOiBWaWRlb0RlY29kZXIsXG4gICAgICBFbmNvZGVkVmlkZW9DaHVuazogRW5jb2RlZFZpZGVvQ2h1bmssXG4gICAgICBkZWJ1ZzogZGVidWdcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgcmVzb2x2ZSBub3RoaW5nXG4gIGlmIChkZWJ1ZykgY29uc29sZS5pbmZvKCdXZWJDb2RlY3MgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn0pO1xuXG4vKipcbiAqICAgX19fXyAgICAgICAgICAgICAgICAgXyBfICAgICBfXyAgICAgX19fICAgICBfXG4gKiAgLyBfX198ICBfX18gXyBfXyBfX18gfCB8IHxfICAgXFwgXFwgICAvIChfKSBfX3wgfCBfX18gIF9fX1xuICogIFxcX19fIFxcIC8gX198ICdfXy8gXyBcXHwgfCB8IHwgfCBcXCBcXCAvIC98IHwvIF9gIHwvIF8gXFwvIF8gXFxcbiAqICAgX19fKSB8IChfX3wgfCB8IChfKSB8IHwgfCB8X3wgfFxcIFYgLyB8IHwgKF98IHwgIF9fLyAoXykgfFxuICogIHxfX19fLyBcXF9fX3xffCAgXFxfX18vfF98X3xcXF9fLCB8IFxcXy8gIHxffFxcX18sX3xcXF9fX3xcXF9fXy9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX18vXG4gKlxuICogUmVzcG9uc2l2ZSBzY3JvbGxhYmxlIHZpZGVvcyB3aXRob3V0IG9ic2N1cmUgdmlkZW8gZW5jb2RpbmcgcmVxdWlyZW1lbnRzLlxuICogQ29tcGF0aWJsZSB3aXRoIFJlYWN0LCBTdmVsdGUsIFZ1ZSwgYW5kIHBsYWluIEhUTUwuXG4gKi9cbnZhciBTY3JvbGx5VmlkZW8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGx5VmlkZW8oX3JlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHNyYyA9IF9yZWYuc3JjLFxuICAgICAgc2Nyb2xseVZpZGVvQ29udGFpbmVyID0gX3JlZi5zY3JvbGx5VmlkZW9Db250YWluZXIsXG4gICAgICBfcmVmJGNvdmVyID0gX3JlZi5jb3ZlcixcbiAgICAgIGNvdmVyID0gX3JlZiRjb3ZlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkY292ZXIsXG4gICAgICBfcmVmJHN0aWNreSA9IF9yZWYuc3RpY2t5LFxuICAgICAgc3RpY2t5ID0gX3JlZiRzdGlja3kgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHN0aWNreSxcbiAgICAgIF9yZWYkZnVsbCA9IF9yZWYuZnVsbCxcbiAgICAgIGZ1bGwgPSBfcmVmJGZ1bGwgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGZ1bGwsXG4gICAgICBfcmVmJHRyYWNrU2Nyb2xsID0gX3JlZi50cmFja1Njcm9sbCxcbiAgICAgIHRyYWNrU2Nyb2xsID0gX3JlZiR0cmFja1Njcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkdHJhY2tTY3JvbGwsXG4gICAgICBfcmVmJHRyYW5zaXRpb25TcGVlZCA9IF9yZWYudHJhbnNpdGlvblNwZWVkLFxuICAgICAgdHJhbnNpdGlvblNwZWVkID0gX3JlZiR0cmFuc2l0aW9uU3BlZWQgPT09IHZvaWQgMCA/IDggOiBfcmVmJHRyYW5zaXRpb25TcGVlZCxcbiAgICAgIF9yZWYkZnJhbWVUaHJlc2hvbGQgPSBfcmVmLmZyYW1lVGhyZXNob2xkLFxuICAgICAgZnJhbWVUaHJlc2hvbGQgPSBfcmVmJGZyYW1lVGhyZXNob2xkID09PSB2b2lkIDAgPyAwLjEgOiBfcmVmJGZyYW1lVGhyZXNob2xkLFxuICAgICAgX3JlZiR1c2VXZWJDb2RlY3MgPSBfcmVmLnVzZVdlYkNvZGVjcyxcbiAgICAgIHVzZVdlYkNvZGVjcyA9IF9yZWYkdXNlV2ViQ29kZWNzID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiR1c2VXZWJDb2RlY3MsXG4gICAgICBfcmVmJGRlYnVnID0gX3JlZi5kZWJ1ZyxcbiAgICAgIGRlYnVnID0gX3JlZiRkZWJ1ZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGRlYnVnO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGx5VmlkZW8pO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBET01cbiAgICBpZiAoKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTY3JvbGx5VmlkZW8gbXVzdCBiZSBpbml0aWF0ZWQgaW4gYSBET00gY29udGV4dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYmFzaWMgYXJndW1lbnRzIGFyZSBzZXQgZm9yIHNjcm9sbHl2aWRlb1xuICAgIGlmICghc2Nyb2xseVZpZGVvQ29udGFpbmVyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdzY3JvbGx5VmlkZW9Db250YWluZXIgbXVzdCBiZSBhIHZhbGlkIERPTSBvYmplY3QnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ011c3QgcHJvdmlkZSB2YWxpZCB2aWRlbyBzcmMgdG8gU2Nyb2xseVZpZGVvJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGUgY29udGFpbmVyLiBJZiB0aGUgY29udGFpbmVyIGlzIGEgc3RyaW5nIHdlIGdldCB0aGUgZWxlbWVudFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGlmIChzY3JvbGx5VmlkZW9Db250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB0aGlzLmNvbnRhaW5lciA9IHNjcm9sbHlWaWRlb0NvbnRhaW5lcjtcbiAgICAvLyBvdGhlcndpc2UgaXQgc2hvdWxkIGJldHRlciBiZSBhbiBlbGVtZW50XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjcm9sbHlWaWRlb0NvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzY3JvbGx5VmlkZW9Db250YWluZXIpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcikgdGhyb3cgbmV3IEVycm9yKCdzY3JvbGx5VmlkZW9Db250YWluZXIgbXVzdCBiZSBhIHZhbGlkIERPTSBvYmplY3QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY3JvbGx5VmlkZW9Db250YWluZXIgbXVzdCBiZSBhIHZhbGlkIERPTSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoZSBjb25zdHJ1Y3RvciBvcHRpb25zXG4gICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgdGhpcy50cmFuc2l0aW9uU3BlZWQgPSB0cmFuc2l0aW9uU3BlZWQ7XG4gICAgdGhpcy5mcmFtZVRocmVzaG9sZCA9IGZyYW1lVGhyZXNob2xkO1xuICAgIHRoaXMudXNlV2ViQ29kZWNzID0gdXNlV2ViQ29kZWNzO1xuICAgIHRoaXMuY292ZXIgPSBjb3ZlcjtcbiAgICB0aGlzLnN0aWNreSA9IHN0aWNreTtcbiAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgIHRoaXMudHJhY2tTY3JvbGwgPSB0cmFja1Njcm9sbDtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGluaXRpYWwgdmlkZW8gb2JqZWN0LiBFdmVuIGlmIHdlIGFyZSBnb2luZyB0byB1c2Ugd2ViY29kZWNzLFxuICAgIC8vIHdlIHN0YXJ0IHdpdGggYSBwYXVzZWQgdmlkZW8gb2JqZWN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdGhpcy52aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgdGhpcy52aWRlby5zcmMgPSBzcmM7XG4gICAgdGhpcy52aWRlby5wcmVsb2FkID0gJ2F1dG8nO1xuICAgIHRoaXMudmlkZW8udGFiSW5kZXggPSAwO1xuICAgIHRoaXMudmlkZW8uYXV0b2J1ZmZlciA9IHRydWU7XG4gICAgdGhpcy52aWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgdGhpcy52aWRlby5tdXRlZCA9IHRydWU7XG4gICAgdGhpcy52aWRlby5wYXVzZSgpO1xuICAgIHRoaXMudmlkZW8ubG9hZCgpO1xuXG4gICAgLy8gQWRkcyB0aGUgdmlkZW8gdG8gdGhlIGNvbnRhaW5lclxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudmlkZW8pO1xuXG4gICAgLy8gU2V0dGluZyBDU1MgcHJvcGVydGllcyBmb3Igc3RpY2t5XG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdzdGlja3knO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gJzAnO1xuICAgIH1cblxuICAgIC8vIFNldHRpbmcgQ1NTIHByb3BlcnRpZXMgZm9yIGZ1bGxcbiAgICBpZiAoZnVsbCkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIENTUyBwcm9wZXJ0aWVzIGZvciBjb3ZlclxuICAgIGlmIChjb3ZlcikgdGhpcy5zZXRDb3ZlclN0eWxlKHRoaXMudmlkZW8pO1xuXG4gICAgLy8gRGV0ZWN0IHdlYmtpdCAoc2FmYXJpKSwgYmVjYXVzZSB3ZWJraXQgcmVxdWlyZXMgc3BlY2lhbCBhdHRlbnRpb25cbiAgICB2YXIgYnJvd3NlckVuZ2luZSA9IG5ldyBVQVBhcnNlcigpLmdldEVuZ2luZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHRoaXMuaXNTYWZhcmkgPSBicm93c2VyRW5naW5lLm5hbWUgPT09ICdXZWJLaXQnO1xuICAgIGlmIChkZWJ1ZyAmJiB0aGlzLmlzU2FmYXJpKSBjb25zb2xlLmluZm8oJ1NhZmFyaSBicm93c2VyIGRldGVjdGVkJyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHN0YXRlIHZhcmlhYmxlc1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwOyAvLyBTYXZlcyB0aGUgY3VycmVudFRpbWUgb2YgdGhlIHZpZGVvLCBzeW5jZWQgd2l0aCB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lXG4gICAgdGhpcy50YXJnZXRUaW1lID0gMDsgLy8gVGhlIHRhcmdldCB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gaGFwcGVuc1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDsgLy8gVGhlIGNhbnZhcyBmb3IgZHJhd2luZyB0aGUgZnJhbWVzIGRlY29kZWQgYnkgd2ViQ29kZWNzXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDsgLy8gVGhlIGNhbnZhcyBjb250ZXh0XG4gICAgdGhpcy5mcmFtZXMgPSBbXTsgLy8gVGhlIGZyYW1lcyBkZWNvZGVkIGJ5IHdlYkNvZGVjc1xuICAgIHRoaXMuZnJhbWVSYXRlID0gMDsgLy8gQ2FsY3VsYXRpb24gb2YgZnJhbWVSYXRlIHNvIHdlIGtub3cgd2hpY2ggZnJhbWUgdG8gcGFpbnRcblxuICAgIC8vIEFkZCBzY3JvbGwgbGlzdGVuZXIgZm9yIHJlc3BvbmRpbmcgdG8gc2Nyb2xsIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVTY3JvbGxQZXJjZW50YWdlID0gZnVuY3Rpb24gKGp1bXApIHtcbiAgICAgIC8vIFVzZWQgZm9yIGludGVybmFsbHkgc2V0dGluZyB0aGUgc2Nyb2xsIHBlcmNlbnRhZ2UgYmFzZWQgb24gYnVpbHQtaW4gbGlzdGVuZXJzXG4gICAgICB2YXIgY29udGFpbmVyQm91bmRpbmdDbGllbnRSZWN0ID0gX3RoaXMuY29udGFpbmVyLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY3VycmVudCBzY3JvbGwgcGVyY2VudCBvZiB0aGUgdmlkZW9cbiAgICAgIHZhciBzY3JvbGxQZXJjZW50ID0gLWNvbnRhaW5lckJvdW5kaW5nQ2xpZW50UmVjdC50b3BcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgLyAoY29udGFpbmVyQm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBpZiAoX3RoaXMuZGVidWcpIGNvbnNvbGUuaW5mbygnU2Nyb2xseVZpZGVvIHNjcm9sbGVkIHRvJywgc2Nyb2xsUGVyY2VudCk7XG5cbiAgICAgIC8vIFNldCB0aGUgdGFyZ2V0IHRpbWUgcGVyY2VudFxuICAgICAgX3RoaXMuc2V0VGFyZ2V0VGltZVBlcmNlbnQoc2Nyb2xsUGVyY2VudCwganVtcCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBvdXIgZXZlbnQgbGlzdGVuZXJzIGZvciBoYW5kbGluZyBjaGFuZ2VzIHRvIHRoZSB3aW5kb3cgb3Igc2Nyb2xsXG4gICAgaWYgKHRoaXMudHJhY2tTY3JvbGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlU2Nyb2xsUGVyY2VudGFnZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCBzY3JvbGwgcGVyY2VudGFnZVxuICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZVNjcm9sbFBlcmNlbnRhZ2UodHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2V0VGFyZ2V0VGltZVBlcmNlbnQoMCwgdHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNpemUgZnVuY3Rpb25cbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5kZWJ1ZykgY29uc29sZS5pbmZvKCdTY3JvbGx5VmlkZW8gcmVzaXppbmcuLi4nKTtcbiAgICAgIC8vIE9uIHJlc2l6ZSwgd2UgbmVlZCB0byByZXNldCB0aGUgY292ZXIgc3R5bGVcbiAgICAgIGlmIChfdGhpcy5jb3ZlcikgX3RoaXMuc2V0Q292ZXJTdHlsZShfdGhpcy5jYW52YXMgfHwgX3RoaXMudmlkZW8pO1xuICAgICAgLy8gVGhlbiByZXBhaW50IHRoZSBjYW52YXMsIGlmIHdlIGFyZSBpbiB1c2VXZWJjb2RlY3NcbiAgICAgIF90aGlzLnBhaW50Q2FudmFzRnJhbWUoTWF0aC5mbG9vcihfdGhpcy5jdXJyZW50VGltZSAqIF90aGlzLmZyYW1lUmF0ZSkpO1xuICAgIH07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUpO1xuICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLnJlc2l6ZSk7XG5cbiAgICAvLyBDYWxscyBkZWNvZGUgdmlkZW8gdG8gYXR0ZW1wdCB3ZWJjb2RlY3MgbWV0aG9kXG4gICAgdGhpcy5kZWNvZGVWaWRlbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0eWxlIG9mIHRoZSB2aWRlbyBvciBjYW52YXMgdG8gXCJjb3ZlclwiIGl0J3MgY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBlbFxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFNjcm9sbHlWaWRlbywgW3tcbiAgICBrZXk6IFwic2V0Q292ZXJTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb3ZlclN0eWxlKGVsKSB7XG4gICAgICBpZiAodGhpcy5jb3Zlcikge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9ICc1MCUnO1xuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gJzUwJSc7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknO1xuICAgICAgICBlbC5zdHlsZS5taW5XaWR0aCA9ICcxMDElJztcbiAgICAgICAgZWwuc3R5bGUubWluSGVpZ2h0ID0gJzEwMSUnO1xuXG4gICAgICAgIC8vIEdldHMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICB2YXIgX3RoaXMkY29udGFpbmVyJGdldEJvID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgY29udGFpbmVyV2lkdGggPSBfdGhpcyRjb250YWluZXIkZ2V0Qm8ud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gX3RoaXMkY29udGFpbmVyJGdldEJvLmhlaWdodDtcblxuICAgICAgICAvLyBHZXRzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWRlbyBmcmFtZXNcbiAgICAgICAgdmFyIHdpZHRoID0gZWwudmlkZW9XaWR0aCB8fCBlbC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLnZpZGVvSGVpZ2h0IHx8IGVsLmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIGNvbnNvbGUuaW5mbygnQ29udGFpbmVyIGRpbWVuc2lvbnM6JywgW2NvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHRdKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIGNvbnNvbGUuaW5mbygnRWxlbWVudCBkaW1lbnNpb25zOicsIFt3aWR0aCwgaGVpZ2h0XSk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyB3aGljaCBheGlzIG5lZWRzIHRvIGJlIDEwMCUgYW5kIHdoaWNoIG5lZWRzIHRvIGJlIHNjYWxlZFxuICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQgPiB3aWR0aCAvIGhlaWdodCkge1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgd2ViQ29kZWNzIHRvIGRlY29kZSB0aGUgdmlkZW8gaW50byBmcmFtZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVWaWRlb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVWaWRlbygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMudXNlV2ViQ29kZWNzICYmIHRoaXMuc3JjKSB7XG4gICAgICAgIHZpZGVvRGVjb2Rlcih0aGlzLnNyYywgZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgX3RoaXMyLmZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgfSwgdGhpcy5kZWJ1ZylbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5kZWJ1ZykgY29uc29sZS5lcnJvcignRXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgdmlkZW8nKTtcbiAgICAgICAgICAvLyBSZW1vdmUgYWxsIGRlY29kZWQgZnJhbWVzIGlmIGEgZmFpbHVyZSBoYXBwZW5zIGR1cmluZyBkZWNvZGluZ1xuICAgICAgICAgIF90aGlzMi5mcmFtZXMgPSBbXTtcblxuICAgICAgICAgIC8vIEZvcmNlIGEgdmlkZW8gcmVsb2FkIHdoZW4gdmlkZW9EZWNvZGVyIGZhaWxzXG4gICAgICAgICAgX3RoaXMyLnZpZGVvLmxvYWQoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSWYgbm8gZnJhbWVzLCBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgIGlmIChfdGhpczIuZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5kZWJ1ZykgY29uc29sZS5lcnJvcignTm8gZnJhbWVzIHdlcmUgcmVjZWl2ZWQgZnJvbSB3ZWJDb2RlY3MnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyYW1lUmF0ZSBiYXNlZCBvbiBudW1iZXIgb2YgZnJhbWVzIGFuZCB0aGUgZHVyYXRpb25cbiAgICAgICAgICBfdGhpczIuZnJhbWVSYXRlID0gX3RoaXMyLmZyYW1lcy5sZW5ndGggLyBfdGhpczIudmlkZW8uZHVyYXRpb247XG4gICAgICAgICAgaWYgKF90aGlzMi5kZWJ1ZykgY29uc29sZS5pbmZvKCdSZWNlaXZlZCcsIF90aGlzMi5mcmFtZXMubGVuZ3RoLCAnZnJhbWVzJyk7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHZpZGVvIGFuZCBhZGQgdGhlIGNhbnZhc1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICAgIF90aGlzMi5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBfdGhpczIuY29udGV4dCA9IF90aGlzMi5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgIC8vIEhpZGUgdGhlIHZpZGVvIGFuZCBhZGQgdGhlIGNhbnZhcyB0byB0aGUgY29udGFpbmVyXG4gICAgICAgICAgX3RoaXMyLnZpZGVvLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgX3RoaXMyLmNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpczIuY2FudmFzKTtcbiAgICAgICAgICBpZiAoX3RoaXMyLmNvdmVyKSBfdGhpczIuc2V0Q292ZXJTdHlsZShfdGhpczIuY2FudmFzKTtcblxuICAgICAgICAgIC8vIFBhaW50IG91ciBmaXJzdCBmcmFtZVxuICAgICAgICAgIF90aGlzMi5wYWludENhbnZhc0ZyYW1lKE1hdGguZmxvb3IoX3RoaXMyLmN1cnJlbnRUaW1lICogX3RoaXMyLmZyYW1lUmF0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWludHMgdGhlIGZyYW1lIG9mIHRvIHRoZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmFtZU51bVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhaW50Q2FudmFzRnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFpbnRDYW52YXNGcmFtZShmcmFtZU51bSkge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZnJhbWUgYW5kIHBhaW50IGl0IHRvIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIGN1cnJGcmFtZSA9IHRoaXMuZnJhbWVzW2ZyYW1lTnVtXTtcbiAgICAgICAgaWYgKGN1cnJGcmFtZSkge1xuICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSBjb25zb2xlLmluZm8oJ1BhaW50aW5nIGZyYW1lJywgZnJhbWVOdW0pO1xuXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHByb3Blcmx5LCBzaW1pbGFyIHRvIHNldENvdmVyU3R5bGVcbiAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGN1cnJGcmFtZS53aWR0aDtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBjdXJyRnJhbWUuaGVpZ2h0O1xuICAgICAgICAgIHZhciBfdGhpcyRjb250YWluZXIkZ2V0Qm8yID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICB3aWR0aCA9IF90aGlzJGNvbnRhaW5lciRnZXRCbzIud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRjb250YWluZXIkZ2V0Qm8yLmhlaWdodDtcbiAgICAgICAgICBpZiAod2lkdGggLyBoZWlnaHQgPiBjdXJyRnJhbWUud2lkdGggLyBjdXJyRnJhbWUuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHJhdyB0aGUgZnJhbWUgdG8gdGhlIGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShjdXJyRnJhbWUsIDAsIDAsIGN1cnJGcmFtZS53aWR0aCwgY3VyckZyYW1lLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9ucyB0aGUgdmlkZW8gb3IgdGhlIGNhbnZhcyB0byB0aGUgcHJvcGVyIGZyYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganVtcFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRyYW5zaXRpb25Ub1RhcmdldFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNpdGlvblRvVGFyZ2V0VGltZShqdW1wKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnVHJhbnNpdGlvbmluZyB0YXJnZXRUaW1lOicsIHRoaXMudGFyZ2V0VGltZSwgJ2N1cnJlbnRUaW1lOicsIHRoaXMuY3VycmVudFRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBjbG9zZSBlbm91Z2ggdG8gb3VyIHRhcmdldCwgcGF1c2UgdGhlIHZpZGVvIGFuZCByZXR1cm4uXG4gICAgICAvLyBUaGlzIGlzIHRoZSBiYXNlIGNhc2Ugb2YgdGhlIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgaXNOYU4odGhpcy50YXJnZXRUaW1lKVxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnRUaW1lIGlzIGFscmVhZHkgY2xvc2UgZW5vdWdoIHRvIHRoZSB0YXJnZXRUaW1lXG4gICAgICB8fCBNYXRoLmFicyh0aGlzLmN1cnJlbnRUaW1lIC0gdGhpcy50YXJnZXRUaW1lKSA8IHRoaXMuZnJhbWVUaHJlc2hvbGQpIHtcbiAgICAgICAgdGhpcy52aWRlby5wYXVzZSgpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgZ28gb3V0IG9mIHRpbWUgYm91bmRzXG4gICAgICBpZiAodGhpcy50YXJnZXRUaW1lID4gdGhpcy52aWRlby5kdXJhdGlvbikgdGhpcy50YXJnZXRUaW1lID0gdGhpcy52aWRlby5kdXJhdGlvbjtcbiAgICAgIGlmICh0aGlzLnRhcmdldFRpbWUgPCAwKSB0aGlzLnRhcmdldFRpbWUgPSAwO1xuXG4gICAgICAvLyBIb3cgZmFyIGZvcndhcmQgd2UgbmVlZCB0byB0cmFuc2l0aW9uXG4gICAgICB2YXIgdHJhbnNpdGlvbkZvcndhcmQgPSB0aGlzLnRhcmdldFRpbWUgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50VGltZSBhbmQgcGFpbnQgdGhlIGNsb3Nlc3QgZnJhbWVcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSArPSB0cmFuc2l0aW9uRm9yd2FyZCAvICgyNTYgLyB0aGlzLnRyYW5zaXRpb25TcGVlZCk7XG4gICAgICAgIC8vIElmIGp1bXAsIHdlIGdvIGRpcmVjdGx5IHRvIHRoZSBmcmFtZVxuICAgICAgICBpZiAoanVtcCkgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMudGFyZ2V0VGltZTtcbiAgICAgICAgdGhpcy5wYWludENhbnZhc0ZyYW1lKE1hdGguZmxvb3IodGhpcy5jdXJyZW50VGltZSAqIHRoaXMuZnJhbWVSYXRlKSk7XG4gICAgICB9IGVsc2UgaWYgKGp1bXAgfHwgdGhpcy5pc1NhZmFyaSB8fCB0aGlzLnRhcmdldFRpbWUgLSB0aGlzLmN1cnJlbnRUaW1lIDwgMCkge1xuICAgICAgICAvLyBXZSBjYW4ndCB1c2UgYSBuZWdhdGl2ZSBwbGF5YmFja1JhdGUsIHNvIGlmIHRoZSB2aWRlbyBuZWVkcyB0byBnbyBiYWNrd2FyZHMsXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gdXNlIHRoZSBpbmVmZmljaWVudCBtZXRob2Qgb2YgbW9kaWZ5aW5nIGN1cnJlbnRUaW1lIHJhcGlkbHkgdG9cbiAgICAgICAgLy8gZ2V0IGFuIGVmZmVjdC5cbiAgICAgICAgdGhpcy52aWRlby5wYXVzZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IHRyYW5zaXRpb25Gb3J3YXJkIC8gKDY0IC8gdGhpcy50cmFuc2l0aW9uU3BlZWQpO1xuICAgICAgICAvLyBJZiBqdW1wLCB3ZSBnbyBkaXJlY3RseSB0byB0aGUgZnJhbWVcbiAgICAgICAgaWYgKGp1bXApIHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLnRhcmdldFRpbWU7XG4gICAgICAgIHRoaXMudmlkZW8uY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBwbGF5IHRoZSB2aWRlbyBhbmQgYWRqdXN0IHRoZSBwbGF5YmFja1JhdGUgdG8gZ2V0IGEgc21vb3RoZXJcbiAgICAgICAgLy8gYW5pbWF0aW9uIGVmZmVjdC5cbiAgICAgICAgdmFyIHBsYXliYWNrUmF0ZSA9IE1hdGgubWF4KE1hdGgubWluKHRyYW5zaXRpb25Gb3J3YXJkICogNCwgdGhpcy50cmFuc2l0aW9uU3BlZWQsIDE2KSwgMSk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSBjb25zb2xlLmluZm8oJ1Njcm9sbHlWaWRlbyBwbGF5YmFja1JhdGU6JywgcGxheWJhY2tSYXRlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICBpZiAoIWlzTmFOKHBsYXliYWNrUmF0ZSkpIHtcbiAgICAgICAgICB0aGlzLnZpZGVvLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICB0aGlzLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnRUaW1lIHRvIHRoZSB2aWRlbydzIGN1cnJlbnRUaW1lXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjYWxscyBvdXJzZWx2ZXMgdW50aWwgdGhlIGFuaW1hdGlvbiBpcyBkb25lLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnRyYW5zaXRpb25Ub1RhcmdldFRpbWUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudFRpbWUgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB2aWRlbyBkdXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXRQZXJjZW50YWdlXG4gICAgICogQHBhcmFtIGp1bXBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRUYXJnZXRUaW1lUGVyY2VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUYXJnZXRUaW1lUGVyY2VudChzZXRQZXJjZW50YWdlLCBqdW1wKSB7XG4gICAgICAvLyBUaGUgdGltZSB3ZSB3YW50IHRvIHRyYW5zaXRpb24gdG9cbiAgICAgIHRoaXMudGFyZ2V0VGltZSA9IE1hdGgubWF4KE1hdGgubWluKHNldFBlcmNlbnRhZ2UsIDEpLCAwKSAqICh0aGlzLmZyYW1lcy5sZW5ndGggJiYgdGhpcy5mcmFtZVJhdGUgPyB0aGlzLmZyYW1lcy5sZW5ndGggLyB0aGlzLmZyYW1lUmF0ZSA6IHRoaXMudmlkZW8uZHVyYXRpb24pO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgY2xvc2UgZW5vdWdoLCByZXR1cm4gZWFybHlcbiAgICAgIGlmICghanVtcCAmJiBNYXRoLmFicyh0aGlzLmN1cnJlbnRUaW1lIC0gdGhpcy50YXJnZXRUaW1lKSA8IHRoaXMuZnJhbWVUaHJlc2hvbGQpIHJldHVybjtcblxuICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgdHJhbnNpdGlvbmluZywgYmFpbCBlYXJseVxuICAgICAgaWYgKCFqdW1wICYmIHRoaXMudHJhbnNpdGlvbmluZykgcmV0dXJuO1xuXG4gICAgICAvLyBQbGF5IHRoZSB2aWRlbyBpZiB3ZSBhcmUgaW4gdmlkZW8gbW9kZVxuICAgICAgaWYgKCF0aGlzLmNhbnZhcyAmJiAhdGhpcy52aWRlby5wYXVzZWQpIHRoaXMudmlkZW8ucGxheSgpO1xuXG4gICAgICAvLyBTZXQgdHJhbnNpdGlvbmluZyBzdGF0ZSB0byB0cnVlIGFuZCBiZWdpbiB0cmFuc2l0aW9uXG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVG9UYXJnZXRUaW1lKGp1bXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdG8gZGVzdHJveSB0aGlzIFNjcm9sbHlWaWRlbyBvYmplY3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5kZWJ1ZykgY29uc29sZS5pbmZvKCdEZXN0cm95aW5nIFNjcm9sbHlWaWRlbycpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIGlmICh0aGlzLnRyYWNrU2Nyb2xsKSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVTY3JvbGxQZXJjZW50YWdlKTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUpO1xuXG4gICAgICAvLyBDbGVhciBjb21wb25lbnRcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTY3JvbGx5VmlkZW87XG59KCk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ2aWRlb1BlcmNlbnRhZ2VcIl07XG5mdW5jdGlvbiBTY3JvbGx5VmlkZW9Db21wb25lbnQocHJvcHMpIHtcbiAgLy8gdmFyaWFibGUgdG8gaG9sZCB0aGUgRE9NIGVsZW1lbnRcbiAgdmFyIGNvbnRhaW5lckVsZW1lbnQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgLy8gcmVmIHRvIGhvbGQgdGhlIHNjcm9sbHlWaWRlbyBvYmplY3RcbiAgdmFyIHNjcm9sbHlWaWRlb1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICAvLyBTdG9yZSB0aGUgcHJvcHMgc28gd2Uga25vdyB3aGVuIHRoaW5ncyBjaGFuZ2VcbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKCcnKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBsYXN0UHJvcHNTdHJpbmcgPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldExhc3RQcm9wc1N0cmluZyA9IF91c2VTdGF0ZTJbMV07XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgIC8vIHNlcGFyYXRlIG91dCB0aGUgdmlkZW9QZXJjZW50YWdlIHByb3BcbiAgICAgIHZhciB2aWRlb1BlcmNlbnRhZ2UgPSBwcm9wcy52aWRlb1BlcmNlbnRhZ2UsXG4gICAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeShyZXN0UHJvcHMpICE9PSBsYXN0UHJvcHNTdHJpbmcpIHtcbiAgICAgICAgLy8gaWYgc2Nyb2xseXZpZGVvIGFscmVhZHkgZXhpc3RzIGFuZCBhbnkgcGFyYW1ldGVyIGlzIHVwZGF0ZWQsIGRlc3Ryb3kgYW5kIHJlY3JlYXRlLlxuICAgICAgICBpZiAoc2Nyb2xseVZpZGVvUmVmLmN1cnJlbnQgJiYgc2Nyb2xseVZpZGVvUmVmLmN1cnJlbnQuZGVzdHJveSkgc2Nyb2xseVZpZGVvUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xuICAgICAgICBzY3JvbGx5VmlkZW9SZWYuY3VycmVudCA9IG5ldyBTY3JvbGx5VmlkZW8oX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNjcm9sbHlWaWRlb0NvbnRhaW5lcjogY29udGFpbmVyRWxlbWVudC5jdXJyZW50XG4gICAgICAgIH0sIHByb3BzKSk7XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgbmV3IHByb3BzXG4gICAgICAgIHNldExhc3RQcm9wc1N0cmluZyhKU09OLnN0cmluZ2lmeShyZXN0UHJvcHMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHRhcmdldCB0aW1lIHBlcmNlbnRcbiAgICAgIGlmIChzY3JvbGx5VmlkZW9SZWYuY3VycmVudCAmJiB0eXBlb2YgdmlkZW9QZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJiB2aWRlb1BlcmNlbnRhZ2UgPj0gMCAmJiB2aWRlb1BlcmNlbnRhZ2UgPD0gMSkge1xuICAgICAgICBzY3JvbGx5VmlkZW9SZWYuY3VycmVudC5zZXRUYXJnZXRUaW1lUGVyY2VudCh2aWRlb1BlcmNlbnRhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFudXAgdGhlIGNvbXBvbmVudCBvbiB1bm1vdW50XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY3JvbGx5VmlkZW9SZWYuY3VycmVudCAmJiBzY3JvbGx5VmlkZW9SZWYuY3VycmVudC5kZXN0cm95KSBzY3JvbGx5VmlkZW9SZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgfTtcbiAgfSwgW2NvbnRhaW5lckVsZW1lbnQsIHByb3BzXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyRWxlbWVudFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGx5VmlkZW9Db21wb25lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/scrolly-video/dist/ScrollyVideo.cjs.jsx\n"));

/***/ })

});